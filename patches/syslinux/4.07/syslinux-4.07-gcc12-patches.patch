diff -uprN -X dontdiff Syslinux-4.07a/Makefile syslinux-4.07b/Makefile
--- Syslinux-4.07a/Makefile	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/Makefile	2023-02-08 14:50:58.634320430 +0100
@@ -42,7 +42,7 @@ BTARGET  = version.gen version.h version
 BOBJECTS = $(BTARGET) \
 	mbr/*.bin \
 	core/pxelinux.0 core/isolinux.bin core/isolinux-debug.bin \
-	gpxe/gpxelinux.0 dos/syslinux.com \
+	dos/syslinux.com \
 	win32/syslinux.exe win64/syslinux64.exe \
 	dosutil/*.com dosutil/*.sys \
 	$(MODULES)
@@ -50,10 +50,12 @@ BOBJECTS = $(BTARGET) \
 # BSUBDIRs build the on-target binary components.
 # ISUBDIRs build the installer (host) components.
 #
+#CC = gcc
+#CFLAGS = -c -std=c99
 # Note: libinstaller is both a BSUBDIR and an ISUBDIR.  It contains
 # files that depend only on the B phase, but may have to be regenerated
 # for "make installer".
-BSUBDIRS = codepage com32 lzo core memdisk modules mbr memdump gpxe sample \
+BSUBDIRS = codepage com32 lzo core memdisk modules mbr memdump sample \
 	   diag libinstaller dos win32 win64 dosutil
 ITARGET  =
 IOBJECTS = $(ITARGET) \
@@ -66,7 +68,7 @@ INSTALL_BIN   =	mtools/syslinux
 # Things to install in /sbin
 INSTALL_SBIN  = extlinux/extlinux
 # Things to install in /usr/lib/syslinux
-INSTALL_AUX   =	core/pxelinux.0 gpxe/gpxelinux.0 gpxe/gpxelinuxk.0 \
+INSTALL_AUX   =	core/pxelinux.0 \
 		core/isolinux.bin core/isolinux-debug.bin \
 		dos/syslinux.com \
 		mbr/*.bin $(MODULES)
@@ -81,7 +83,7 @@ INSTALLSUBDIRS = com32 utils dosutil
 EXTBOOTINSTALL = $(MODULES)
 
 # Things to install in /tftpboot
-NETINSTALLABLE = core/pxelinux.0 gpxe/gpxelinux.0 \
+NETINSTALLABLE = core/pxelinux.0 \
 		 $(MODULES)
 
 all:
diff -uprN -X dontdiff Syslinux-4.07a/com32/cmenu/libmenu/com32io.h syslinux-4.07b/com32/cmenu/libmenu/com32io.h
--- Syslinux-4.07a/com32/cmenu/libmenu/com32io.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/com32/cmenu/libmenu/com32io.h	2023-02-07 19:48:56.718820811 +0100
@@ -32,6 +32,8 @@
 // actually 1<<1 is Left Shift, 1<<0 is right shift
 #define SHIFT_PRESSED (1<<1 | 1 <<0)
 
+extern com32sys_t inreg, outreg;	// Global register sets for use
+
 /* BIOS Assisted output routines */
 
 void getpos(char *row, char *col, char page);
diff -uprN -X dontdiff Syslinux-4.07a/com32/cmenu/libmenu/menu.c syslinux-4.07b/com32/cmenu/libmenu/menu.c
--- Syslinux-4.07a/com32/cmenu/libmenu/menu.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/com32/cmenu/libmenu/menu.c	2023-02-07 19:47:46.202448450 +0100
@@ -15,6 +15,8 @@
 #include <stdlib.h>
 #include <console.h>
 
+t_handler_return ACTION_VALID, ACTION_INVALID;
+
 // Local Variables
 static pt_menusystem ms;    // Pointer to the menusystem
 char TITLESTR[] =
diff -uprN -X dontdiff Syslinux-4.07a/com32/cmenu/libmenu/menu.h syslinux-4.07b/com32/cmenu/libmenu/menu.h
--- Syslinux-4.07a/com32/cmenu/libmenu/menu.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/com32/cmenu/libmenu/menu.h	2023-02-07 19:47:11.990295734 +0100
@@ -131,7 +131,7 @@ typedef struct {
     unsigned int reserved:6;	// For future expansion
 } t_handler_return;
 
-t_handler_return ACTION_VALID, ACTION_INVALID;	// Specific values
+extern t_handler_return ACTION_VALID, ACTION_INVALID;	// Specific values
 
 typedef t_handler_return(*t_item_handler) (struct s_menusystem *,
 					   struct s_menuitem *);
diff -uprN -X dontdiff Syslinux-4.07a/com32/cmenu/libmenu/syslnx.c syslinux-4.07b/com32/cmenu/libmenu/syslnx.c
--- Syslinux-4.07a/com32/cmenu/libmenu/syslnx.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/com32/cmenu/libmenu/syslnx.c	2023-02-07 19:49:33.619040925 +0100
@@ -14,7 +14,7 @@
 #include <com32.h>
 #include "syslnx.h"
 
-com32sys_t inreg, outreg;	// Global registers for this module
+extern com32sys_t inreg, outreg;	// Global registers for this module
 
 char issyslinux(void)
 {
diff -uprN -X dontdiff Syslinux-4.07a/com32/cmenu/libmenu/tui.c syslinux-4.07b/com32/cmenu/libmenu/tui.c
--- Syslinux-4.07a/com32/cmenu/libmenu/tui.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/com32/cmenu/libmenu/tui.c	2023-02-07 19:50:02.827211225 +0100
@@ -16,8 +16,6 @@
 #include <stdlib.h>
 #include "com32io.h"
 
-com32sys_t inreg, outreg;	// Global register sets for use
-
 char bkspstr[] = " \b$";
 char eolstr[] = "\n$";
 
diff -uprN -X dontdiff Syslinux-4.07a/com32/gplinclude/memory.h syslinux-4.07b/com32/gplinclude/memory.h
--- Syslinux-4.07a/com32/gplinclude/memory.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/com32/gplinclude/memory.h	2023-02-07 19:50:39.811422118 +0100
@@ -37,7 +37,7 @@ struct e820entry {
     uint64_t type;		/* type of memory segment */
 } __attribute__ ((packed));
 
-const char *const e820_types[5];
+extern const char *const e820_types[5];
 
 void get_type(int, char *, int);
 void detect_memory_e820(struct e820entry *desc, int size_map, int *size_found);
diff -uprN -X dontdiff Syslinux-4.07a/com32/hdt/hdt-cli.c syslinux-4.07b/com32/hdt/hdt-cli.c
--- Syslinux-4.07a/com32/hdt/hdt-cli.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/com32/hdt/hdt-cli.c	2023-02-07 19:51:03.379553880 +0100
@@ -34,6 +34,7 @@
 #include "hdt-cli.h"
 #include "hdt-common.h"
 
+struct s_cli hdt_cli;
 struct cli_mode_descr *list_modes[] = {
     &hdt_mode,
     &dmi_mode,
diff -uprN -X dontdiff Syslinux-4.07a/com32/hdt/hdt-cli.h syslinux-4.07b/com32/hdt/hdt-cli.h
--- Syslinux-4.07a/com32/hdt/hdt-cli.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/com32/hdt/hdt-cli.h	2023-02-07 19:40:59.480394836 +0100
@@ -98,7 +98,7 @@ struct s_cli {
     int history_pos;
     int max_history_pos;
 };
-struct s_cli hdt_cli;
+extern struct s_cli hdt_cli;
 
 /* Describe a cli mode */
 struct cli_mode_descr {
@@ -136,18 +136,18 @@ struct cli_alias {
 
 /* List of implemented modes */
 extern struct cli_mode_descr *list_modes[];
-struct cli_mode_descr hdt_mode;
-struct cli_mode_descr dmi_mode;
-struct cli_mode_descr syslinux_mode;
-struct cli_mode_descr pxe_mode;
-struct cli_mode_descr kernel_mode;
-struct cli_mode_descr cpu_mode;
-struct cli_mode_descr pci_mode;
-struct cli_mode_descr vesa_mode;
-struct cli_mode_descr disk_mode;
-struct cli_mode_descr vpd_mode;
-struct cli_mode_descr memory_mode;
-struct cli_mode_descr acpi_mode;
+extern struct cli_mode_descr hdt_mode;
+extern struct cli_mode_descr dmi_mode;
+extern struct cli_mode_descr syslinux_mode;
+extern struct cli_mode_descr pxe_mode;
+extern struct cli_mode_descr kernel_mode;
+extern struct cli_mode_descr cpu_mode;
+extern struct cli_mode_descr pci_mode;
+extern struct cli_mode_descr vesa_mode;
+extern struct cli_mode_descr disk_mode;
+extern struct cli_mode_descr vpd_mode;
+extern struct cli_mode_descr memory_mode;
+extern struct cli_mode_descr acpi_mode;
 
 /* cli helpers */
 void find_cli_mode_descr(cli_mode_t mode, struct cli_mode_descr **mode_found);
diff -uprN -X dontdiff Syslinux-4.07a/com32/hdt/hdt-common.c syslinux-4.07b/com32/hdt/hdt-common.c
--- Syslinux-4.07a/com32/hdt/hdt-common.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/com32/hdt/hdt-common.c	2023-02-07 19:55:07.944808515 +0100
@@ -37,6 +37,24 @@
 #include <disk/mbrs.h>
 #include <memory.h>
 
+struct upload_backend *upload;
+
+/* Defines if the cli is quiet*/
+bool quiet;
+
+/* Defines if the cli is totally silent*/
+bool silent;
+
+/* Defines if we must use the vesa mode */
+bool vesamode;
+
+/* Defines if we must use the menu mode */
+bool menumode;
+
+/* Defines if we are running the auto mode */
+bool automode;
+
+
 /* ISOlinux requires a 8.3 format */
 void convert_isolinux_filename(char *filename, struct s_hardware *hardware)
 {
diff -uprN -X dontdiff Syslinux-4.07a/com32/hdt/hdt-common.h syslinux-4.07b/com32/hdt/hdt-common.h
--- Syslinux-4.07a/com32/hdt/hdt-common.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/com32/hdt/hdt-common.h	2023-02-07 19:42:09.368788519 +0100
@@ -82,22 +82,22 @@
 #define MAX_CLI_LINES 20
 #define MAX_VESA_CLI_LINES 24
 
-struct upload_backend *upload;
+extern struct upload_backend *upload;
 
 /* Defines if the cli is quiet*/
-bool quiet;
+extern bool quiet;
 
 /* Defines if the cli is totally silent*/
-bool silent;
+extern bool silent;
 
 /* Defines if we must use the vesa mode */
-bool vesamode;
+extern bool vesamode;
 
 /* Defines if we must use the menu mode */
-bool menumode;
+extern bool menumode;
 
 /* Defines if we are running the auto mode */
-bool automode;
+extern bool automode;
 
 /* Defines the number of lines in the console
  * Default is 20 for a std console */
diff -uprN -X dontdiff Syslinux-4.07a/com32/lib/getopt_long.c syslinux-4.07b/com32/lib/getopt_long.c
--- Syslinux-4.07a/com32/lib/getopt_long.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/com32/lib/getopt_long.c	2023-02-07 19:43:05.833093033 +0100
@@ -13,8 +13,8 @@
 #include <string.h>
 #include <getopt.h>
 
-char *optarg;
-int optind, opterr, optopt;
+extern char *optarg;
+extern int optind, opterr, optopt;
 static struct getopt_private_state {
 	const char *optptr;
 	const char *last_optstring;
diff -uprN -X dontdiff Syslinux-4.07a/com32/lib/sys/openmem.c syslinux-4.07b/com32/lib/sys/openmem.c
--- Syslinux-4.07a/com32/lib/sys/openmem.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/com32/lib/sys/openmem.c	2023-02-07 19:43:42.301283669 +0100
@@ -38,7 +38,7 @@
  * Open a chunk of memory as if it was a file
  */
 
-const struct input_dev __file_dev;
+extern const struct input_dev __file_dev;
 
 int openmem(const void *base, size_t len, int flags)
 {
diff -uprN -X dontdiff Syslinux-4.07a/dos/errno.h syslinux-4.07b/dos/errno.h
--- Syslinux-4.07a/dos/errno.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/dos/errno.h	2023-02-08 15:00:21.408259711 +0100
@@ -36,7 +36,7 @@
 #define	EDOM		33	/* Math argument out of domain of func */
 #define	ERANGE		34	/* Math result not representable */
 
-int errno;
+extern int errno;
 void perror(const char *);
 
 #endif /* ERRNO_H */
diff -uprN -X dontdiff Syslinux-4.07a/extlinux/main.c syslinux-4.07b/extlinux/main.c
--- Syslinux-4.07a/extlinux/main.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/extlinux/main.c	2023-02-08 15:18:43.705875042 +0100
@@ -38,6 +38,7 @@
 #include <sys/ioctl.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <sys/sysmacros.h>
 #include <sys/mount.h>
 #include <sys/vfs.h>
 
diff -uprN -X dontdiff Syslinux-4.07a/libinstaller/fs.c syslinux-4.07b/libinstaller/fs.c
--- Syslinux-4.07a/libinstaller/fs.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/libinstaller/fs.c	2023-02-08 14:57:01.023575019 +0100
@@ -28,6 +28,12 @@
 #include "syslxint.h"
 #include "syslxcom.h"
 #include "syslxfs.h"
+size_t strlen(const char *str)
+{
+    const char *s;
+    for (s = str; *s; ++s);
+    return (s - str);
+}
 
 void syslinux_make_bootsect(void *bs, int fs_type)
 {
diff -uprN -X dontdiff Syslinux-4.07a/libinstaller/setadv.c syslinux-4.07b/libinstaller/setadv.c
--- Syslinux-4.07a/libinstaller/setadv.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/libinstaller/setadv.c	2023-02-08 15:01:03.976404359 +0100
@@ -31,6 +31,7 @@
 #include "syslxint.h"
 #include "syslxcom.h"
 #include "syslxfs.h"
+int errno;
 
 unsigned char syslinux_adv[2 * ADV_SIZE];
 
diff -uprN -X dontdiff Syslinux-4.07a/libinstaller/syslinux.h syslinux-4.07b/libinstaller/syslinux.h
--- Syslinux-4.07a/libinstaller/syslinux.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/libinstaller/syslinux.h	2023-02-08 14:57:35.899694645 +0100
@@ -17,6 +17,8 @@
 #include "advconst.h"
 #include "setadv.h"
 
+extern size_t strlen(const char *str);
+
 /* The standard boot sector and ldlinux image */
 extern unsigned char syslinux_bootsect[];
 extern const unsigned int syslinux_bootsect_len;
diff -uprN -X dontdiff Syslinux-4.07a/lzo/include/lzo/lzo1.h syslinux-4.07b/lzo/include/lzo/lzo1.h
--- Syslinux-4.07a/lzo/include/lzo/lzo1.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/include/lzo/lzo1.h	2023-02-08 12:45:25.599552219 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -39,7 +27,7 @@
 
 
 #ifndef __LZO1_H_INCLUDED
-#define __LZO1_H_INCLUDED
+#define __LZO1_H_INCLUDED 1
 
 #ifndef __LZOCONF_H_INCLUDED
 #include "lzoconf.h"
@@ -58,7 +46,7 @@ extern "C" {
  * When the required size is 0, you can also pass a NULL pointer.
  */
 
-#define LZO1_MEM_COMPRESS       ((lzo_uint32) (8192L * lzo_sizeof_dict_t))
+#define LZO1_MEM_COMPRESS       ((lzo_uint32_t) (8192L * lzo_sizeof_dict_t))
 #define LZO1_MEM_DECOMPRESS     (0)
 
 
@@ -77,7 +65,7 @@ lzo1_decompress         ( const lzo_byte
 // better compression ratio at the cost of more memory and time
 ************************************************************************/
 
-#define LZO1_99_MEM_COMPRESS    ((lzo_uint32) (65536L * lzo_sizeof_dict_t))
+#define LZO1_99_MEM_COMPRESS    ((lzo_uint32_t) (65536L * lzo_sizeof_dict_t))
 
 LZO_EXTERN(int)
 lzo1_99_compress        ( const lzo_bytep src, lzo_uint  src_len,
diff -uprN -X dontdiff Syslinux-4.07a/lzo/include/lzo/lzo1a.h syslinux-4.07b/lzo/include/lzo/lzo1a.h
--- Syslinux-4.07a/lzo/include/lzo/lzo1a.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/include/lzo/lzo1a.h	2023-02-08 12:45:25.599552219 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -39,7 +27,7 @@
 
 
 #ifndef __LZO1A_H_INCLUDED
-#define __LZO1A_H_INCLUDED
+#define __LZO1A_H_INCLUDED 1
 
 #ifndef __LZOCONF_H_INCLUDED
 #include "lzoconf.h"
@@ -58,7 +46,7 @@ extern "C" {
  * When the required size is 0, you can also pass a NULL pointer.
  */
 
-#define LZO1A_MEM_COMPRESS      ((lzo_uint32) (8192L * lzo_sizeof_dict_t))
+#define LZO1A_MEM_COMPRESS      ((lzo_uint32_t) (8192L * lzo_sizeof_dict_t))
 #define LZO1A_MEM_DECOMPRESS    (0)
 
 
@@ -77,7 +65,7 @@ lzo1a_decompress        ( const lzo_byte
 // better compression ratio at the cost of more memory and time
 ************************************************************************/
 
-#define LZO1A_99_MEM_COMPRESS   ((lzo_uint32) (65536L * lzo_sizeof_dict_t))
+#define LZO1A_99_MEM_COMPRESS   ((lzo_uint32_t) (65536L * lzo_sizeof_dict_t))
 
 LZO_EXTERN(int)
 lzo1a_99_compress       ( const lzo_bytep src, lzo_uint  src_len,
diff -uprN -X dontdiff Syslinux-4.07a/lzo/include/lzo/lzo1b.h syslinux-4.07b/lzo/include/lzo/lzo1b.h
--- Syslinux-4.07a/lzo/include/lzo/lzo1b.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/include/lzo/lzo1b.h	2023-02-08 12:45:25.599552219 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -39,7 +27,7 @@
 
 
 #ifndef __LZO1B_H_INCLUDED
-#define __LZO1B_H_INCLUDED
+#define __LZO1B_H_INCLUDED 1
 
 #ifndef __LZOCONF_H_INCLUDED
 #include "lzoconf.h"
@@ -58,7 +46,7 @@ extern "C" {
  * When the required size is 0, you can also pass a NULL pointer.
  */
 
-#define LZO1B_MEM_COMPRESS      ((lzo_uint32) (16384L * lzo_sizeof_dict_t))
+#define LZO1B_MEM_COMPRESS      ((lzo_uint32_t) (16384L * lzo_sizeof_dict_t))
 #define LZO1B_MEM_DECOMPRESS    (0)
 
 
@@ -133,7 +121,7 @@ lzo1b_9_compress        ( const lzo_byte
 // better compression ratio at the cost of more memory and time
 ************************************************************************/
 
-#define LZO1B_99_MEM_COMPRESS   ((lzo_uint32) (65536L * lzo_sizeof_dict_t))
+#define LZO1B_99_MEM_COMPRESS   ((lzo_uint32_t) (65536L * lzo_sizeof_dict_t))
 
 LZO_EXTERN(int)
 lzo1b_99_compress       ( const lzo_bytep src, lzo_uint  src_len,
@@ -141,7 +129,7 @@ lzo1b_99_compress       ( const lzo_byte
                                 lzo_voidp wrkmem );
 
 
-#define LZO1B_999_MEM_COMPRESS  ((lzo_uint32) (3 * 65536L * sizeof(lzo_xint)))
+#define LZO1B_999_MEM_COMPRESS  ((lzo_uint32_t) (3 * 65536L * sizeof(lzo_xint)))
 
 LZO_EXTERN(int)
 lzo1b_999_compress      ( const lzo_bytep src, lzo_uint  src_len,
diff -uprN -X dontdiff Syslinux-4.07a/lzo/include/lzo/lzo1c.h syslinux-4.07b/lzo/include/lzo/lzo1c.h
--- Syslinux-4.07a/lzo/include/lzo/lzo1c.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/include/lzo/lzo1c.h	2023-02-08 12:45:25.599552219 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -39,7 +27,7 @@
 
 
 #ifndef __LZO1C_H_INCLUDED
-#define __LZO1C_H_INCLUDED
+#define __LZO1C_H_INCLUDED 1
 
 #ifndef __LZOCONF_H_INCLUDED
 #include "lzoconf.h"
@@ -58,7 +46,7 @@ extern "C" {
  * When the required size is 0, you can also pass a NULL pointer.
  */
 
-#define LZO1C_MEM_COMPRESS      ((lzo_uint32) (16384L * lzo_sizeof_dict_t))
+#define LZO1C_MEM_COMPRESS      ((lzo_uint32_t) (16384L * lzo_sizeof_dict_t))
 #define LZO1C_MEM_DECOMPRESS    (0)
 
 
@@ -133,7 +121,7 @@ lzo1c_9_compress        ( const lzo_byte
 // better compression ratio at the cost of more memory and time
 ************************************************************************/
 
-#define LZO1C_99_MEM_COMPRESS   ((lzo_uint32) (65536L * lzo_sizeof_dict_t))
+#define LZO1C_99_MEM_COMPRESS   ((lzo_uint32_t) (65536L * lzo_sizeof_dict_t))
 
 LZO_EXTERN(int)
 lzo1c_99_compress       ( const lzo_bytep src, lzo_uint  src_len,
@@ -141,7 +129,7 @@ lzo1c_99_compress       ( const lzo_byte
                                 lzo_voidp wrkmem );
 
 
-#define LZO1C_999_MEM_COMPRESS  ((lzo_uint32) (5 * 16384L * sizeof(short)))
+#define LZO1C_999_MEM_COMPRESS  ((lzo_uint32_t) (5 * 16384L * sizeof(short)))
 
 LZO_EXTERN(int)
 lzo1c_999_compress      ( const lzo_bytep src, lzo_uint  src_len,
diff -uprN -X dontdiff Syslinux-4.07a/lzo/include/lzo/lzo1f.h syslinux-4.07b/lzo/include/lzo/lzo1f.h
--- Syslinux-4.07a/lzo/include/lzo/lzo1f.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/include/lzo/lzo1f.h	2023-02-08 12:45:25.599552219 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -39,7 +27,7 @@
 
 
 #ifndef __LZO1F_H_INCLUDED
-#define __LZO1F_H_INCLUDED
+#define __LZO1F_H_INCLUDED 1
 
 #ifndef __LZOCONF_H_INCLUDED
 #include "lzoconf.h"
@@ -58,7 +46,7 @@ extern "C" {
  * When the required size is 0, you can also pass a NULL pointer.
  */
 
-#define LZO1F_MEM_COMPRESS      ((lzo_uint32) (16384L * lzo_sizeof_dict_t))
+#define LZO1F_MEM_COMPRESS      ((lzo_uint32_t) (16384L * lzo_sizeof_dict_t))
 #define LZO1F_MEM_DECOMPRESS    (0)
 
 
@@ -89,7 +77,7 @@ lzo1f_1_compress        ( const lzo_byte
 // better compression ratio at the cost of more memory and time
 ************************************************************************/
 
-#define LZO1F_999_MEM_COMPRESS  ((lzo_uint32) (5 * 16384L * sizeof(short)))
+#define LZO1F_999_MEM_COMPRESS  ((lzo_uint32_t) (5 * 16384L * sizeof(short)))
 
 LZO_EXTERN(int)
 lzo1f_999_compress      ( const lzo_bytep src, lzo_uint  src_len,
diff -uprN -X dontdiff Syslinux-4.07a/lzo/include/lzo/lzo1x.h syslinux-4.07b/lzo/include/lzo/lzo1x.h
--- Syslinux-4.07a/lzo/include/lzo/lzo1x.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/include/lzo/lzo1x.h	2023-02-08 12:45:25.599552219 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -39,7 +27,7 @@
 
 
 #ifndef __LZO1X_H_INCLUDED
-#define __LZO1X_H_INCLUDED
+#define __LZO1X_H_INCLUDED 1
 
 #ifndef __LZOCONF_H_INCLUDED
 #include "lzoconf.h"
@@ -80,7 +68,7 @@ lzo1x_decompress_safe   ( const lzo_byte
 //
 ************************************************************************/
 
-#define LZO1X_1_MEM_COMPRESS    ((lzo_uint32) (16384L * lzo_sizeof_dict_t))
+#define LZO1X_1_MEM_COMPRESS    ((lzo_uint32_t) (16384L * lzo_sizeof_dict_t))
 
 LZO_EXTERN(int)
 lzo1x_1_compress        ( const lzo_bytep src, lzo_uint  src_len,
@@ -92,8 +80,8 @@ lzo1x_1_compress        ( const lzo_byte
 // special compressor versions
 ************************************************************************/
 
-/* this version needs only 8 kB work memory */
-#define LZO1X_1_11_MEM_COMPRESS ((lzo_uint32) (2048L * lzo_sizeof_dict_t))
+/* this version needs only 8 KiB work memory */
+#define LZO1X_1_11_MEM_COMPRESS ((lzo_uint32_t) (2048L * lzo_sizeof_dict_t))
 
 LZO_EXTERN(int)
 lzo1x_1_11_compress     ( const lzo_bytep src, lzo_uint  src_len,
@@ -101,8 +89,8 @@ lzo1x_1_11_compress     ( const lzo_byte
                                 lzo_voidp wrkmem );
 
 
-/* this version needs 16 kB work memory */
-#define LZO1X_1_12_MEM_COMPRESS ((lzo_uint32) (4096L * lzo_sizeof_dict_t))
+/* this version needs 16 KiB work memory */
+#define LZO1X_1_12_MEM_COMPRESS ((lzo_uint32_t) (4096L * lzo_sizeof_dict_t))
 
 LZO_EXTERN(int)
 lzo1x_1_12_compress     ( const lzo_bytep src, lzo_uint  src_len,
@@ -111,7 +99,7 @@ lzo1x_1_12_compress     ( const lzo_byte
 
 
 /* use this version if you need a little more compression speed */
-#define LZO1X_1_15_MEM_COMPRESS ((lzo_uint32) (32768L * lzo_sizeof_dict_t))
+#define LZO1X_1_15_MEM_COMPRESS ((lzo_uint32_t) (32768L * lzo_sizeof_dict_t))
 
 LZO_EXTERN(int)
 lzo1x_1_15_compress     ( const lzo_bytep src, lzo_uint  src_len,
@@ -123,7 +111,7 @@ lzo1x_1_15_compress     ( const lzo_byte
 // better compression ratio at the cost of more memory and time
 ************************************************************************/
 
-#define LZO1X_999_MEM_COMPRESS  ((lzo_uint32) (14 * 16384L * sizeof(short)))
+#define LZO1X_999_MEM_COMPRESS  ((lzo_uint32_t) (14 * 16384L * sizeof(short)))
 
 LZO_EXTERN(int)
 lzo1x_999_compress      ( const lzo_bytep src, lzo_uint  src_len,
@@ -136,22 +124,22 @@ lzo1x_999_compress      ( const lzo_byte
 ************************************************************************/
 
 LZO_EXTERN(int)
-lzo1x_999_compress_dict     ( const lzo_bytep in , lzo_uint  in_len,
-                                    lzo_bytep out, lzo_uintp out_len,
+lzo1x_999_compress_dict     ( const lzo_bytep src, lzo_uint  src_len,
+                                    lzo_bytep dst, lzo_uintp dst_len,
                                     lzo_voidp wrkmem,
                               const lzo_bytep dict, lzo_uint dict_len );
 
 LZO_EXTERN(int)
-lzo1x_999_compress_level    ( const lzo_bytep in , lzo_uint  in_len,
-                                    lzo_bytep out, lzo_uintp out_len,
+lzo1x_999_compress_level    ( const lzo_bytep src, lzo_uint  src_len,
+                                    lzo_bytep dst, lzo_uintp dst_len,
                                     lzo_voidp wrkmem,
                               const lzo_bytep dict, lzo_uint dict_len,
                                     lzo_callback_p cb,
                                     int compression_level );
 
 LZO_EXTERN(int)
-lzo1x_decompress_dict_safe ( const lzo_bytep in,  lzo_uint  in_len,
-                                   lzo_bytep out, lzo_uintp out_len,
+lzo1x_decompress_dict_safe ( const lzo_bytep src, lzo_uint  src_len,
+                                   lzo_bytep dst, lzo_uintp dst_len,
                                    lzo_voidp wrkmem /* NOT USED */,
                              const lzo_bytep dict, lzo_uint dict_len );
 
@@ -161,8 +149,8 @@ lzo1x_decompress_dict_safe ( const lzo_b
 ************************************************************************/
 
 LZO_EXTERN(int)
-lzo1x_optimize          (       lzo_bytep in , lzo_uint  in_len,
-                                lzo_bytep out, lzo_uintp out_len,
+lzo1x_optimize          (       lzo_bytep src, lzo_uint  src_len,
+                                lzo_bytep dst, lzo_uintp dst_len,
                                 lzo_voidp wrkmem /* NOT USED */ );
 
 
diff -uprN -X dontdiff Syslinux-4.07a/lzo/include/lzo/lzo1y.h syslinux-4.07b/lzo/include/lzo/lzo1y.h
--- Syslinux-4.07a/lzo/include/lzo/lzo1y.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/include/lzo/lzo1y.h	2023-02-08 12:45:25.599552219 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -39,7 +27,7 @@
 
 
 #ifndef __LZO1Y_H_INCLUDED
-#define __LZO1Y_H_INCLUDED
+#define __LZO1Y_H_INCLUDED 1
 
 #ifndef __LZOCONF_H_INCLUDED
 #include "lzoconf.h"
@@ -58,7 +46,7 @@ extern "C" {
  * When the required size is 0, you can also pass a NULL pointer.
  */
 
-#define LZO1Y_MEM_COMPRESS      ((lzo_uint32) (16384L * lzo_sizeof_dict_t))
+#define LZO1Y_MEM_COMPRESS      ((lzo_uint32_t) (16384L * lzo_sizeof_dict_t))
 #define LZO1Y_MEM_DECOMPRESS    (0)
 #define LZO1Y_MEM_OPTIMIZE      (0)
 
@@ -90,7 +78,7 @@ lzo1y_1_compress        ( const lzo_byte
 // better compression ratio at the cost of more memory and time
 ************************************************************************/
 
-#define LZO1Y_999_MEM_COMPRESS  ((lzo_uint32) (14 * 16384L * sizeof(short)))
+#define LZO1Y_999_MEM_COMPRESS  ((lzo_uint32_t) (14 * 16384L * sizeof(short)))
 
 LZO_EXTERN(int)
 lzo1y_999_compress      ( const lzo_bytep src, lzo_uint  src_len,
@@ -104,22 +92,22 @@ lzo1y_999_compress      ( const lzo_byte
 ************************************************************************/
 
 LZO_EXTERN(int)
-lzo1y_999_compress_dict     ( const lzo_bytep in , lzo_uint  in_len,
-                                    lzo_bytep out, lzo_uintp out_len,
+lzo1y_999_compress_dict     ( const lzo_bytep src, lzo_uint  src_len,
+                                    lzo_bytep dst, lzo_uintp dst_len,
                                     lzo_voidp wrkmem,
                               const lzo_bytep dict, lzo_uint dict_len );
 
 LZO_EXTERN(int)
-lzo1y_999_compress_level    ( const lzo_bytep in , lzo_uint  in_len,
-                                    lzo_bytep out, lzo_uintp out_len,
+lzo1y_999_compress_level    ( const lzo_bytep src, lzo_uint  src_len,
+                                    lzo_bytep dst, lzo_uintp dst_len,
                                     lzo_voidp wrkmem,
                               const lzo_bytep dict, lzo_uint dict_len,
                                     lzo_callback_p cb,
                                     int compression_level );
 
 LZO_EXTERN(int)
-lzo1y_decompress_dict_safe ( const lzo_bytep in,  lzo_uint  in_len,
-                                   lzo_bytep out, lzo_uintp out_len,
+lzo1y_decompress_dict_safe ( const lzo_bytep src, lzo_uint  src_len,
+                                   lzo_bytep dst, lzo_uintp dst_len,
                                    lzo_voidp wrkmem /* NOT USED */,
                              const lzo_bytep dict, lzo_uint dict_len );
 
@@ -129,8 +117,8 @@ lzo1y_decompress_dict_safe ( const lzo_b
 ************************************************************************/
 
 LZO_EXTERN(int)
-lzo1y_optimize          (       lzo_bytep in , lzo_uint  in_len,
-                                lzo_bytep out, lzo_uintp out_len,
+lzo1y_optimize          (       lzo_bytep src, lzo_uint  src_len,
+                                lzo_bytep dst, lzo_uintp dst_len,
                                 lzo_voidp wrkmem /* NOT USED */ );
 
 
diff -uprN -X dontdiff Syslinux-4.07a/lzo/include/lzo/lzo1z.h syslinux-4.07b/lzo/include/lzo/lzo1z.h
--- Syslinux-4.07a/lzo/include/lzo/lzo1z.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/include/lzo/lzo1z.h	2023-02-08 12:45:25.599552219 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -39,7 +27,7 @@
 
 
 #ifndef __LZO1Z_H_INCLUDED
-#define __LZO1Z_H_INCLUDED
+#define __LZO1Z_H_INCLUDED 1
 
 #ifndef __LZOCONF_H_INCLUDED
 #include "lzoconf.h"
@@ -58,9 +46,7 @@ extern "C" {
  * When the required size is 0, you can also pass a NULL pointer.
  */
 
-#define LZO1Z_MEM_COMPRESS      ((lzo_uint32) (16384L * lzo_sizeof_dict_t))
 #define LZO1Z_MEM_DECOMPRESS    (0)
-#define LZO1Z_MEM_OPTIMIZE      (0)
 
 
 /* decompression */
@@ -77,23 +63,10 @@ lzo1z_decompress_safe   ( const lzo_byte
 
 
 /***********************************************************************
-//
-************************************************************************/
-
-#if 0
-/* not yet implemented */
-LZO_EXTERN(int)
-lzo1z_1_compress        ( const lzo_bytep src, lzo_uint  src_len,
-                                lzo_bytep dst, lzo_uintp dst_len,
-                                lzo_voidp wrkmem );
-#endif
-
-
-/***********************************************************************
 // better compression ratio at the cost of more memory and time
 ************************************************************************/
 
-#define LZO1Z_999_MEM_COMPRESS  ((lzo_uint32) (14 * 16384L * sizeof(short)))
+#define LZO1Z_999_MEM_COMPRESS  ((lzo_uint32_t) (14 * 16384L * sizeof(short)))
 
 LZO_EXTERN(int)
 lzo1z_999_compress      ( const lzo_bytep src, lzo_uint  src_len,
@@ -106,40 +79,26 @@ lzo1z_999_compress      ( const lzo_byte
 ************************************************************************/
 
 LZO_EXTERN(int)
-lzo1z_999_compress_dict     ( const lzo_bytep in , lzo_uint  in_len,
-                                    lzo_bytep out, lzo_uintp out_len,
+lzo1z_999_compress_dict     ( const lzo_bytep src, lzo_uint  src_len,
+                                    lzo_bytep dst, lzo_uintp dst_len,
                                     lzo_voidp wrkmem,
                               const lzo_bytep dict, lzo_uint dict_len );
 
 LZO_EXTERN(int)
-lzo1z_999_compress_level    ( const lzo_bytep in , lzo_uint  in_len,
-                                    lzo_bytep out, lzo_uintp out_len,
+lzo1z_999_compress_level    ( const lzo_bytep src, lzo_uint  src_len,
+                                    lzo_bytep dst, lzo_uintp dst_len,
                                     lzo_voidp wrkmem,
                               const lzo_bytep dict, lzo_uint dict_len,
                                     lzo_callback_p cb,
                                     int compression_level );
 
 LZO_EXTERN(int)
-lzo1z_decompress_dict_safe ( const lzo_bytep in,  lzo_uint  in_len,
-                                   lzo_bytep out, lzo_uintp out_len,
+lzo1z_decompress_dict_safe ( const lzo_bytep src, lzo_uint  src_len,
+                                   lzo_bytep dst, lzo_uintp dst_len,
                                    lzo_voidp wrkmem /* NOT USED */,
                              const lzo_bytep dict, lzo_uint dict_len );
 
 
-/***********************************************************************
-// optimize a compressed data block
-************************************************************************/
-
-#if 0
-/* not yet implemented */
-LZO_EXTERN(int)
-lzo1z_optimize          (       lzo_bytep in , lzo_uint  in_len,
-                                lzo_bytep out, lzo_uintp out_len,
-                                lzo_voidp wrkmem /* NOT USED */ );
-#endif
-
-
-
 #ifdef __cplusplus
 } /* extern "C" */
 #endif
diff -uprN -X dontdiff Syslinux-4.07a/lzo/include/lzo/lzo2a.h syslinux-4.07b/lzo/include/lzo/lzo2a.h
--- Syslinux-4.07a/lzo/include/lzo/lzo2a.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/include/lzo/lzo2a.h	2023-02-08 12:45:25.599552219 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -39,7 +27,7 @@
 
 
 #ifndef __LZO2A_H_INCLUDED
-#define __LZO2A_H_INCLUDED
+#define __LZO2A_H_INCLUDED 1
 
 #ifndef __LZOCONF_H_INCLUDED
 #include "lzoconf.h"
@@ -73,7 +61,7 @@ lzo2a_decompress_safe   ( const lzo_byte
 // better compression ratio at the cost of more memory and time
 ************************************************************************/
 
-#define LZO2A_999_MEM_COMPRESS  ((lzo_uint32) (8 * 16384L * sizeof(short)))
+#define LZO2A_999_MEM_COMPRESS  ((lzo_uint32_t) (8 * 16384L * sizeof(short)))
 
 LZO_EXTERN(int)
 lzo2a_999_compress      ( const lzo_bytep src, lzo_uint  src_len,
diff -uprN -X dontdiff Syslinux-4.07a/lzo/include/lzo/lzo_asm.h syslinux-4.07b/lzo/include/lzo/lzo_asm.h
--- Syslinux-4.07a/lzo/include/lzo/lzo_asm.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/include/lzo/lzo_asm.h	2023-02-08 12:45:25.599552219 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -39,7 +27,7 @@
 
 
 #ifndef __LZO_ASM_H_INCLUDED
-#define __LZO_ASM_H_INCLUDED
+#define __LZO_ASM_H_INCLUDED 1
 
 #ifndef __LZOCONF_H_INCLUDED
 #include "lzoconf.h"
@@ -51,7 +39,20 @@ extern "C" {
 
 
 /***********************************************************************
-// assembly decompressors
+// i386 assembly decompressors
+//
+// NOTE:
+// ====
+//
+// - For reasons of speed all fast assembler decompressors (having '_fast'
+//   in their name) can access (write to) up to 3 bytes past the end of
+//   the decompressed ("dst") block. Data past the end of the compressed
+//   ("src") block is never accessed (read from).
+//   [ technical note: because data is transferred in 32-bit units ]
+//
+// - Please also see asm/i386/00README.TXT and doc/LZO.FAQ for more
+//   important details about the assembler versions.
+//
 ************************************************************************/
 
 LZO_EXTERN(int) lzo1c_decompress_asm
@@ -113,18 +114,18 @@ LZO_EXTERN(int) lzo1y_decompress_asm_fas
 
 #if 0
 
-LZO_EXTERN(lzo_uint32)
-lzo_crc32_asm(lzo_uint32 _c, const lzo_bytep _buf, lzo_uint _len,
-              const lzo_uint32p _crc_table);
+LZO_EXTERN(lzo_uint32_t)
+lzo_crc32_asm(lzo_uint32_t c, const lzo_bytep buf, lzo_uint len,
+              const lzo_uint32_tp tab);
 
-LZO_EXTERN(lzo_uint32)
-lzo_crc32_asm_small(lzo_uint32 _c, const lzo_bytep _buf, lzo_uint _len);
+LZO_EXTERN(lzo_uint32_t)
+lzo_crc32_asm_small(lzo_uint32_t c, const lzo_bytep buf, lzo_uint len);
 
 LZO_EXTERN(int)
-lzo_cpuid_asm(lzo_uint32p /* lzo_uint32 info[16] */ );
+lzo_cpuid_asm(lzo_uint32_tp /* lzo_uint32_t info[16] */ );
 
-LZO_EXTERN(lzo_uint32)
-lzo_rdtsc_asm(lzo_uint32p /* lzo_uint32 ticks[2] */ );
+LZO_EXTERN(lzo_uint32_t)
+lzo_rdtsc_asm(lzo_uint32_tp /* lzo_uint32_t ticks[2] */ );
 
 #endif
 
diff -uprN -X dontdiff Syslinux-4.07a/lzo/include/lzo/lzoconf.h syslinux-4.07b/lzo/include/lzo/lzoconf.h
--- Syslinux-4.07a/lzo/include/lzo/lzoconf.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/include/lzo/lzoconf.h	2023-02-08 12:45:25.599552219 +0100
@@ -1,20 +1,8 @@
-/* lzoconf.h -- configuration for the LZO real-time data compression library
+/* lzoconf.h -- configuration of the LZO data compression library
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -39,11 +27,11 @@
 
 
 #ifndef __LZOCONF_H_INCLUDED
-#define __LZOCONF_H_INCLUDED
+#define __LZOCONF_H_INCLUDED 1
 
-#define LZO_VERSION             0x2030
-#define LZO_VERSION_STRING      "2.03"
-#define LZO_VERSION_DATE        "Apr 30 2008"
+#define LZO_VERSION             0x2070
+#define LZO_VERSION_STRING      "2.07"
+#define LZO_VERSION_DATE        "Jun 25 2014"
 
 /* internal Autoconf configuration file - only used when building LZO */
 #if defined(LZO_HAVE_CONFIG_H)
@@ -60,7 +48,7 @@
 #if !defined(CHAR_BIT) || (CHAR_BIT != 8)
 #  error "invalid CHAR_BIT"
 #endif
-#if !defined(UCHAR_MAX) || !defined(UINT_MAX) || !defined(ULONG_MAX)
+#if !defined(UCHAR_MAX) || !defined(USHRT_MAX) || !defined(UINT_MAX) || !defined(ULONG_MAX)
 #  error "check your compiler installation"
 #endif
 #if (USHRT_MAX < 1) || (UINT_MAX < 1) || (ULONG_MAX < 1)
@@ -82,14 +70,6 @@ extern "C" {
 // some core defines
 ************************************************************************/
 
-#if !defined(LZO_UINT32_C)
-#  if (UINT_MAX < LZO_0xffffffffL)
-#    define LZO_UINT32_C(c)     c ## UL
-#  else
-#    define LZO_UINT32_C(c)     ((c) + 0U)
-#  endif
-#endif
-
 /* memory checkers */
 #if !defined(__LZO_CHECKER)
 #  if defined(__BOUNDS_CHECKING_ON)
@@ -108,28 +88,31 @@ extern "C" {
 // integral and pointer types
 ************************************************************************/
 
-/* lzo_uint should match size_t */
+/* lzo_uint must match size_t */
 #if !defined(LZO_UINT_MAX)
-#  if defined(LZO_ABI_LLP64) /* WIN64 */
-#    if defined(LZO_OS_WIN64)
+#  if (LZO_ABI_LLP64)
+#    if (LZO_OS_WIN64)
      typedef unsigned __int64   lzo_uint;
      typedef __int64            lzo_int;
 #    else
-     typedef unsigned long long lzo_uint;
-     typedef long long          lzo_int;
+     typedef lzo_ullong_t       lzo_uint;
+     typedef lzo_llong_t        lzo_int;
 #    endif
+#    define LZO_SIZEOF_LZO_UINT 8
 #    define LZO_UINT_MAX        0xffffffffffffffffull
 #    define LZO_INT_MAX         9223372036854775807LL
 #    define LZO_INT_MIN         (-1LL - LZO_INT_MAX)
-#  elif defined(LZO_ABI_IP32L64) /* MIPS R5900 */
+#  elif (LZO_ABI_IP32L64) /* MIPS R5900 */
      typedef unsigned int       lzo_uint;
      typedef int                lzo_int;
+#    define LZO_SIZEOF_LZO_UINT LZO_SIZEOF_INT
 #    define LZO_UINT_MAX        UINT_MAX
 #    define LZO_INT_MAX         INT_MAX
 #    define LZO_INT_MIN         INT_MIN
 #  elif (ULONG_MAX >= LZO_0xffffffffL)
      typedef unsigned long      lzo_uint;
      typedef long               lzo_int;
+#    define LZO_SIZEOF_LZO_UINT LZO_SIZEOF_LONG
 #    define LZO_UINT_MAX        ULONG_MAX
 #    define LZO_INT_MAX         LONG_MAX
 #    define LZO_INT_MIN         LONG_MIN
@@ -138,42 +121,22 @@ extern "C" {
 #  endif
 #endif
 
-/* Integral types with 32 bits or more. */
-#if !defined(LZO_UINT32_MAX)
-#  if (UINT_MAX >= LZO_0xffffffffL)
-     typedef unsigned int       lzo_uint32;
-     typedef int                lzo_int32;
-#    define LZO_UINT32_MAX      UINT_MAX
-#    define LZO_INT32_MAX       INT_MAX
-#    define LZO_INT32_MIN       INT_MIN
-#  elif (ULONG_MAX >= LZO_0xffffffffL)
-     typedef unsigned long      lzo_uint32;
-     typedef long               lzo_int32;
-#    define LZO_UINT32_MAX      ULONG_MAX
-#    define LZO_INT32_MAX       LONG_MAX
-#    define LZO_INT32_MIN       LONG_MIN
-#  else
-#    error "lzo_uint32"
-#  endif
-#endif
-
-/* The larger type of lzo_uint and lzo_uint32. */
-#if (LZO_UINT_MAX >= LZO_UINT32_MAX)
+/* The larger type of lzo_uint and lzo_uint32_t. */
+#if (LZO_SIZEOF_LZO_UINT >= 4)
 #  define lzo_xint              lzo_uint
 #else
-#  define lzo_xint              lzo_uint32
+#  define lzo_xint              lzo_uint32_t
 #endif
 
-/* Memory model that allows to access memory at offsets of lzo_uint. */
-#if !defined(__LZO_MMODEL)
-#  if (LZO_UINT_MAX <= UINT_MAX)
-#    define __LZO_MMODEL
-#  elif defined(LZO_HAVE_MM_HUGE_PTR)
-#    define __LZO_MMODEL_HUGE   1
-#    define __LZO_MMODEL        __huge
-#  else
-#    define __LZO_MMODEL
-#  endif
+typedef int lzo_bool;
+
+/* sanity checks */
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint) == LZO_SIZEOF_LZO_UINT)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_xint) >= sizeof(lzo_uint))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_xint) >= sizeof(lzo_uint32_t))
+
+#ifndef __LZO_MMODEL
+#define __LZO_MMODEL            /*empty*/
 #endif
 
 /* no typedef here because of const-pointer issues */
@@ -182,17 +145,52 @@ extern "C" {
 #define lzo_voidp               void __LZO_MMODEL *
 #define lzo_shortp              short __LZO_MMODEL *
 #define lzo_ushortp             unsigned short __LZO_MMODEL *
-#define lzo_uint32p             lzo_uint32 __LZO_MMODEL *
-#define lzo_int32p              lzo_int32 __LZO_MMODEL *
-#define lzo_uintp               lzo_uint __LZO_MMODEL *
 #define lzo_intp                lzo_int __LZO_MMODEL *
+#define lzo_uintp               lzo_uint __LZO_MMODEL *
 #define lzo_xintp               lzo_xint __LZO_MMODEL *
 #define lzo_voidpp              lzo_voidp __LZO_MMODEL *
 #define lzo_bytepp              lzo_bytep __LZO_MMODEL *
-/* deprecated - use `lzo_bytep' instead of `lzo_byte *' */
-#define lzo_byte                unsigned char __LZO_MMODEL
 
-typedef int lzo_bool;
+#define lzo_int8_tp             lzo_int8_t __LZO_MMODEL *
+#define lzo_uint8_tp            lzo_uint8_t __LZO_MMODEL *
+#define lzo_int16_tp            lzo_int16_t __LZO_MMODEL *
+#define lzo_uint16_tp           lzo_uint16_t __LZO_MMODEL *
+#define lzo_int32_tp            lzo_int32_t __LZO_MMODEL *
+#define lzo_uint32_tp           lzo_uint32_t __LZO_MMODEL *
+#if defined(lzo_int64_t)
+#define lzo_int64_tp            lzo_int64_t __LZO_MMODEL *
+#define lzo_uint64_tp           lzo_uint64_t __LZO_MMODEL *
+#endif
+
+/* Older LZO versions used to support ancient systems and memory models
+ * like 16-bit MSDOS with __huge pointers and Cray PVP, but these
+ * obsolete configurations are not supported any longer.
+ */
+#if defined(__LZO_MMODEL_HUGE)
+#error "__LZO_MMODEL_HUGE is unsupported"
+#endif
+#if (LZO_MM_PVP)
+#error "LZO_MM_PVP is unsupported"
+#endif
+#if (LZO_SIZEOF_INT < 4)
+#error "LZO_SIZEOF_INT < 4 is unsupported"
+#endif
+#if (__LZO_UINTPTR_T_IS_POINTER)
+#error "__LZO_UINTPTR_T_IS_POINTER is unsupported"
+#endif
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(int) >= 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint) >= 4)
+/* Strange configurations where sizeof(lzo_uint) != sizeof(size_t) should
+ * work but have not received much testing lately, so be strict here.
+ */
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint) == sizeof(size_t))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint) == sizeof(ptrdiff_t))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint) == sizeof(lzo_uintptr_t))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(void *)   == sizeof(lzo_uintptr_t))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(char *)   == sizeof(lzo_uintptr_t))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long *)   == sizeof(lzo_uintptr_t))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(void *)   == sizeof(lzo_voidp))
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(char *)   == sizeof(lzo_bytep))
 
 
 /***********************************************************************
@@ -215,10 +213,10 @@ typedef int lzo_bool;
 
 /* DLL export information */
 #if !defined(__LZO_EXPORT1)
-#  define __LZO_EXPORT1
+#  define __LZO_EXPORT1         /*empty*/
 #endif
 #if !defined(__LZO_EXPORT2)
-#  define __LZO_EXPORT2
+#  define __LZO_EXPORT2         /*empty*/
 #endif
 
 /* __cdecl calling convention for public C and assembly functions */
@@ -287,7 +285,7 @@ struct lzo_callback_t
     /* a progress indicator callback function (set to 0 to disable) */
     lzo_progress_func_t nprogress;
 
-    /* NOTE: the first parameter "self" of the nalloc/nfree/nprogress
+    /* INFO: the first parameter "self" of the nalloc/nfree/nprogress
      * callbacks points back to this struct, so you are free to store
      * some extra info in the following variables. */
     lzo_voidp user1;
@@ -306,7 +304,7 @@ struct lzo_callback_t
  */
 #define LZO_E_OK                    0
 #define LZO_E_ERROR                 (-1)
-#define LZO_E_OUT_OF_MEMORY         (-2)    /* [not used right now] */
+#define LZO_E_OUT_OF_MEMORY         (-2)    /* [lzo_alloc_func_t failure] */
 #define LZO_E_NOT_COMPRESSIBLE      (-3)    /* [not used right now] */
 #define LZO_E_INPUT_OVERRUN         (-4)
 #define LZO_E_OUTPUT_OVERRUN        (-5)
@@ -314,6 +312,10 @@ struct lzo_callback_t
 #define LZO_E_EOF_NOT_FOUND         (-7)
 #define LZO_E_INPUT_NOT_CONSUMED    (-8)
 #define LZO_E_NOT_YET_IMPLEMENTED   (-9)    /* [not used right now] */
+#define LZO_E_INVALID_ARGUMENT      (-10)
+#define LZO_E_INVALID_ALIGNMENT     (-11)   /* pointer argument is not properly aligned */
+#define LZO_E_OUTPUT_NOT_CONSUMED   (-12)
+#define LZO_E_INTERNAL_ERROR        (-99)
 
 
 #ifndef lzo_sizeof_dict_t
@@ -327,7 +329,7 @@ struct lzo_callback_t
  * compiler's view of various types are consistent.
  */
 #define lzo_init() __lzo_init_v2(LZO_VERSION,(int)sizeof(short),(int)sizeof(int),\
-    (int)sizeof(long),(int)sizeof(lzo_uint32),(int)sizeof(lzo_uint),\
+    (int)sizeof(long),(int)sizeof(lzo_uint32_t),(int)sizeof(lzo_uint),\
     (int)lzo_sizeof_dict_t,(int)sizeof(char *),(int)sizeof(lzo_voidp),\
     (int)sizeof(lzo_callback_t))
 LZO_EXTERN(int) __lzo_init_v2(unsigned,int,int,int,int,int,int,int,int,int);
@@ -341,38 +343,63 @@ LZO_EXTERN(const lzo_charp) _lzo_version
 
 /* string functions */
 LZO_EXTERN(int)
-lzo_memcmp(const lzo_voidp _s1, const lzo_voidp _s2, lzo_uint _len);
+    lzo_memcmp(const lzo_voidp a, const lzo_voidp b, lzo_uint len);
 LZO_EXTERN(lzo_voidp)
-lzo_memcpy(lzo_voidp _dest, const lzo_voidp _src, lzo_uint _len);
+    lzo_memcpy(lzo_voidp dst, const lzo_voidp src, lzo_uint len);
 LZO_EXTERN(lzo_voidp)
-lzo_memmove(lzo_voidp _dest, const lzo_voidp _src, lzo_uint _len);
+    lzo_memmove(lzo_voidp dst, const lzo_voidp src, lzo_uint len);
 LZO_EXTERN(lzo_voidp)
-lzo_memset(lzo_voidp _s, int _c, lzo_uint _len);
+    lzo_memset(lzo_voidp buf, int c, lzo_uint len);
 
 /* checksum functions */
-LZO_EXTERN(lzo_uint32)
-lzo_adler32(lzo_uint32 _adler, const lzo_bytep _buf, lzo_uint _len);
-LZO_EXTERN(lzo_uint32)
-lzo_crc32(lzo_uint32 _c, const lzo_bytep _buf, lzo_uint _len);
-LZO_EXTERN(const lzo_uint32p)
-lzo_get_crc32_table(void);
+LZO_EXTERN(lzo_uint32_t)
+    lzo_adler32(lzo_uint32_t c, const lzo_bytep buf, lzo_uint len);
+LZO_EXTERN(lzo_uint32_t)
+    lzo_crc32(lzo_uint32_t c, const lzo_bytep buf, lzo_uint len);
+LZO_EXTERN(const lzo_uint32_tp)
+    lzo_get_crc32_table(void);
 
 /* misc. */
 LZO_EXTERN(int) _lzo_config_check(void);
-typedef union { lzo_bytep p; lzo_uint u; } __lzo_pu_u;
-typedef union { lzo_bytep p; lzo_uint32 u32; } __lzo_pu32_u;
-typedef union { void *vp; lzo_bytep bp; lzo_uint32 u32; long l; } lzo_align_t;
-
-/* align a char pointer on a boundary that is a multiple of `size' */
-LZO_EXTERN(unsigned) __lzo_align_gap(const lzo_voidp _ptr, lzo_uint _size);
-#define LZO_PTR_ALIGN_UP(_ptr,_size) \
-    ((_ptr) + (lzo_uint) __lzo_align_gap((const lzo_voidp)(_ptr),(lzo_uint)(_size)))
+typedef union {
+    lzo_voidp a00; lzo_bytep a01; lzo_uint a02; lzo_xint a03; lzo_uintptr_t a04;
+    void *a05; unsigned char *a06; unsigned long a07; size_t a08; ptrdiff_t a09;
+#if defined(lzo_int64_t)
+    lzo_uint64_t a10;
+#endif
+} lzo_align_t;
+
+/* align a char pointer on a boundary that is a multiple of 'size' */
+LZO_EXTERN(unsigned) __lzo_align_gap(const lzo_voidp p, lzo_uint size);
+#define LZO_PTR_ALIGN_UP(p,size) \
+    ((p) + (lzo_uint) __lzo_align_gap((const lzo_voidp)(p),(lzo_uint)(size)))
 
 
 /***********************************************************************
-// deprecated macros - only for backward compatibility with LZO v1.xx
+// deprecated macros - only for backward compatibility
 ************************************************************************/
 
+/* deprecated - use 'lzo_bytep' instead of 'lzo_byte *' */
+#define lzo_byte                unsigned char
+/* deprecated type names */
+#define lzo_int32               lzo_int32_t
+#define lzo_uint32              lzo_uint32_t
+#define lzo_int32p              lzo_int32_t __LZO_MMODEL *
+#define lzo_uint32p             lzo_uint32_t __LZO_MMODEL *
+#define LZO_INT32_MAX           LZO_INT32_C(2147483647)
+#define LZO_UINT32_MAX          LZO_UINT32_C(4294967295)
+#if defined(lzo_int64_t)
+#define lzo_int64               lzo_int64_t
+#define lzo_uint64              lzo_uint64_t
+#define lzo_int64p              lzo_int64_t __LZO_MMODEL *
+#define lzo_uint64p             lzo_uint64_t __LZO_MMODEL *
+#define LZO_INT64_MAX           LZO_INT64_C(9223372036854775807)
+#define LZO_UINT64_MAX          LZO_UINT64_C(18446744073709551615)
+#endif
+/* deprecated types */
+typedef union { lzo_bytep a; lzo_uint b; } __lzo_pu_u;
+typedef union { lzo_bytep a; lzo_uint32_t b; } __lzo_pu32_u;
+
 #if defined(LZO_CFG_COMPAT)
 
 #define __LZOCONF_H 1
@@ -395,8 +422,8 @@ LZO_EXTERN(unsigned) __lzo_align_gap(con
 #  define __LZO_WIN 1
 #endif
 
-#define __LZO_CMODEL
-#define __LZO_DMODEL
+#define __LZO_CMODEL            /*empty*/
+#define __LZO_DMODEL            /*empty*/
 #define __LZO_ENTRY             __LZO_CDECL
 #define LZO_EXTERN_CDECL        LZO_EXTERN
 #define LZO_ALIGN               LZO_PTR_ALIGN_UP
diff -uprN -X dontdiff Syslinux-4.07a/lzo/include/lzo/lzodefs.h syslinux-4.07b/lzo/include/lzo/lzodefs.h
--- Syslinux-4.07a/lzo/include/lzo/lzodefs.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/include/lzo/lzodefs.h	2023-02-08 12:45:25.599552219 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -44,12 +32,6 @@
 #if defined(__CYGWIN32__) && !defined(__CYGWIN__)
 #  define __CYGWIN__ __CYGWIN32__
 #endif
-#if defined(__IBMCPP__) && !defined(__IBMC__)
-#  define __IBMC__ __IBMCPP__
-#endif
-#if defined(__ICL) && defined(_WIN32) && !defined(__INTEL_COMPILER)
-#  define __INTEL_COMPILER __ICL
-#endif
 #if 1 && defined(__INTERIX) && defined(__GNUC__) && !defined(_ALL_SOURCE)
 #  define _ALL_SOURCE 1
 #endif
@@ -58,19 +40,30 @@
 #    define __LONG_MAX__ 9223372036854775807L
 #  endif
 #endif
-#if defined(__INTEL_COMPILER) && defined(__linux__)
+#if !defined(LZO_CFG_NO_DISABLE_WUNDEF)
+#if defined(__ARMCC_VERSION)
+#  pragma diag_suppress 193
+#elif defined(__clang__) && defined(__clang_minor__)
+#  pragma clang diagnostic ignored "-Wundef"
+#elif defined(__INTEL_COMPILER)
 #  pragma warning(disable: 193)
-#endif
-#if defined(__KEIL__) && defined(__C166__)
-#  pragma warning disable = 322
-#elif 0 && defined(__C251__)
+#elif defined(__KEIL__) && defined(__C166__)
 #  pragma warning disable = 322
-#endif
-#if defined(_MSC_VER) && !defined(__INTEL_COMPILER) && !defined(__MWERKS__)
-#  if (_MSC_VER >= 1300)
+#elif defined(__GNUC__) && defined(__GNUC_MINOR__) && !defined(__PATHSCALE__)
+#  if ((__GNUC__-0) >= 5 || ((__GNUC__-0) == 4 && (__GNUC_MINOR__-0) >= 2))
+#    pragma GCC diagnostic ignored "-Wundef"
+#  endif
+#elif defined(_MSC_VER) && !defined(__clang__) && !defined(__INTEL_COMPILER) && !defined(__MWERKS__)
+#  if ((_MSC_VER-0) >= 1300)
 #    pragma warning(disable: 4668)
 #  endif
 #endif
+#endif
+#if 0 && defined(__POCC__) && defined(_WIN32)
+#  if (__POCC__ >= 400)
+#    pragma warn(disable: 2216)
+#  endif
+#endif
 #if 0 && defined(__WATCOMC__)
 #  if (__WATCOMC__ >= 1050) && (__WATCOMC__ < 1060)
 #    pragma warning 203 9
@@ -79,13 +72,29 @@
 #if defined(__BORLANDC__) && defined(__MSDOS__) && !defined(__FLAT__)
 #  pragma option -h
 #endif
+#if !(LZO_CFG_NO_DISABLE_WCRTNONSTDC)
+#ifndef _CRT_NONSTDC_NO_DEPRECATE
+#define _CRT_NONSTDC_NO_DEPRECATE 1
+#endif
+#ifndef _CRT_NONSTDC_NO_WARNINGS
+#define _CRT_NONSTDC_NO_WARNINGS 1
+#endif
+#ifndef _CRT_SECURE_NO_DEPRECATE
+#define _CRT_SECURE_NO_DEPRECATE 1
+#endif
+#ifndef _CRT_SECURE_NO_WARNINGS
+#define _CRT_SECURE_NO_WARNINGS 1
+#endif
+#endif
 #if 0
-#define LZO_0xffffL             0xfffful
-#define LZO_0xffffffffL         0xfffffffful
+#define LZO_0xffffUL            0xfffful
+#define LZO_0xffffffffUL        0xfffffffful
 #else
-#define LZO_0xffffL             65535ul
-#define LZO_0xffffffffL         4294967295ul
+#define LZO_0xffffUL            65535ul
+#define LZO_0xffffffffUL        4294967295ul
 #endif
+#define LZO_0xffffL             LZO_0xffffUL
+#define LZO_0xffffffffL         LZO_0xffffffffUL
 #if (LZO_0xffffL == LZO_0xffffffffL)
 #  error "your preprocessor is broken 1"
 #endif
@@ -100,6 +109,13 @@
 #  error "your preprocessor is broken 4"
 #endif
 #endif
+#if defined(__COUNTER__)
+#  ifndef LZO_CFG_USE_COUNTER
+#  define LZO_CFG_USE_COUNTER 1
+#  endif
+#else
+#  undef LZO_CFG_USE_COUNTER
+#endif
 #if (UINT_MAX == LZO_0xffffL)
 #if defined(__ZTC__) && defined(__I86__) && !defined(__OS2__)
 #  if !defined(MSDOS)
@@ -121,7 +137,7 @@
 #endif
 #if defined(_MSC_VER) && defined(M_I86HM) && (UINT_MAX == LZO_0xffffL)
 #  define ptrdiff_t long
-#  define _PTRDIFF_T_DEFINED
+#  define _PTRDIFF_T_DEFINED 1
 #endif
 #if (UINT_MAX == LZO_0xffffL)
 #  undef __LZO_RENAME_A
@@ -230,14 +246,31 @@
 #endif
 #define LZO_PP_STRINGIZE(x)             #x
 #define LZO_PP_MACRO_EXPAND(x)          LZO_PP_STRINGIZE(x)
+#define LZO_PP_CONCAT0()                /*empty*/
+#define LZO_PP_CONCAT1(a)               a
 #define LZO_PP_CONCAT2(a,b)             a ## b
 #define LZO_PP_CONCAT3(a,b,c)           a ## b ## c
 #define LZO_PP_CONCAT4(a,b,c,d)         a ## b ## c ## d
 #define LZO_PP_CONCAT5(a,b,c,d,e)       a ## b ## c ## d ## e
+#define LZO_PP_CONCAT6(a,b,c,d,e,f)     a ## b ## c ## d ## e ## f
+#define LZO_PP_CONCAT7(a,b,c,d,e,f,g)   a ## b ## c ## d ## e ## f ## g
+#define LZO_PP_ECONCAT0()               LZO_PP_CONCAT0()
+#define LZO_PP_ECONCAT1(a)              LZO_PP_CONCAT1(a)
 #define LZO_PP_ECONCAT2(a,b)            LZO_PP_CONCAT2(a,b)
 #define LZO_PP_ECONCAT3(a,b,c)          LZO_PP_CONCAT3(a,b,c)
 #define LZO_PP_ECONCAT4(a,b,c,d)        LZO_PP_CONCAT4(a,b,c,d)
 #define LZO_PP_ECONCAT5(a,b,c,d,e)      LZO_PP_CONCAT5(a,b,c,d,e)
+#define LZO_PP_ECONCAT6(a,b,c,d,e,f)    LZO_PP_CONCAT6(a,b,c,d,e,f)
+#define LZO_PP_ECONCAT7(a,b,c,d,e,f,g)  LZO_PP_CONCAT7(a,b,c,d,e,f,g)
+#define LZO_PP_EMPTY                    /*empty*/
+#define LZO_PP_EMPTY0()                 /*empty*/
+#define LZO_PP_EMPTY1(a)                /*empty*/
+#define LZO_PP_EMPTY2(a,b)              /*empty*/
+#define LZO_PP_EMPTY3(a,b,c)            /*empty*/
+#define LZO_PP_EMPTY4(a,b,c,d)          /*empty*/
+#define LZO_PP_EMPTY5(a,b,c,d,e)        /*empty*/
+#define LZO_PP_EMPTY6(a,b,c,d,e,f)      /*empty*/
+#define LZO_PP_EMPTY7(a,b,c,d,e,f,g)    /*empty*/
 #if 1
 #define LZO_CPP_STRINGIZE(x)            #x
 #define LZO_CPP_MACRO_EXPAND(x)         LZO_CPP_STRINGIZE(x)
@@ -245,12 +278,16 @@
 #define LZO_CPP_CONCAT3(a,b,c)          a ## b ## c
 #define LZO_CPP_CONCAT4(a,b,c,d)        a ## b ## c ## d
 #define LZO_CPP_CONCAT5(a,b,c,d,e)      a ## b ## c ## d ## e
+#define LZO_CPP_CONCAT6(a,b,c,d,e,f)    a ## b ## c ## d ## e ## f
+#define LZO_CPP_CONCAT7(a,b,c,d,e,f,g)  a ## b ## c ## d ## e ## f ## g
 #define LZO_CPP_ECONCAT2(a,b)           LZO_CPP_CONCAT2(a,b)
 #define LZO_CPP_ECONCAT3(a,b,c)         LZO_CPP_CONCAT3(a,b,c)
 #define LZO_CPP_ECONCAT4(a,b,c,d)       LZO_CPP_CONCAT4(a,b,c,d)
 #define LZO_CPP_ECONCAT5(a,b,c,d,e)     LZO_CPP_CONCAT5(a,b,c,d,e)
+#define LZO_CPP_ECONCAT6(a,b,c,d,e,f)   LZO_CPP_CONCAT6(a,b,c,d,e,f)
+#define LZO_CPP_ECONCAT7(a,b,c,d,e,f,g) LZO_CPP_CONCAT7(a,b,c,d,e,f,g)
 #endif
-#define __LZO_MASK_GEN(o,b)     (((((o) << ((b)-1)) - (o)) << 1) + (o))
+#define __LZO_MASK_GEN(o,b)     (((((o) << ((b)-!!(b))) - (o)) << 1) + (o)*!!(b))
 #if 1 && defined(__cplusplus)
 #  if !defined(__STDC_CONSTANT_MACROS)
 #    define __STDC_CONSTANT_MACROS 1
@@ -260,14 +297,18 @@
 #  endif
 #endif
 #if defined(__cplusplus)
-#  define LZO_EXTERN_C extern "C"
-#else
-#  define LZO_EXTERN_C extern
+#  define LZO_EXTERN_C          extern "C"
+#  define LZO_EXTERN_C_BEGIN    extern "C" {
+#  define LZO_EXTERN_C_END      }
+#else
+#  define LZO_EXTERN_C          extern
+#  define LZO_EXTERN_C_BEGIN    /*empty*/
+#  define LZO_EXTERN_C_END      /*empty*/
 #endif
 #if !defined(__LZO_OS_OVERRIDE)
-#if defined(LZO_OS_FREESTANDING)
+#if (LZO_OS_FREESTANDING)
 #  define LZO_INFO_OS           "freestanding"
-#elif defined(LZO_OS_EMBEDDED)
+#elif (LZO_OS_EMBEDDED)
 #  define LZO_INFO_OS           "embedded"
 #elif 1 && defined(__IAR_SYSTEMS_ICC__)
 #  define LZO_OS_EMBEDDED       1
@@ -363,12 +404,12 @@
 #elif defined(__VMS)
 #  define LZO_OS_VMS            1
 #  define LZO_INFO_OS           "vms"
-#elif ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
+#elif (defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__)
 #  define LZO_OS_CONSOLE        1
 #  define LZO_OS_CONSOLE_PS2    1
 #  define LZO_INFO_OS           "console"
 #  define LZO_INFO_OS_CONSOLE   "ps2"
-#elif (defined(__mips__) && defined(__psp__))
+#elif defined(__mips__) && defined(__psp__)
 #  define LZO_OS_CONSOLE        1
 #  define LZO_OS_CONSOLE_PSP    1
 #  define LZO_INFO_OS           "console"
@@ -396,9 +437,18 @@
 #  elif defined(__linux__) || defined(__linux) || defined(__LINUX__)
 #    define LZO_OS_POSIX_LINUX      1
 #    define LZO_INFO_OS_POSIX       "linux"
-#  elif defined(__APPLE__) || defined(__MACOS__)
-#    define LZO_OS_POSIX_MACOSX     1
-#    define LZO_INFO_OS_POSIX       "macosx"
+#  elif defined(__APPLE__) && defined(__MACH__)
+#    if ((__ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__-0) >= 20000)
+#      define LZO_OS_POSIX_DARWIN     1040
+#      define LZO_INFO_OS_POSIX       "darwin_iphone"
+#    elif ((__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__-0) >= 1040)
+#      define LZO_OS_POSIX_DARWIN     __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
+#      define LZO_INFO_OS_POSIX       "darwin"
+#    else
+#      define LZO_OS_POSIX_DARWIN     1
+#      define LZO_INFO_OS_POSIX       "darwin"
+#    endif
+#    define LZO_OS_POSIX_MACOSX     LZO_OS_POSIX_DARWIN
 #  elif defined(__minix__) || defined(__minix)
 #    define LZO_OS_POSIX_MINIX      1
 #    define LZO_INFO_OS_POSIX       "minix"
@@ -433,18 +483,18 @@
 #endif
 #if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
 #  if (UINT_MAX != LZO_0xffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #endif
 #if (LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_WIN32 || LZO_OS_WIN64)
 #  if (UINT_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #endif
 #if defined(CIL) && defined(_GNUCC) && defined(__GNUC__)
@@ -460,48 +510,73 @@
 #  define LZO_INFO_CC           "sdcc"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(SDCC)
 #elif defined(__PATHSCALE__) && defined(__PATHCC_PATCHLEVEL__)
-#  define LZO_CC_PATHSCALE      (__PATHCC__ * 0x10000L + __PATHCC_MINOR__ * 0x100 + __PATHCC_PATCHLEVEL__)
+#  define LZO_CC_PATHSCALE      (__PATHCC__ * 0x10000L + (__PATHCC_MINOR__-0) * 0x100 + (__PATHCC_PATCHLEVEL__-0))
 #  define LZO_INFO_CC           "Pathscale C"
 #  define LZO_INFO_CCVER        __PATHSCALE__
-#elif defined(__INTEL_COMPILER)
-#  define LZO_CC_INTELC         1
+#  if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#    define LZO_CC_PATHSCALE_GNUC (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
+#  endif
+#elif defined(__INTEL_COMPILER) && ((__INTEL_COMPILER-0) > 0)
+#  define LZO_CC_INTELC         __INTEL_COMPILER
 #  define LZO_INFO_CC           "Intel C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__INTEL_COMPILER)
-#  if defined(_WIN32) || defined(_WIN64)
-#    define LZO_CC_SYNTAX_MSC 1
-#  else
-#    define LZO_CC_SYNTAX_GNUC 1
+#  if defined(_MSC_VER) && ((_MSC_VER-0) > 0)
+#    define LZO_CC_INTELC_MSC   _MSC_VER
+#  elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#    define LZO_CC_INTELC_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
 #  endif
 #elif defined(__POCC__) && defined(_WIN32)
 #  define LZO_CC_PELLESC        1
 #  define LZO_INFO_CC           "Pelles C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__POCC__)
-#elif defined(__llvm__) && defined(__GNUC__) && defined(__VERSION__)
-#  if defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_LLVM         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
+#elif defined(__ARMCC_VERSION) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#  if defined(__GNUC_PATCHLEVEL__)
+#    define LZO_CC_ARMCC_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
 #  else
-#    define LZO_CC_LLVM         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
+#    define LZO_CC_ARMCC_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100)
 #  endif
-#  define LZO_INFO_CC           "llvm-gcc"
+#  define LZO_CC_ARMCC          __ARMCC_VERSION
+#  define LZO_INFO_CC           "ARM C Compiler"
 #  define LZO_INFO_CCVER        __VERSION__
-#elif defined(__GNUC__) && defined(__VERSION__)
-#  if defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
-#  elif defined(__GNUC_MINOR__)
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
+#elif defined(__clang__) && defined(__llvm__) && defined(__VERSION__)
+#  if defined(__clang_major__) && defined(__clang_minor__) && defined(__clang_patchlevel__)
+#    define LZO_CC_CLANG        (__clang_major__ * 0x10000L + (__clang_minor__-0) * 0x100 + (__clang_patchlevel__-0))
+#  else
+#    define LZO_CC_CLANG        0x010000L
+#  endif
+#  if defined(_MSC_VER) && ((_MSC_VER-0) > 0)
+#    define LZO_CC_CLANG_MSC    _MSC_VER
+#  elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#    define LZO_CC_CLANG_GNUC   (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
+#  endif
+#  define LZO_INFO_CC           "clang"
+#  define LZO_INFO_CCVER        __VERSION__
+#elif defined(__llvm__) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#  if defined(__GNUC_PATCHLEVEL__)
+#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
 #  else
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L)
+#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100)
 #  endif
-#  define LZO_INFO_CC           "gcc"
+#  define LZO_CC_LLVM           LZO_CC_LLVM_GNUC
+#  define LZO_INFO_CC           "llvm-gcc"
 #  define LZO_INFO_CCVER        __VERSION__
 #elif defined(__ACK__) && defined(_ACK)
 #  define LZO_CC_ACK            1
 #  define LZO_INFO_CC           "Amsterdam Compiler Kit C"
 #  define LZO_INFO_CCVER        "unknown"
+#elif defined(__ARMCC_VERSION) && !defined(__GNUC__)
+#  define LZO_CC_ARMCC          __ARMCC_VERSION
+#  define LZO_CC_ARMCC_ARMCC    __ARMCC_VERSION
+#  define LZO_INFO_CC           "ARM C Compiler"
+#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__ARMCC_VERSION)
 #elif defined(__AZTEC_C__)
 #  define LZO_CC_AZTECC         1
 #  define LZO_INFO_CC           "Aztec C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__AZTEC_C__)
+#elif defined(__CODEGEARC__)
+#  define LZO_CC_CODEGEARC      1
+#  define LZO_INFO_CC           "CodeGear C"
+#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__CODEGEARC__)
 #elif defined(__BORLANDC__)
 #  define LZO_CC_BORLANDC       1
 #  define LZO_INFO_CC           "Borland C"
@@ -518,10 +593,23 @@
 #  define LZO_CC_DECC           1
 #  define LZO_INFO_CC           "DEC C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__DECC)
+#elif (defined(__ghs) || defined(__ghs__)) && defined(__GHS_VERSION_NUMBER) && ((__GHS_VERSION_NUMBER-0) > 0)
+#  define LZO_CC_GHS            1
+#  define LZO_INFO_CC           "Green Hills C"
+#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__GHS_VERSION_NUMBER)
+#  if defined(_MSC_VER) && ((_MSC_VER-0) > 0)
+#    define LZO_CC_GHS_MSC      _MSC_VER
+#  elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
+#    define LZO_CC_GHS_GNUC     (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
+#  endif
 #elif defined(__HIGHC__)
 #  define LZO_CC_HIGHC          1
 #  define LZO_INFO_CC           "MetaWare High C"
 #  define LZO_INFO_CCVER        "unknown"
+#elif defined(__HP_aCC) && ((__HP_aCC-0) > 0)
+#  define LZO_CC_HPACC          __HP_aCC
+#  define LZO_INFO_CC           "HP aCC"
+#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__HP_aCC)
 #elif defined(__IAR_SYSTEMS_ICC__)
 #  define LZO_CC_IARC           1
 #  define LZO_INFO_CC           "IAR C"
@@ -530,10 +618,14 @@
 #  else
 #    define LZO_INFO_CCVER      "unknown"
 #  endif
-#elif defined(__IBMC__)
-#  define LZO_CC_IBMC           1
+#elif defined(__IBMC__) && ((__IBMC__-0) > 0)
+#  define LZO_CC_IBMC           __IBMC__
 #  define LZO_INFO_CC           "IBM C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__IBMC__)
+#elif defined(__IBMCPP__) && ((__IBMCPP__-0) > 0)
+#  define LZO_CC_IBMC           __IBMCPP__
+#  define LZO_INFO_CC           "IBM C"
+#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__IBMCPP__)
 #elif defined(__KEIL__) && defined(__C166__)
 #  define LZO_CC_KEILC          1
 #  define LZO_INFO_CC           "Keil C"
@@ -550,16 +642,8 @@
 #  else
 #    define LZO_INFO_CCVER      "unknown"
 #  endif
-#elif defined(_MSC_VER)
-#  define LZO_CC_MSC            1
-#  define LZO_INFO_CC           "Microsoft C"
-#  if defined(_MSC_FULL_VER)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER) "." LZO_PP_MACRO_EXPAND(_MSC_FULL_VER)
-#  else
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER)
-#  endif
-#elif defined(__MWERKS__)
-#  define LZO_CC_MWERKS         1
+#elif defined(__MWERKS__) && ((__MWERKS__-0) > 0)
+#  define LZO_CC_MWERKS         __MWERKS__
 #  define LZO_INFO_CC           "Metrowerks C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__MWERKS__)
 #elif (defined(__NDPC__) || defined(__NDPX__)) && defined(__i386)
@@ -570,6 +654,15 @@
 #  define LZO_CC_PACIFICC       1
 #  define LZO_INFO_CC           "Pacific C"
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__PACIFIC__)
+#elif defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__)
+#  if defined(__PGIC_PATCHLEVEL__)
+#    define LZO_CC_PGI          (__PGIC__ * 0x10000L + (__PGIC_MINOR__-0) * 0x100 + (__PGIC_PATCHLEVEL__-0))
+#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__PGIC__) "." LZO_PP_MACRO_EXPAND(__PGIC_MINOR__) "." LZO_PP_MACRO_EXPAND(__PGIC_PATCHLEVEL__)
+#  else
+#    define LZO_CC_PGI          (__PGIC__ * 0x10000L + (__PGIC_MINOR__-0) * 0x100)
+#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__PGIC__) "." LZO_PP_MACRO_EXPAND(__PGIC_MINOR__) ".0"
+#  endif
+#  define LZO_INFO_CC           "Portland Group PGI C"
 #elif defined(__PGI) && (defined(__linux__) || defined(__WIN32__))
 #  define LZO_CC_PGI            1
 #  define LZO_INFO_CC           "Portland Group PGI C"
@@ -584,7 +677,7 @@
 #  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__SC__)
 #elif defined(__SUNPRO_C)
 #  define LZO_INFO_CC           "SunPro C"
-#  if ((__SUNPRO_C)+0 > 0)
+#  if ((__SUNPRO_C-0) > 0)
 #    define LZO_CC_SUNPROC      __SUNPRO_C
 #    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_C)
 #  else
@@ -593,7 +686,7 @@
 #  endif
 #elif defined(__SUNPRO_CC)
 #  define LZO_INFO_CC           "SunPro C"
-#  if ((__SUNPRO_CC)+0 > 0)
+#  if ((__SUNPRO_CC-0) > 0)
 #    define LZO_CC_SUNPROC      __SUNPRO_CC
 #    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_CC)
 #  else
@@ -619,20 +712,50 @@
 #elif defined(__ZTC__)
 #  define LZO_CC_ZORTECHC       1
 #  define LZO_INFO_CC           "Zortech C"
-#  if (__ZTC__ == 0x310)
+#  if ((__ZTC__-0) == 0x310)
 #    define LZO_INFO_CCVER      "0x310"
 #  else
 #    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__ZTC__)
 #  endif
+#elif defined(__GNUC__) && defined(__VERSION__)
+#  if defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
+#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100 + (__GNUC_PATCHLEVEL__-0))
+#  elif defined(__GNUC_MINOR__)
+#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + (__GNUC_MINOR__-0) * 0x100)
+#  else
+#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L)
+#  endif
+#  define LZO_INFO_CC           "gcc"
+#  define LZO_INFO_CCVER        __VERSION__
+#elif defined(_MSC_VER) && ((_MSC_VER-0) > 0)
+#  define LZO_CC_MSC            _MSC_VER
+#  define LZO_INFO_CC           "Microsoft C"
+#  if defined(_MSC_FULL_VER)
+#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER) "." LZO_PP_MACRO_EXPAND(_MSC_FULL_VER)
+#  else
+#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER)
+#  endif
 #else
 #  define LZO_CC_UNKNOWN        1
 #  define LZO_INFO_CC           "unknown"
 #  define LZO_INFO_CCVER        "unknown"
 #endif
+#if (LZO_CC_GNUC) && defined(__OPEN64__)
+#  if defined(__OPENCC__) && defined(__OPENCC_MINOR__) && defined(__OPENCC_PATCHLEVEL__)
+#    define LZO_CC_OPEN64       (__OPENCC__ * 0x10000L + (__OPENCC_MINOR__-0) * 0x100 + (__OPENCC_PATCHLEVEL__-0))
+#    define LZO_CC_OPEN64_GNUC  LZO_CC_GNUC
+#  endif
+#endif
+#if (LZO_CC_GNUC) && defined(__PCC__)
+#  if defined(__PCC__) && defined(__PCC_MINOR__) && defined(__PCC_MINORMINOR__)
+#    define LZO_CC_PCC          (__PCC__ * 0x10000L + (__PCC_MINOR__-0) * 0x100 + (__PCC_MINORMINOR__-0))
+#    define LZO_CC_PCC_GNUC     LZO_CC_GNUC
+#  endif
+#endif
 #if 0 && (LZO_CC_MSC && (_MSC_VER >= 1200)) && !defined(_MSC_FULL_VER)
 #  error "LZO_CC_MSC: _MSC_FULL_VER is not defined"
 #endif
-#if !defined(__LZO_ARCH_OVERRIDE) && !defined(LZO_ARCH_GENERIC) && defined(_CRAY)
+#if !defined(__LZO_ARCH_OVERRIDE) && !(LZO_ARCH_GENERIC) && defined(_CRAY)
 #  if (UINT_MAX > LZO_0xffffffffL) && defined(_CRAY)
 #    if defined(_CRAYMPP) || defined(_CRAYT3D) || defined(_CRAYT3E)
 #      define LZO_ARCH_CRAY_MPP     1
@@ -642,12 +765,14 @@
 #  endif
 #endif
 #if !defined(__LZO_ARCH_OVERRIDE)
-#if defined(LZO_ARCH_GENERIC)
+#if (LZO_ARCH_GENERIC)
 #  define LZO_INFO_ARCH             "generic"
 #elif (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
 #  define LZO_ARCH_I086             1
-#  define LZO_ARCH_IA16             1
 #  define LZO_INFO_ARCH             "i086"
+#elif defined(__aarch64__)
+#  define LZO_ARCH_ARM64            1
+#  define LZO_INFO_ARCH             "arm64"
 #elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
 #  define LZO_ARCH_ALPHA            1
 #  define LZO_INFO_ARCH             "alpha"
@@ -663,10 +788,10 @@
 #  define LZO_INFO_ARCH             "arm_thumb"
 #elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCARM__)
 #  define LZO_ARCH_ARM              1
-#  if defined(__CPU_MODE__) && ((__CPU_MODE__)+0 == 1)
+#  if defined(__CPU_MODE__) && ((__CPU_MODE__-0) == 1)
 #    define LZO_ARCH_ARM_THUMB      1
 #    define LZO_INFO_ARCH           "arm_thumb"
-#  elif defined(__CPU_MODE__) && ((__CPU_MODE__)+0 == 2)
+#  elif defined(__CPU_MODE__) && ((__CPU_MODE__-0) == 2)
 #    define LZO_INFO_ARCH           "arm"
 #  else
 #    define LZO_INFO_ARCH           "arm"
@@ -677,6 +802,9 @@
 #elif (UINT_MAX <= LZO_0xffffL) && defined(__AVR__)
 #  define LZO_ARCH_AVR              1
 #  define LZO_INFO_ARCH             "avr"
+#elif defined(__avr32__) || defined(__AVR32__)
+#  define LZO_ARCH_AVR32            1
+#  define LZO_INFO_ARCH             "avr32"
 #elif defined(__bfin__)
 #  define LZO_ARCH_BLACKFIN         1
 #  define LZO_INFO_ARCH             "blackfin"
@@ -781,53 +909,147 @@
 #  error "FIXME - missing define for CPU architecture"
 #endif
 #if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN32)
-#  error "FIXME - missing WIN32 define for CPU architecture"
+#  error "FIXME - missing LZO_OS_WIN32 define for CPU architecture"
 #endif
 #if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN64)
-#  error "FIXME - missing WIN64 define for CPU architecture"
+#  error "FIXME - missing LZO_OS_WIN64 define for CPU architecture"
 #endif
 #if (LZO_OS_OS216 || LZO_OS_WIN16)
 #  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
 #elif 1 && (LZO_OS_DOS16 && defined(BLX286))
 #  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
 #elif 1 && (LZO_OS_DOS16 && defined(DOSX286))
 #  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
 #elif 1 && (LZO_OS_DOS16 && LZO_CC_BORLANDC && defined(__DPMI16__))
 #  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
 #endif
-#if defined(LZO_ARCH_ARM_THUMB) && !defined(LZO_ARCH_ARM)
-#  error "this should not happen"
+#if (LZO_ARCH_AMD64 && !LZO_ARCH_X64)
+#  define LZO_ARCH_X64              1
+#elif (!LZO_ARCH_AMD64 && LZO_ARCH_X64) && defined(__LZO_ARCH_OVERRIDE)
+#  define LZO_ARCH_AMD64            1
+#endif
+#if (LZO_ARCH_ARM64 && !LZO_ARCH_AARCH64)
+#  define LZO_ARCH_AARCH64          1
+#elif (!LZO_ARCH_ARM64 && LZO_ARCH_AARCH64) && defined(__LZO_ARCH_OVERRIDE)
+#  define LZO_ARCH_ARM64            1
+#endif
+#if (LZO_ARCH_I386 && !LZO_ARCH_X86)
+#  define LZO_ARCH_X86              1
+#elif (!LZO_ARCH_I386 && LZO_ARCH_X86) && defined(__LZO_ARCH_OVERRIDE)
+#  define LZO_ARCH_I386            1
+#endif
+#if (LZO_ARCH_AMD64 && !LZO_ARCH_X64) || (!LZO_ARCH_AMD64 && LZO_ARCH_X64)
+#  error "unexpected configuration - check your compiler defines"
 #endif
-#if defined(LZO_ARCH_I086PM) && !defined(LZO_ARCH_I086)
-#  error "this should not happen"
+#if (LZO_ARCH_ARM64 && !LZO_ARCH_AARCH64) || (!LZO_ARCH_ARM64 && LZO_ARCH_AARCH64)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_I386 && !LZO_ARCH_X86) || (!LZO_ARCH_I386 && LZO_ARCH_X86)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_ARM_THUMB && !LZO_ARCH_ARM)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_ARM_THUMB1 && !LZO_ARCH_ARM_THUMB)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_ARM_THUMB2 && !LZO_ARCH_ARM_THUMB)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_ARM_THUMB1 && LZO_ARCH_ARM_THUMB2)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_I086PM && !LZO_ARCH_I086)
+#  error "unexpected configuration - check your compiler defines"
 #endif
 #if (LZO_ARCH_I086)
 #  if (UINT_MAX != LZO_0xffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #endif
 #if (LZO_ARCH_I386)
 #  if (UINT_MAX != LZO_0xffffL) && defined(__i386_int16__)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #  if (UINT_MAX != LZO_0xffffffffL) && !defined(__i386_int16__)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
+#  endif
+#endif
+#if (LZO_ARCH_AMD64 || LZO_ARCH_I386)
+#  if !defined(LZO_TARGET_FEATURE_SSE2)
+#    if defined(__SSE2__)
+#      define LZO_TARGET_FEATURE_SSE2       1
+#    elif defined(_MSC_VER) && ((defined(_M_IX86_FP) && ((_M_IX86_FP)+0 >= 2)) || defined(_M_AMD64))
+#      define LZO_TARGET_FEATURE_SSE2       1
+#    endif
+#  endif
+#  if !defined(LZO_TARGET_FEATURE_SSSE3)
+#  if (LZO_TARGET_FEATURE_SSE2)
+#    if defined(__SSSE3__)
+#      define LZO_TARGET_FEATURE_SSSE3      1
+#    elif defined(_MSC_VER) && defined(__AVX__)
+#      define LZO_TARGET_FEATURE_SSSE3      1
+#    endif
+#  endif
+#  endif
+#  if !defined(LZO_TARGET_FEATURE_SSE4_2)
+#  if (LZO_TARGET_FEATURE_SSSE3)
+#    if defined(__SSE4_2__)
+#      define LZO_TARGET_FEATURE_SSE4_2     1
+#    endif
+#  endif
 #  endif
+#  if !defined(LZO_TARGET_FEATURE_AVX)
+#  if (LZO_TARGET_FEATURE_SSSE3)
+#    if defined(__AVX__)
+#      define LZO_TARGET_FEATURE_AVX        1
+#    endif
+#  endif
+#  endif
+#  if !defined(LZO_TARGET_FEATURE_AVX2)
+#  if (LZO_TARGET_FEATURE_AVX)
+#    if defined(__AVX2__)
+#      define LZO_TARGET_FEATURE_AVX2       1
+#    endif
+#  endif
+#  endif
+#endif
+#if (LZO_TARGET_FEATURE_SSSE3 && !(LZO_TARGET_FEATURE_SSE2))
+#  error "unexpected configuration - check your compiler defines"
 #endif
-#if !defined(__LZO_MM_OVERRIDE)
+#if (LZO_TARGET_FEATURE_SSE4_2 && !(LZO_TARGET_FEATURE_SSSE3))
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_TARGET_FEATURE_AVX && !(LZO_TARGET_FEATURE_SSSE3))
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_TARGET_FEATURE_AVX2 && !(LZO_TARGET_FEATURE_AVX))
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if (LZO_ARCH_ARM)
+#  if !defined(LZO_TARGET_FEATURE_NEON)
+#    if defined(__ARM_NEON__)
+#      define LZO_TARGET_FEATURE_NEON       1
+#    endif
+#  endif
+#elif (LZO_ARCH_ARM64)
+#  if !defined(LZO_TARGET_FEATURE_NEON)
+#    if 1
+#      define LZO_TARGET_FEATURE_NEON       1
+#    endif
+#  endif
+#endif
+#if 0
+#elif !defined(__LZO_MM_OVERRIDE)
 #if (LZO_ARCH_I086)
 #if (UINT_MAX != LZO_0xffffL)
-#  error "this should not happen"
+#  error "unexpected configuration - check your compiler defines"
 #endif
 #if defined(__TINY__) || defined(M_I86TM) || defined(_M_I86TM)
 #  define LZO_MM_TINY           1
@@ -854,7 +1076,7 @@
 #elif (LZO_CC_ZORTECHC && defined(__VCM__))
 #  define LZO_MM_LARGE          1
 #else
-#  error "unknown memory model"
+#  error "unknown LZO_ARCH_I086 memory model"
 #endif
 #if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
 #define LZO_HAVE_MM_HUGE_PTR        1
@@ -875,12 +1097,12 @@
 #elif (LZO_CC_TURBOC && (__TURBOC__ < 0x0295))
 #  undef LZO_HAVE_MM_HUGE_ARRAY
 #endif
-#if (LZO_ARCH_I086PM) && !defined(LZO_HAVE_MM_HUGE_PTR)
+#if (LZO_ARCH_I086PM) && !(LZO_HAVE_MM_HUGE_PTR)
 #  if (LZO_OS_DOS16)
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  elif (LZO_CC_ZORTECHC)
 #  else
-#    error "this should not happen"
+#    error "unexpected configuration - check your compiler defines"
 #  endif
 #endif
 #ifdef __cplusplus
@@ -912,7 +1134,7 @@ extern "C" {
 #endif
 #elif (LZO_ARCH_C166)
 #if !defined(__MODEL__)
-#  error "FIXME - C166 __MODEL__"
+#  error "FIXME - LZO_ARCH_C166 __MODEL__"
 #elif ((__MODEL__) == 0)
 #  define LZO_MM_SMALL          1
 #elif ((__MODEL__) == 1)
@@ -926,11 +1148,11 @@ extern "C" {
 #elif ((__MODEL__) == 5)
 #  define LZO_MM_XSMALL         1
 #else
-#  error "FIXME - C166 __MODEL__"
+#  error "FIXME - LZO_ARCH_C166 __MODEL__"
 #endif
 #elif (LZO_ARCH_MCS251)
 #if !defined(__MODEL__)
-#  error "FIXME - MCS251 __MODEL__"
+#  error "FIXME - LZO_ARCH_MCS251 __MODEL__"
 #elif ((__MODEL__) == 0)
 #  define LZO_MM_SMALL          1
 #elif ((__MODEL__) == 2)
@@ -942,11 +1164,11 @@ extern "C" {
 #elif ((__MODEL__) == 5)
 #  define LZO_MM_XSMALL         1
 #else
-#  error "FIXME - MCS251 __MODEL__"
+#  error "FIXME - LZO_ARCH_MCS251 __MODEL__"
 #endif
 #elif (LZO_ARCH_MCS51)
 #if !defined(__MODEL__)
-#  error "FIXME - MCS51 __MODEL__"
+#  error "FIXME - LZO_ARCH_MCS51 __MODEL__"
 #elif ((__MODEL__) == 1)
 #  define LZO_MM_SMALL          1
 #elif ((__MODEL__) == 2)
@@ -958,7 +1180,7 @@ extern "C" {
 #elif ((__MODEL__) == 5)
 #  define LZO_MM_XSMALL         1
 #else
-#  error "FIXME - MCS51 __MODEL__"
+#  error "FIXME - LZO_ARCH_MCS51 __MODEL__"
 #endif
 #elif (LZO_ARCH_CRAY_PVP)
 #  define LZO_MM_PVP            1
@@ -985,35 +1207,818 @@ extern "C" {
 #  error "unknown memory model"
 #endif
 #endif
+#if !defined(__lzo_gnuc_extension__)
+#if (LZO_CC_GNUC >= 0x020800ul)
+#  define __lzo_gnuc_extension__    __extension__
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_gnuc_extension__    __extension__
+#elif (LZO_CC_IBMC >= 600)
+#  define __lzo_gnuc_extension__    __extension__
+#else
+#endif
+#endif
+#if !defined(__lzo_gnuc_extension__)
+#  define __lzo_gnuc_extension__    /*empty*/
+#endif
+#if !defined(LZO_CFG_USE_NEW_STYLE_CASTS) && defined(__cplusplus) && 0
+#  if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020800ul))
+#    define LZO_CFG_USE_NEW_STYLE_CASTS 0
+#  elif (LZO_CC_INTELC && (__INTEL_COMPILER < 1200))
+#    define LZO_CFG_USE_NEW_STYLE_CASTS 0
+#  else
+#    define LZO_CFG_USE_NEW_STYLE_CASTS 1
+#  endif
+#endif
+#if !defined(LZO_CFG_USE_NEW_STYLE_CASTS)
+#  define LZO_CFG_USE_NEW_STYLE_CASTS 0
+#endif
+#if !defined(__cplusplus)
+#  if defined(LZO_CFG_USE_NEW_STYLE_CASTS)
+#    undef LZO_CFG_USE_NEW_STYLE_CASTS
+#  endif
+#  define LZO_CFG_USE_NEW_STYLE_CASTS 0
+#endif
+#if !defined(LZO_REINTERPRET_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_REINTERPRET_CAST(t,e)       (reinterpret_cast<t> (e))
+#  endif
+#endif
+#if !defined(LZO_REINTERPRET_CAST)
+#  define LZO_REINTERPRET_CAST(t,e)         ((t) (e))
+#endif
+#if !defined(LZO_STATIC_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_STATIC_CAST(t,e)            (static_cast<t> (e))
+#  endif
+#endif
+#if !defined(LZO_STATIC_CAST)
+#  define LZO_STATIC_CAST(t,e)              ((t) (e))
+#endif
+#if !defined(LZO_STATIC_CAST2)
+#  define LZO_STATIC_CAST2(t1,t2,e)         LZO_STATIC_CAST(t1, LZO_STATIC_CAST(t2, e))
+#endif
+#if !defined(LZO_UNCONST_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_UNCONST_CAST(t,e)           (const_cast<t> (e))
+#  elif (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_UNCONST_CAST(t,e)           ((t) (e))
+#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define LZO_UNCONST_CAST(t,e)           ((t) ((void *) ((lzo_uintptr_t) ((const void *) (e)))))
+#  endif
+#endif
+#if !defined(LZO_UNCONST_CAST)
+#  define LZO_UNCONST_CAST(t,e)             ((t) ((void *) ((const void *) (e))))
+#endif
+#if !defined(LZO_UNCONST_VOLATILE_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_UNCONST_VOLATILE_CAST(t,e)  (const_cast<t> (e))
+#  elif (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_UNCONST_VOLATILE_CAST(t,e)  ((t) (e))
+#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define LZO_UNCONST_VOLATILE_CAST(t,e)  ((t) ((volatile void *) ((lzo_uintptr_t) ((volatile const void *) (e)))))
+#  endif
+#endif
+#if !defined(LZO_UNCONST_VOLATILE_CAST)
+#  define LZO_UNCONST_VOLATILE_CAST(t,e)    ((t) ((volatile void *) ((volatile const void *) (e))))
+#endif
+#if !defined(LZO_UNVOLATILE_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_UNVOLATILE_CAST(t,e)        (const_cast<t> (e))
+#  elif (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_UNVOLATILE_CAST(t,e)        ((t) (e))
+#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define LZO_UNVOLATILE_CAST(t,e)        ((t) ((void *) ((lzo_uintptr_t) ((volatile void *) (e)))))
+#  endif
+#endif
+#if !defined(LZO_UNVOLATILE_CAST)
+#  define LZO_UNVOLATILE_CAST(t,e)          ((t) ((void *) ((volatile void *) (e))))
+#endif
+#if !defined(LZO_UNVOLATILE_CONST_CAST)
+#  if (LZO_CFG_USE_NEW_STYLE_CASTS)
+#    define LZO_UNVOLATILE_CONST_CAST(t,e)  (const_cast<t> (e))
+#  elif (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_UNVOLATILE_CONST_CAST(t,e)  ((t) (e))
+#  elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define LZO_UNVOLATILE_CONST_CAST(t,e)  ((t) ((const void *) ((lzo_uintptr_t) ((volatile const void *) (e)))))
+#  endif
+#endif
+#if !defined(LZO_UNVOLATILE_CONST_CAST)
+#  define LZO_UNVOLATILE_CONST_CAST(t,e)    ((t) ((const void *) ((volatile const void *) (e))))
+#endif
+#if !defined(LZO_PCAST)
+#  if (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_PCAST(t,e)                  ((t) (e))
+#  endif
+#endif
+#if !defined(LZO_PCAST)
+#  define LZO_PCAST(t,e)                    LZO_STATIC_CAST(t, LZO_STATIC_CAST(void *, e))
+#endif
+#if !defined(LZO_CCAST)
+#  if (LZO_HAVE_MM_HUGE_PTR)
+#    define LZO_CCAST(t,e)                  ((t) (e))
+#  endif
+#endif
+#if !defined(LZO_CCAST)
+#  define LZO_CCAST(t,e)                    LZO_STATIC_CAST(t, LZO_STATIC_CAST(const void *, e))
+#endif
+#if !defined(LZO_ICONV)
+#  define LZO_ICONV(t,e)                    LZO_STATIC_CAST(t, e)
+#endif
+#if !defined(LZO_ICAST)
+#  define LZO_ICAST(t,e)                    LZO_STATIC_CAST(t, e)
+#endif
+#if !defined(LZO_ITRUNC)
+#  define LZO_ITRUNC(t,e)                   LZO_STATIC_CAST(t, e)
+#endif
+#if !defined(__lzo_cte)
+#  if (LZO_CC_MSC || LZO_CC_WATCOMC)
+#    define __lzo_cte(e)            ((void)0,(e))
+#  elif 1
+#    define __lzo_cte(e)            ((void)0,(e))
+#  endif
+#endif
+#if !defined(__lzo_cte)
+#  define __lzo_cte(e)              (e)
+#endif
+#if !defined(LZO_BLOCK_BEGIN)
+#  define LZO_BLOCK_BEGIN           do {
+#  define LZO_BLOCK_END             } while __lzo_cte(0)
+#endif
+#if !defined(LZO_UNUSED)
+#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
+#    define LZO_UNUSED(var)         ((void) &var)
+#  elif (LZO_CC_BORLANDC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PELLESC || LZO_CC_TURBOC)
+#    define LZO_UNUSED(var)         if (&var) ; else
+#  elif (LZO_CC_CLANG && (LZO_CC_CLANG >= 0x030200ul))
+#    define LZO_UNUSED(var)         ((void) &var)
+#  elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define LZO_UNUSED(var)         ((void) var)
+#  elif (LZO_CC_MSC && (_MSC_VER < 900))
+#    define LZO_UNUSED(var)         if (&var) ; else
+#  elif (LZO_CC_KEILC)
+#    define LZO_UNUSED(var)         {LZO_EXTERN_C int lzo_unused__[1-2*!(sizeof(var)>0)];}
+#  elif (LZO_CC_PACIFICC)
+#    define LZO_UNUSED(var)         ((void) sizeof(var))
+#  elif (LZO_CC_WATCOMC) && defined(__cplusplus)
+#    define LZO_UNUSED(var)         ((void) var)
+#  else
+#    define LZO_UNUSED(var)         ((void) &var)
+#  endif
+#endif
+#if !defined(LZO_UNUSED_FUNC)
+#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
+#    define LZO_UNUSED_FUNC(func)   ((void) func)
+#  elif (LZO_CC_BORLANDC || LZO_CC_NDPC || LZO_CC_TURBOC)
+#    define LZO_UNUSED_FUNC(func)   if (func) ; else
+#  elif (LZO_CC_CLANG || LZO_CC_LLVM)
+#    define LZO_UNUSED_FUNC(func)   ((void) &func)
+#  elif (LZO_CC_MSC && (_MSC_VER < 900))
+#    define LZO_UNUSED_FUNC(func)   if (func) ; else
+#  elif (LZO_CC_MSC)
+#    define LZO_UNUSED_FUNC(func)   ((void) &func)
+#  elif (LZO_CC_KEILC || LZO_CC_PELLESC)
+#    define LZO_UNUSED_FUNC(func)   {LZO_EXTERN_C int lzo_unused_func__[1-2*!(sizeof((int)func)>0)];}
+#  else
+#    define LZO_UNUSED_FUNC(func)   ((void) func)
+#  endif
+#endif
+#if !defined(LZO_UNUSED_LABEL)
+#  if (LZO_CC_CLANG >= 0x020800ul)
+#    define LZO_UNUSED_LABEL(l)     (__lzo_gnuc_extension__ ((void) ((const void *) &&l)))
+#  elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_INTELC || LZO_CC_WATCOMC)
+#    define LZO_UNUSED_LABEL(l)     if __lzo_cte(0) goto l
+#  else
+#    define LZO_UNUSED_LABEL(l)     switch (0) case 1:goto l
+#  endif
+#endif
+#if !defined(LZO_DEFINE_UNINITIALIZED_VAR)
+#  if 0
+#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var
+#  elif 0 && (LZO_CC_GNUC)
+#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = var
+#  else
+#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = init
+#  endif
+#endif
+#if !defined(__lzo_inline)
+#if (LZO_CC_TURBOC && (__TURBOC__ <= 0x0295))
+#elif defined(__cplusplus)
+#  define __lzo_inline          inline
+#elif defined(__STDC_VERSION__) && (__STDC_VERSION__-0 >= 199901L)
+#  define __lzo_inline          inline
+#elif (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0550))
+#  define __lzo_inline          __inline
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
+#  define __lzo_inline          __inline__
+#elif (LZO_CC_DMC)
+#  define __lzo_inline          __inline
+#elif (LZO_CC_GHS)
+#  define __lzo_inline          __inline__
+#elif (LZO_CC_IBMC >= 600)
+#  define __lzo_inline          __inline__
+#elif (LZO_CC_INTELC)
+#  define __lzo_inline          __inline
+#elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x2405))
+#  define __lzo_inline          __inline
+#elif (LZO_CC_MSC && (_MSC_VER >= 900))
+#  define __lzo_inline          __inline
+#elif (LZO_CC_SUNPROC >= 0x5100)
+#  define __lzo_inline          __inline__
+#endif
+#endif
+#if defined(__lzo_inline)
+#  ifndef __lzo_HAVE_inline
+#  define __lzo_HAVE_inline 1
+#  endif
+#else
+#  define __lzo_inline          /*empty*/
+#endif
+#if !defined(__lzo_forceinline)
+#if (LZO_CC_GNUC >= 0x030200ul)
+#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
+#elif (LZO_CC_IBMC >= 700)
+#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
+#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 450))
+#  define __lzo_forceinline     __forceinline
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
+#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
+#elif (LZO_CC_MSC && (_MSC_VER >= 1200))
+#  define __lzo_forceinline     __forceinline
+#elif (LZO_CC_PGI >= 0x0d0a00ul)
+#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
+#elif (LZO_CC_SUNPROC >= 0x5100)
+#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
+#endif
+#endif
+#if defined(__lzo_forceinline)
+#  ifndef __lzo_HAVE_forceinline
+#  define __lzo_HAVE_forceinline 1
+#  endif
+#else
+#  define __lzo_forceinline     __lzo_inline
+#endif
+#if !defined(__lzo_noinline)
+#if 1 && (LZO_ARCH_I386) && (LZO_CC_GNUC >= 0x040000ul) && (LZO_CC_GNUC < 0x040003ul)
+#  define __lzo_noinline        __attribute__((__noinline__,__used__))
+#elif (LZO_CC_GNUC >= 0x030200ul)
+#  define __lzo_noinline        __attribute__((__noinline__))
+#elif (LZO_CC_IBMC >= 700)
+#  define __lzo_noinline        __attribute__((__noinline__))
+#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 600))
+#  define __lzo_noinline        __declspec(noinline)
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
+#  define __lzo_noinline        __attribute__((__noinline__))
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_noinline        __attribute__((__noinline__))
+#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
+#  define __lzo_noinline        __declspec(noinline)
+#elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x3200) && (LZO_OS_WIN32 || LZO_OS_WIN64))
+#  if defined(__cplusplus)
+#  else
+#    define __lzo_noinline      __declspec(noinline)
+#  endif
+#elif (LZO_CC_PGI >= 0x0d0a00ul)
+#  define __lzo_noinline        __attribute__((__noinline__))
+#elif (LZO_CC_SUNPROC >= 0x5100)
+#  define __lzo_noinline        __attribute__((__noinline__))
+#endif
+#endif
+#if defined(__lzo_noinline)
+#  ifndef __lzo_HAVE_noinline
+#  define __lzo_HAVE_noinline 1
+#  endif
+#else
+#  define __lzo_noinline        /*empty*/
+#endif
+#if (__lzo_HAVE_forceinline || __lzo_HAVE_noinline) && !(__lzo_HAVE_inline)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if !defined(__lzo_static_inline)
+#if (LZO_CC_IBMC)
+#  define __lzo_static_inline       __lzo_gnuc_extension__ static __lzo_inline
+#endif
+#endif
+#if !defined(__lzo_static_inline)
+#  define __lzo_static_inline       static __lzo_inline
+#endif
+#if !defined(__lzo_static_forceinline)
+#if (LZO_CC_IBMC)
+#  define __lzo_static_forceinline  __lzo_gnuc_extension__ static __lzo_forceinline
+#endif
+#endif
+#if !defined(__lzo_static_forceinline)
+#  define __lzo_static_forceinline  static __lzo_forceinline
+#endif
+#if !defined(__lzo_static_noinline)
+#if (LZO_CC_IBMC)
+#  define __lzo_static_noinline     __lzo_gnuc_extension__ static __lzo_noinline
+#endif
+#endif
+#if !defined(__lzo_static_noinline)
+#  define __lzo_static_noinline     static __lzo_noinline
+#endif
+#if !defined(__lzo_c99_extern_inline)
+#if defined(__GNUC_GNU_INLINE__)
+#  define __lzo_c99_extern_inline   __lzo_inline
+#elif defined(__GNUC_STDC_INLINE__)
+#  define __lzo_c99_extern_inline   extern __lzo_inline
+#elif defined(__STDC_VERSION__) && (__STDC_VERSION__-0 >= 199901L)
+#  define __lzo_c99_extern_inline   extern __lzo_inline
+#endif
+#if !defined(__lzo_c99_extern_inline) && (__lzo_HAVE_inline)
+#  define __lzo_c99_extern_inline   __lzo_inline
+#endif
+#endif
+#if defined(__lzo_c99_extern_inline)
+#  ifndef __lzo_HAVE_c99_extern_inline
+#  define __lzo_HAVE_c99_extern_inline 1
+#  endif
+#else
+#  define __lzo_c99_extern_inline   /*empty*/
+#endif
+#if !defined(__lzo_may_alias)
+#if (LZO_CC_GNUC >= 0x030400ul)
+#  define __lzo_may_alias       __attribute__((__may_alias__))
+#elif (LZO_CC_CLANG >= 0x020900ul)
+#  define __lzo_may_alias       __attribute__((__may_alias__))
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 1210)) && 0
+#  define __lzo_may_alias       __attribute__((__may_alias__))
+#elif (LZO_CC_PGI >= 0x0d0a00ul) && 0
+#  define __lzo_may_alias       __attribute__((__may_alias__))
+#endif
+#endif
+#if defined(__lzo_may_alias)
+#  ifndef __lzo_HAVE_may_alias
+#  define __lzo_HAVE_may_alias 1
+#  endif
+#else
+#  define __lzo_may_alias       /*empty*/
+#endif
+#if !defined(__lzo_noreturn)
+#if (LZO_CC_GNUC >= 0x020700ul)
+#  define __lzo_noreturn        __attribute__((__noreturn__))
+#elif (LZO_CC_IBMC >= 700)
+#  define __lzo_noreturn        __attribute__((__noreturn__))
+#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 450))
+#  define __lzo_noreturn        __declspec(noreturn)
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 600))
+#  define __lzo_noreturn        __attribute__((__noreturn__))
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_noreturn        __attribute__((__noreturn__))
+#elif (LZO_CC_MSC && (_MSC_VER >= 1200))
+#  define __lzo_noreturn        __declspec(noreturn)
+#elif (LZO_CC_PGI >= 0x0d0a00ul)
+#  define __lzo_noreturn        __attribute__((__noreturn__))
+#endif
+#endif
+#if defined(__lzo_noreturn)
+#  ifndef __lzo_HAVE_noreturn
+#  define __lzo_HAVE_noreturn 1
+#  endif
+#else
+#  define __lzo_noreturn        /*empty*/
+#endif
+#if !defined(__lzo_nothrow)
+#if (LZO_CC_GNUC >= 0x030300ul)
+#  define __lzo_nothrow         __attribute__((__nothrow__))
+#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 450)) && defined(__cplusplus)
+#  define __lzo_nothrow         __declspec(nothrow)
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 900))
+#  define __lzo_nothrow         __attribute__((__nothrow__))
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_nothrow         __attribute__((__nothrow__))
+#elif (LZO_CC_MSC && (_MSC_VER >= 1200)) && defined(__cplusplus)
+#  define __lzo_nothrow         __declspec(nothrow)
+#endif
+#endif
+#if defined(__lzo_nothrow)
+#  ifndef __lzo_HAVE_nothrow
+#  define __lzo_HAVE_nothrow 1
+#  endif
+#else
+#  define __lzo_nothrow         /*empty*/
+#endif
+#if !defined(__lzo_restrict)
+#if (LZO_CC_GNUC >= 0x030400ul)
+#  define __lzo_restrict        __restrict__
+#elif (LZO_CC_IBMC >= 800) && !defined(__cplusplus)
+#  define __lzo_restrict        __restrict__
+#elif (LZO_CC_IBMC >= 1210)
+#  define __lzo_restrict        __restrict__
+#elif (LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 600))
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 600))
+#  define __lzo_restrict        __restrict__
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM)
+#  define __lzo_restrict        __restrict__
+#elif (LZO_CC_MSC && (_MSC_VER >= 1400))
+#  define __lzo_restrict        __restrict
+#elif (LZO_CC_PGI >= 0x0d0a00ul)
+#  define __lzo_restrict        __restrict__
+#endif
+#endif
+#if defined(__lzo_restrict)
+#  ifndef __lzo_HAVE_restrict
+#  define __lzo_HAVE_restrict 1
+#  endif
+#else
+#  define __lzo_restrict        /*empty*/
+#endif
+#if !defined(__lzo_alignof)
+#if (LZO_CC_ARMCC || LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
+#  define __lzo_alignof(e)      __alignof__(e)
+#elif (LZO_CC_GHS) && !defined(__cplusplus)
+#  define __lzo_alignof(e)      __alignof__(e)
+#elif (LZO_CC_IBMC >= 600)
+#  define __lzo_alignof(e)      (__lzo_gnuc_extension__ __alignof__(e))
+#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 700))
+#  define __lzo_alignof(e)      __alignof__(e)
+#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
+#  define __lzo_alignof(e)      __alignof(e)
+#elif (LZO_CC_SUNPROC >= 0x5100)
+#  define __lzo_alignof(e)      __alignof__(e)
+#endif
+#endif
+#if defined(__lzo_alignof)
+#  ifndef __lzo_HAVE_alignof
+#  define __lzo_HAVE_alignof 1
+#  endif
+#endif
+#if !defined(__lzo_struct_packed)
+#if   (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020800ul)) && defined(__cplusplus)
+#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020700ul))
+#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020800ul)) && defined(__cplusplus)
+#elif (LZO_CC_PCC && (LZO_CC_PCC < 0x010100ul))
+#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC < 0x5110)) && !defined(__cplusplus)
+#elif (LZO_CC_GNUC >= 0x030400ul) && !(LZO_CC_PCC_GNUC) && (LZO_ARCH_AMD64 || LZO_ARCH_I386)
+#  define __lzo_struct_packed(s)        struct s {
+#  define __lzo_struct_packed_end()     } __attribute__((__gcc_struct__,__packed__));
+#  define __lzo_struct_packed_ma_end()  } __lzo_may_alias __attribute__((__gcc_struct__,__packed__));
+#elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || (LZO_CC_PGI >= 0x0d0a00ul) || (LZO_CC_SUNPROC >= 0x5100))
+#  define __lzo_struct_packed(s)        struct s {
+#  define __lzo_struct_packed_end()     } __attribute__((__packed__));
+#  define __lzo_struct_packed_ma_end()  } __lzo_may_alias __attribute__((__packed__));
+#elif (LZO_CC_IBMC >= 700)
+#  define __lzo_struct_packed(s)        __lzo_gnuc_extension__ struct s {
+#  define __lzo_struct_packed_end()     } __attribute__((__packed__));
+#  define __lzo_struct_packed_ma_end()  } __lzo_may_alias __attribute__((__packed__));
+#elif (LZO_CC_INTELC_MSC) || (LZO_CC_MSC && (_MSC_VER >= 1300))
+#  define __lzo_struct_packed(s)        __pragma(pack(push,1)) struct s {
+#  define __lzo_struct_packed_end()     } __pragma(pack(pop));
+#elif (LZO_CC_WATCOMC && (__WATCOMC__ >= 900))
+#  define __lzo_struct_packed(s)        _Packed struct s {
+#  define __lzo_struct_packed_end()     };
+#endif
+#endif
+#if defined(__lzo_struct_packed) && !defined(__lzo_struct_packed_ma)
+#  define __lzo_struct_packed_ma(s)     __lzo_struct_packed(s)
+#endif
+#if defined(__lzo_struct_packed_end) && !defined(__lzo_struct_packed_ma_end)
+#  define __lzo_struct_packed_ma_end()  __lzo_struct_packed_end()
+#endif
+#if !defined(__lzo_byte_struct)
+#if defined(__lzo_struct_packed)
+#  define __lzo_byte_struct(s,n)        __lzo_struct_packed(s) unsigned char a[n]; __lzo_struct_packed_end()
+#  define __lzo_byte_struct_ma(s,n)     __lzo_struct_packed_ma(s) unsigned char a[n]; __lzo_struct_packed_ma_end()
+#elif (LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_PGI || (LZO_CC_SUNPROC >= 0x5100))
+#  define __lzo_byte_struct(s,n)        struct s { unsigned char a[n]; } __attribute__((__packed__));
+#  define __lzo_byte_struct_ma(s,n)     struct s { unsigned char a[n]; } __lzo_may_alias __attribute__((__packed__));
+#endif
+#endif
+#if defined(__lzo_byte_struct) &&  !defined(__lzo_byte_struct_ma)
+#  define __lzo_byte_struct_ma(s,n)     __lzo_byte_struct(s,n)
+#endif
+#if !defined(__lzo_struct_align16) && (__lzo_HAVE_alignof)
+#if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x030000ul))
+#elif (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020800ul)) && defined(__cplusplus)
+#elif (LZO_CC_CILLY || LZO_CC_PCC)
+#elif (LZO_CC_INTELC_MSC) || (LZO_CC_MSC && (_MSC_VER >= 1300))
+#  define __lzo_struct_align16(s)       struct __declspec(align(16)) s {
+#  define __lzo_struct_align16_end()    };
+#  define __lzo_struct_align32(s)       struct __declspec(align(32)) s {
+#  define __lzo_struct_align32_end()    };
+#  define __lzo_struct_align64(s)       struct __declspec(align(64)) s {
+#  define __lzo_struct_align64_end()    };
+#elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_GNUC || (LZO_CC_IBMC >= 700) || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_struct_align16(s)       struct s {
+#  define __lzo_struct_align16_end()    } __attribute__((__aligned__(16)));
+#  define __lzo_struct_align32(s)       struct s {
+#  define __lzo_struct_align32_end()    } __attribute__((__aligned__(32)));
+#  define __lzo_struct_align64(s)       struct s {
+#  define __lzo_struct_align64_end()    } __attribute__((__aligned__(64)));
+#endif
+#endif
+#if !defined(__lzo_union_um)
+#if   (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020800ul)) && defined(__cplusplus)
+#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020700ul))
+#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020800ul)) && defined(__cplusplus)
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER < 810))
+#elif (LZO_CC_PCC && (LZO_CC_PCC < 0x010100ul))
+#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC < 0x5110)) && !defined(__cplusplus)
+#elif (LZO_CC_ARMCC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || (LZO_CC_PGI >= 0x0d0a00ul) || (LZO_CC_SUNPROC >= 0x5100))
+#  define __lzo_union_am(s)             union s {
+#  define __lzo_union_am_end()          } __lzo_may_alias;
+#  define __lzo_union_um(s)             union s {
+#  define __lzo_union_um_end()          } __lzo_may_alias __attribute__((__packed__));
+#elif (LZO_CC_IBMC >= 700)
+#  define __lzo_union_am(s)             __lzo_gnuc_extension__ union s {
+#  define __lzo_union_am_end()          } __lzo_may_alias;
+#  define __lzo_union_um(s)             __lzo_gnuc_extension__ union s {
+#  define __lzo_union_um_end()          } __lzo_may_alias __attribute__((__packed__));
+#elif (LZO_CC_INTELC_MSC) || (LZO_CC_MSC && (_MSC_VER >= 1300))
+#  define __lzo_union_um(s)             __pragma(pack(push,1)) union s {
+#  define __lzo_union_um_end()          } __pragma(pack(pop));
+#elif (LZO_CC_WATCOMC && (__WATCOMC__ >= 900))
+#  define __lzo_union_um(s)             _Packed union s {
+#  define __lzo_union_um_end()          };
+#endif
+#endif
+#if !defined(__lzo_union_am)
+#  define __lzo_union_am(s)             union s {
+#  define __lzo_union_am_end()          };
+#endif
+#if !defined(__lzo_constructor)
+#if (LZO_CC_GNUC >= 0x030400ul)
+#  define __lzo_constructor     __attribute__((__constructor__,__used__))
+#elif (LZO_CC_GNUC >= 0x020700ul)
+#  define __lzo_constructor     __attribute__((__constructor__))
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
+#  define __lzo_constructor     __attribute__((__constructor__,__used__))
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_constructor     __attribute__((__constructor__))
+#endif
+#endif
+#if defined(__lzo_constructor)
+#  ifndef __lzo_HAVE_constructor
+#  define __lzo_HAVE_constructor 1
+#  endif
+#endif
+#if !defined(__lzo_destructor)
+#if (LZO_CC_GNUC >= 0x030400ul)
+#  define __lzo_destructor      __attribute__((__destructor__,__used__))
+#elif (LZO_CC_GNUC >= 0x020700ul)
+#  define __lzo_destructor      __attribute__((__destructor__))
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 800))
+#  define __lzo_destructor      __attribute__((__destructor__,__used__))
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_destructor      __attribute__((__destructor__))
+#endif
+#endif
+#if defined(__lzo_destructor)
+#  ifndef __lzo_HAVE_destructor
+#  define __lzo_HAVE_destructor 1
+#  endif
+#endif
+#if (__lzo_HAVE_destructor) && !(__lzo_HAVE_constructor)
+#  error "unexpected configuration - check your compiler defines"
+#endif
+#if !defined(__lzo_likely) && !defined(__lzo_unlikely)
+#if (LZO_CC_GNUC >= 0x030200ul)
+#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
+#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
+#elif (LZO_CC_IBMC >= 1010)
+#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
+#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
+#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800))
+#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
+#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
+#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
+#endif
+#endif
+#if defined(__lzo_likely)
+#  ifndef __lzo_HAVE_likely
+#  define __lzo_HAVE_likely 1
+#  endif
+#else
+#  define __lzo_likely(e)       (e)
+#endif
+#if defined(__lzo_unlikely)
+#  ifndef __lzo_HAVE_unlikely
+#  define __lzo_HAVE_unlikely 1
+#  endif
+#else
+#  define __lzo_unlikely(e)     (e)
+#endif
+#if !defined(__lzo_static_unused_void_func)
+#  if 1 && (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || (LZO_CC_GNUC >= 0x020700ul) || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
+#    define __lzo_static_unused_void_func(f)    static void __attribute__((__unused__)) f(void)
+#  else
+#    define __lzo_static_unused_void_func(f)    static __lzo_inline void f(void)
+#  endif
+#endif
+#if !defined(__lzo_loop_forever)
+#  if (LZO_CC_IBMC)
+#    define __lzo_loop_forever()    LZO_BLOCK_BEGIN for (;;) { ; } LZO_BLOCK_END
+#  else
+#    define __lzo_loop_forever()    do { ; } while __lzo_cte(1)
+#  endif
+#endif
+#if !defined(__lzo_unreachable)
+#if (LZO_CC_CLANG && (LZO_CC_CLANG >= 0x020800ul))
+#  define __lzo_unreachable()       __builtin_unreachable();
+#elif (LZO_CC_GNUC >= 0x040500ul)
+#  define __lzo_unreachable()       __builtin_unreachable();
+#elif (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 1300)) && 1
+#  define __lzo_unreachable()       __builtin_unreachable();
+#endif
+#endif
+#if defined(__lzo_unreachable)
+#  ifndef __lzo_HAVE_unreachable
+#  define __lzo_HAVE_unreachable 1
+#  endif
+#else
+#  if 0
+#  define __lzo_unreachable()       ((void)0);
+#  else
+#  define __lzo_unreachable()       __lzo_loop_forever();
+#  endif
+#endif
+#ifndef __LZO_CTA_NAME
+#if (LZO_CFG_USE_COUNTER)
+#  define __LZO_CTA_NAME(a)         LZO_PP_ECONCAT2(a,__COUNTER__)
+#else
+#  define __LZO_CTA_NAME(a)         LZO_PP_ECONCAT2(a,__LINE__)
+#endif
+#endif
+#if !defined(LZO_COMPILE_TIME_ASSERT_HEADER)
+#  if (LZO_CC_AZTECC || LZO_CC_ZORTECHC)
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1-!(e)]; LZO_EXTERN_C_END
+#  elif (LZO_CC_DMC || LZO_CC_SYMANTECC)
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1u-2*!(e)]; LZO_EXTERN_C_END
+#  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1-!(e)]; LZO_EXTERN_C_END
+#  elif (LZO_CC_CLANG && (LZO_CC_CLANG < 0x020900ul)) && defined(__cplusplus)
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN int __LZO_CTA_NAME(lzo_cta_f__)(int [1-2*!(e)]); LZO_EXTERN_C_END
+#  elif (LZO_CC_GNUC) && defined(__CHECKER__) && defined(__SPARSE_CHECKER__)
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN enum {__LZO_CTA_NAME(lzo_cta_e__)=1/!!(e)} __attribute__((__unused__)); LZO_EXTERN_C_END
+#  else
+#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  LZO_EXTERN_C_BEGIN extern int __LZO_CTA_NAME(lzo_cta__)[1-2*!(e)]; LZO_EXTERN_C_END
+#  endif
+#endif
+#if !defined(LZO_COMPILE_TIME_ASSERT)
+#  if (LZO_CC_AZTECC)
+#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __LZO_CTA_NAME(lzo_cta_t__)[1-!(e)];}
+#  elif (LZO_CC_DMC || LZO_CC_PACIFICC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
+#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
+#  elif (LZO_CC_GNUC) && defined(__CHECKER__) && defined(__SPARSE_CHECKER__)
+#    define LZO_COMPILE_TIME_ASSERT(e)  {(void) (0/!!(e));}
+#  elif (LZO_CC_GNUC >= 0x040700ul) && (LZO_CFG_USE_COUNTER) && defined(__cplusplus)
+#    define LZO_COMPILE_TIME_ASSERT(e)  {enum {__LZO_CTA_NAME(lzo_cta_e__)=1/!!(e)} __attribute__((__unused__));}
+#  elif (LZO_CC_GNUC >= 0x040700ul)
+#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __LZO_CTA_NAME(lzo_cta_t__)[1-2*!(e)] __attribute__((__unused__));}
+#  elif (LZO_CC_MSC && (_MSC_VER < 900))
+#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
+#  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
+#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
+#  else
+#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __LZO_CTA_NAME(lzo_cta_t__)[1-2*!(e)];}
+#  endif
+#endif
+LZO_COMPILE_TIME_ASSERT_HEADER(1 == 1)
+#if defined(__cplusplus)
+extern "C" { LZO_COMPILE_TIME_ASSERT_HEADER(2 == 2) }
+#endif
+LZO_COMPILE_TIME_ASSERT_HEADER(3 == 3)
+#if (LZO_ARCH_I086 || LZO_ARCH_I386) && (LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_OS216 || LZO_OS_WIN16 || LZO_OS_WIN32 || LZO_OS_WIN64)
+#  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC)
+#  elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
+#    define __lzo_cdecl                 __cdecl
+#    define __lzo_cdecl_atexit          /*empty*/
+#    define __lzo_cdecl_main            __cdecl
+#    if (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
+#      define __lzo_cdecl_qsort         __pascal
+#    elif (LZO_OS_OS2 && (LZO_CC_ZORTECHC))
+#      define __lzo_cdecl_qsort         _stdcall
+#    else
+#      define __lzo_cdecl_qsort         __cdecl
+#    endif
+#  elif (LZO_CC_WATCOMC)
+#    define __lzo_cdecl                 __cdecl
+#  else
+#    define __lzo_cdecl                 __cdecl
+#    define __lzo_cdecl_atexit          __cdecl
+#    define __lzo_cdecl_main            __cdecl
+#    define __lzo_cdecl_qsort           __cdecl
+#  endif
+#  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC || LZO_CC_WATCOMC)
+#  elif (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
+#    define __lzo_cdecl_sighandler      __pascal
+#  elif (LZO_OS_OS2 && (LZO_CC_ZORTECHC))
+#    define __lzo_cdecl_sighandler      _stdcall
+#  elif (LZO_CC_MSC && (_MSC_VER >= 1400)) && defined(_M_CEE_PURE)
+#    define __lzo_cdecl_sighandler      __clrcall
+#  elif (LZO_CC_MSC && (_MSC_VER >= 600 && _MSC_VER < 700))
+#    if defined(_DLL)
+#      define __lzo_cdecl_sighandler    _far _cdecl _loadds
+#    elif defined(_MT)
+#      define __lzo_cdecl_sighandler    _far _cdecl
+#    else
+#      define __lzo_cdecl_sighandler    _cdecl
+#    endif
+#  else
+#    define __lzo_cdecl_sighandler      __cdecl
+#  endif
+#elif (LZO_ARCH_I386) && (LZO_CC_WATCOMC)
+#  define __lzo_cdecl                   __cdecl
+#elif (LZO_ARCH_M68K && LZO_OS_TOS && (LZO_CC_PUREC || LZO_CC_TURBOC))
+#  define __lzo_cdecl                   cdecl
+#endif
+#if !defined(__lzo_cdecl)
+#  define __lzo_cdecl                   /*empty*/
+#endif
+#if !defined(__lzo_cdecl_atexit)
+#  define __lzo_cdecl_atexit            /*empty*/
+#endif
+#if !defined(__lzo_cdecl_main)
+#  define __lzo_cdecl_main              /*empty*/
+#endif
+#if !defined(__lzo_cdecl_qsort)
+#  define __lzo_cdecl_qsort             /*empty*/
+#endif
+#if !defined(__lzo_cdecl_sighandler)
+#  define __lzo_cdecl_sighandler        /*empty*/
+#endif
+#if !defined(__lzo_cdecl_va)
+#  define __lzo_cdecl_va                __lzo_cdecl
+#endif
+#if !(LZO_CFG_NO_WINDOWS_H)
+#if !defined(LZO_HAVE_WINDOWS_H)
+#if (LZO_OS_CYGWIN || (LZO_OS_EMX && defined(__RSXNT__)) || LZO_OS_WIN32 || LZO_OS_WIN64)
+#  if (LZO_CC_WATCOMC && (__WATCOMC__ < 1000))
+#  elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__PW32__)
+#  elif ((LZO_OS_CYGWIN || defined(__MINGW32__)) && (LZO_CC_GNUC && (LZO_CC_GNUC < 0x025f00ul)))
+#  else
+#    define LZO_HAVE_WINDOWS_H 1
+#  endif
+#endif
+#endif
+#endif
+#ifndef LZO_SIZEOF_SHORT
 #if defined(SIZEOF_SHORT)
 #  define LZO_SIZEOF_SHORT          (SIZEOF_SHORT)
+#elif defined(__SIZEOF_SHORT__)
+#  define LZO_SIZEOF_SHORT          (__SIZEOF_SHORT__)
+#endif
 #endif
+#ifndef LZO_SIZEOF_INT
 #if defined(SIZEOF_INT)
 #  define LZO_SIZEOF_INT            (SIZEOF_INT)
+#elif defined(__SIZEOF_INT__)
+#  define LZO_SIZEOF_INT            (__SIZEOF_INT__)
+#endif
 #endif
+#ifndef LZO_SIZEOF_LONG
 #if defined(SIZEOF_LONG)
 #  define LZO_SIZEOF_LONG           (SIZEOF_LONG)
+#elif defined(__SIZEOF_LONG__)
+#  define LZO_SIZEOF_LONG           (__SIZEOF_LONG__)
 #endif
+#endif
+#ifndef LZO_SIZEOF_LONG_LONG
 #if defined(SIZEOF_LONG_LONG)
 #  define LZO_SIZEOF_LONG_LONG      (SIZEOF_LONG_LONG)
+#elif defined(__SIZEOF_LONG_LONG__)
+#  define LZO_SIZEOF_LONG_LONG      (__SIZEOF_LONG_LONG__)
+#endif
 #endif
+#ifndef LZO_SIZEOF___INT16
 #if defined(SIZEOF___INT16)
 #  define LZO_SIZEOF___INT16        (SIZEOF___INT16)
 #endif
+#endif
+#ifndef LZO_SIZEOF___INT32
 #if defined(SIZEOF___INT32)
 #  define LZO_SIZEOF___INT32        (SIZEOF___INT32)
 #endif
+#endif
+#ifndef LZO_SIZEOF___INT64
 #if defined(SIZEOF___INT64)
 #  define LZO_SIZEOF___INT64        (SIZEOF___INT64)
 #endif
+#endif
+#ifndef LZO_SIZEOF_VOID_P
 #if defined(SIZEOF_VOID_P)
 #  define LZO_SIZEOF_VOID_P         (SIZEOF_VOID_P)
+#elif defined(__SIZEOF_POINTER__)
+#  define LZO_SIZEOF_VOID_P         (__SIZEOF_POINTER__)
+#endif
 #endif
+#ifndef LZO_SIZEOF_SIZE_T
 #if defined(SIZEOF_SIZE_T)
 #  define LZO_SIZEOF_SIZE_T         (SIZEOF_SIZE_T)
+#elif defined(__SIZEOF_SIZE_T__)
+#  define LZO_SIZEOF_SIZE_T         (__SIZEOF_SIZE_T__)
 #endif
+#endif
+#ifndef LZO_SIZEOF_PTRDIFF_T
 #if defined(SIZEOF_PTRDIFF_T)
 #  define LZO_SIZEOF_PTRDIFF_T      (SIZEOF_PTRDIFF_T)
+#elif defined(__SIZEOF_PTRDIFF_T__)
+#  define LZO_SIZEOF_PTRDIFF_T      (__SIZEOF_PTRDIFF_T__)
+#endif
 #endif
 #define __LZO_LSR(x,b)    (((x)+0ul) >> (b))
 #if !defined(LZO_SIZEOF_SHORT)
@@ -1035,6 +2040,7 @@ extern "C" {
 #    error "LZO_SIZEOF_SHORT"
 #  endif
 #endif
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_SHORT == sizeof(short))
 #if !defined(LZO_SIZEOF_INT)
 #  if (LZO_ARCH_CRAY_PVP)
 #    define LZO_SIZEOF_INT          8
@@ -1056,6 +2062,7 @@ extern "C" {
 #    error "LZO_SIZEOF_INT"
 #  endif
 #endif
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_INT == sizeof(int))
 #if !defined(LZO_SIZEOF_LONG)
 #  if (ULONG_MAX == LZO_0xffffffffL)
 #    define LZO_SIZEOF_LONG         4
@@ -1065,6 +2072,8 @@ extern "C" {
 #    define LZO_SIZEOF_LONG         2
 #  elif (__LZO_LSR(ULONG_MAX,31) == 1)
 #    define LZO_SIZEOF_LONG         4
+#  elif (__LZO_LSR(ULONG_MAX,39) == 1)
+#    define LZO_SIZEOF_LONG         5
 #  elif (__LZO_LSR(ULONG_MAX,63) == 1)
 #    define LZO_SIZEOF_LONG         8
 #  elif (__LZO_LSR(ULONG_MAX,127) == 1)
@@ -1073,11 +2082,12 @@ extern "C" {
 #    error "LZO_SIZEOF_LONG"
 #  endif
 #endif
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_LONG == sizeof(long))
 #if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
 #if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
 #  if defined(__LONG_MAX__) && defined(__LONG_LONG_MAX__)
 #    if (LZO_CC_GNUC >= 0x030300ul)
-#      if ((__LONG_MAX__)+0 == (__LONG_LONG_MAX__)+0)
+#      if ((__LONG_MAX__-0) == (__LONG_LONG_MAX__-0))
 #        define LZO_SIZEOF_LONG_LONG      LZO_SIZEOF_LONG
 #      elif (__LZO_LSR(__LONG_LONG_MAX__,30) == 1)
 #        define LZO_SIZEOF_LONG_LONG      4
@@ -1091,7 +2101,7 @@ extern "C" {
 #if (LZO_ARCH_I086 && LZO_CC_DMC)
 #elif (LZO_CC_CILLY) && defined(__GNUC__)
 #  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#elif (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
 #  define LZO_SIZEOF_LONG_LONG      8
 #elif ((LZO_OS_WIN32 || LZO_OS_WIN64 || defined(_WIN32)) && LZO_CC_MSC && (_MSC_VER >= 1400))
 #  define LZO_SIZEOF_LONG_LONG      8
@@ -1113,11 +2123,13 @@ extern "C" {
 #  define LZO_SIZEOF___INT64        8
 #elif (LZO_ARCH_I386 && (LZO_CC_WATCOMC && (__WATCOMC__ >= 1100)))
 #  define LZO_SIZEOF___INT64        8
-#elif (LZO_CC_WATCOMC && defined(_INTEGRAL_MAX_BITS) && (_INTEGRAL_MAX_BITS == 64))
+#elif (LZO_CC_GHS && defined(__LLONG_BIT) && ((__LLONG_BIT-0) == 64))
+#  define LZO_SIZEOF_LONG_LONG      8
+#elif (LZO_CC_WATCOMC && defined(_INTEGRAL_MAX_BITS) && ((_INTEGRAL_MAX_BITS-0) == 64))
 #  define LZO_SIZEOF___INT64        8
 #elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
 #  define LZO_SIZEOF_LONG_LONG      8
-#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
+#elif (defined(__vms) || defined(__VMS)) && ((__INITIAL_POINTER_SIZE-0) == 64)
 #  define LZO_SIZEOF_LONG_LONG      8
 #elif (LZO_CC_SDCC) && (LZO_SIZEOF_INT == 2)
 #elif 1 && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
@@ -1125,92 +2137,132 @@ extern "C" {
 #endif
 #endif
 #endif
-#if defined(__cplusplus) && defined(LZO_CC_GNUC)
+#if defined(__cplusplus) && (LZO_CC_GNUC)
 #  if (LZO_CC_GNUC < 0x020800ul)
 #    undef LZO_SIZEOF_LONG_LONG
 #  endif
 #endif
-#if defined(LZO_CFG_NO_LONG_LONG) || defined(__NO_LONG_LONG)
+#if (LZO_CFG_NO_LONG_LONG)
+#  undef LZO_SIZEOF_LONG_LONG
+#elif defined(__NO_LONG_LONG)
+#  undef LZO_SIZEOF_LONG_LONG
+#elif defined(_NO_LONGLONG)
 #  undef LZO_SIZEOF_LONG_LONG
 #endif
-#if !defined(LZO_SIZEOF_VOID_P)
-#if (LZO_ARCH_I086)
-#  define __LZO_WORDSIZE            2
-#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM)
-#    define LZO_SIZEOF_VOID_P       2
-#  elif (LZO_MM_COMPACT || LZO_MM_LARGE || LZO_MM_HUGE)
-#    define LZO_SIZEOF_VOID_P       4
+#if !defined(LZO_WORDSIZE)
+#if (LZO_ARCH_ALPHA)
+#  define LZO_WORDSIZE              8
+#elif (LZO_ARCH_AMD64)
+#  define LZO_WORDSIZE              8
+#elif (LZO_ARCH_AVR)
+#  define LZO_WORDSIZE              1
+#elif (LZO_ARCH_H8300)
+#  if defined(__NORMAL_MODE__)
+#    define LZO_WORDSIZE            4
+#  elif defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
+#    define LZO_WORDSIZE            4
 #  else
-#    error "LZO_MM"
+#    define LZO_WORDSIZE            2
 #  endif
-#elif (LZO_ARCH_AVR || LZO_ARCH_Z80)
-#  define __LZO_WORDSIZE            1
+#elif (LZO_ARCH_I086)
+#  define LZO_WORDSIZE              2
+#elif (LZO_ARCH_IA64)
+#  define LZO_WORDSIZE              8
+#elif (LZO_ARCH_M16C)
+#  define LZO_WORDSIZE              2
+#elif (LZO_ARCH_SPU)
+#  define LZO_WORDSIZE              4
+#elif (LZO_ARCH_Z80)
+#  define LZO_WORDSIZE              1
+#elif (LZO_SIZEOF_LONG == 8) && ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
+#  define LZO_WORDSIZE              8
+#elif (LZO_OS_OS400 || defined(__OS400__))
+#  define LZO_WORDSIZE              8
+#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
+#  define LZO_WORDSIZE              8
+#endif
+#endif
+#if !defined(LZO_SIZEOF_VOID_P)
+#if defined(__ILP32__) || defined(__ILP32) || defined(_ILP32)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(int)  == 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 4)
+#  define LZO_SIZEOF_VOID_P         4
+#elif defined(__ILP64__) || defined(__ILP64) || defined(_ILP64)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(int)  == 8)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 8)
+#  define LZO_SIZEOF_VOID_P         8
+#elif defined(__LLP64__) || defined(__LLP64) || defined(_LLP64) || defined(_WIN64)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 4)
+#  define LZO_SIZEOF_VOID_P         8
+#elif defined(__LP64__) || defined(__LP64) || defined(_LP64)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(long) == 8)
+#  define LZO_SIZEOF_VOID_P         8
+#elif (LZO_ARCH_AVR)
 #  define LZO_SIZEOF_VOID_P         2
 #elif (LZO_ARCH_C166 || LZO_ARCH_MCS51 || LZO_ARCH_MCS251 || LZO_ARCH_MSP430)
 #  define LZO_SIZEOF_VOID_P         2
 #elif (LZO_ARCH_H8300)
 #  if defined(__NORMAL_MODE__)
-#    define __LZO_WORDSIZE          4
 #    define LZO_SIZEOF_VOID_P       2
 #  elif defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
-#    define __LZO_WORDSIZE          4
 #    define LZO_SIZEOF_VOID_P       4
 #  else
-#    define __LZO_WORDSIZE          2
 #    define LZO_SIZEOF_VOID_P       2
 #  endif
 #  if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x040000ul)) && (LZO_SIZEOF_INT == 4)
 #    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_INT
 #    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_INT
 #  endif
+#elif (LZO_ARCH_I086)
+#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM)
+#    define LZO_SIZEOF_VOID_P       2
+#  elif (LZO_MM_COMPACT || LZO_MM_LARGE || LZO_MM_HUGE)
+#    define LZO_SIZEOF_VOID_P       4
+#  else
+#    error "invalid LZO_ARCH_I086 memory model"
+#  endif
 #elif (LZO_ARCH_M16C)
-#  define __LZO_WORDSIZE            2
 #  if defined(__m32c_cpu__) || defined(__m32cm_cpu__)
 #    define LZO_SIZEOF_VOID_P       4
 #  else
 #    define LZO_SIZEOF_VOID_P       2
 #  endif
+#elif (LZO_ARCH_SPU)
+#  define LZO_SIZEOF_VOID_P         4
+#elif (LZO_ARCH_Z80)
+#  define LZO_SIZEOF_VOID_P         2
 #elif (LZO_SIZEOF_LONG == 8) && ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
-#  define __LZO_WORDSIZE            8
 #  define LZO_SIZEOF_VOID_P         4
-#elif defined(__LLP64__) || defined(__LLP64) || defined(_LLP64) || defined(_WIN64)
-#  define __LZO_WORDSIZE            8
-#  define LZO_SIZEOF_VOID_P         8
-#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
-#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
 #elif (LZO_OS_OS400 || defined(__OS400__))
-#  define __LZO_WORDSIZE            LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_VOID_P         16
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
+#  if defined(__LLP64_IFC__)
+#    define LZO_SIZEOF_VOID_P       8
+#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_LONG
+#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_LONG
+#  else
+#    define LZO_SIZEOF_VOID_P       16
+#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_LONG
+#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_LONG
+#  endif
 #elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
 #  define LZO_SIZEOF_VOID_P         8
 #  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
 #  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (LZO_ARCH_SPU)
-# if 0
-#  define __LZO_WORDSIZE            16
-# endif
-#  define LZO_SIZEOF_VOID_P         4
-#else
-#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
 #endif
 #endif
-#if !defined(LZO_WORDSIZE)
-#  if defined(__LZO_WORDSIZE)
-#    define LZO_WORDSIZE            __LZO_WORDSIZE
-#  else
-#    define LZO_WORDSIZE            LZO_SIZEOF_VOID_P
-#  endif
+#if !defined(LZO_SIZEOF_VOID_P)
+#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
 #endif
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_VOID_P == sizeof(void *))
 #if !defined(LZO_SIZEOF_SIZE_T)
 #if (LZO_ARCH_I086 || LZO_ARCH_M16C)
 #  define LZO_SIZEOF_SIZE_T         2
-#else
+#endif
+#endif
+#if !defined(LZO_SIZEOF_SIZE_T)
 #  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_VOID_P
 #endif
+#if defined(offsetof)
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_SIZE_T == sizeof(size_t))
 #endif
 #if !defined(LZO_SIZEOF_PTRDIFF_T)
 #if (LZO_ARCH_I086)
@@ -1223,21 +2275,30 @@ extern "C" {
 #      define LZO_SIZEOF_PTRDIFF_T  2
 #    endif
 #  else
-#    error "LZO_MM"
+#    error "invalid LZO_ARCH_I086 memory model"
 #  endif
-#else
+#endif
+#endif
+#if !defined(LZO_SIZEOF_PTRDIFF_T)
 #  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_SIZE_T
 #endif
+#if defined(offsetof)
+LZO_COMPILE_TIME_ASSERT_HEADER(LZO_SIZEOF_PTRDIFF_T == sizeof(ptrdiff_t))
+#endif
+#if !defined(LZO_WORDSIZE)
+#  define LZO_WORDSIZE              LZO_SIZEOF_VOID_P
 #endif
-#if defined(LZO_ABI_NEUTRAL_ENDIAN)
+#if (LZO_ABI_NEUTRAL_ENDIAN)
 #  undef LZO_ABI_BIG_ENDIAN
 #  undef LZO_ABI_LITTLE_ENDIAN
-#elif !defined(LZO_ABI_BIG_ENDIAN) && !defined(LZO_ABI_LITTLE_ENDIAN)
+#elif !(LZO_ABI_BIG_ENDIAN) && !(LZO_ABI_LITTLE_ENDIAN)
 #if (LZO_ARCH_ALPHA) && (LZO_ARCH_CRAY_MPP)
 #  define LZO_ABI_BIG_ENDIAN        1
+#elif (LZO_ARCH_IA64) && (LZO_OS_POSIX_LINUX || LZO_OS_WIN64)
+#  define LZO_ABI_LITTLE_ENDIAN     1
 #elif (LZO_ARCH_ALPHA || LZO_ARCH_AMD64 || LZO_ARCH_BLACKFIN || LZO_ARCH_CRIS || LZO_ARCH_I086 || LZO_ARCH_I386 || LZO_ARCH_MSP430)
 #  define LZO_ABI_LITTLE_ENDIAN     1
-#elif (LZO_ARCH_M68K || LZO_ARCH_S390)
+#elif (LZO_ARCH_AVR32 || LZO_ARCH_M68K || LZO_ARCH_S390 || LZO_ARCH_SPU)
 #  define LZO_ABI_BIG_ENDIAN        1
 #elif 1 && defined(__IAR_SYSTEMS_ICC__) && defined(__LITTLE_ENDIAN__)
 #  if (__LITTLE_ENDIAN__ == 1)
@@ -1253,20 +2314,33 @@ extern "C" {
 #  define LZO_ABI_BIG_ENDIAN        1
 #elif 1 && (LZO_ARCH_ARM) && defined(__ARMEL__) && !defined(__ARMEB__)
 #  define LZO_ABI_LITTLE_ENDIAN     1
+#elif 1 && (LZO_ARCH_ARM && LZO_CC_ARMCC_ARMCC)
+#  if defined(__BIG_ENDIAN) && defined(__LITTLE_ENDIAN)
+#    error "unexpected configuration - check your compiler defines"
+#  elif defined(__BIG_ENDIAN)
+#    define LZO_ABI_BIG_ENDIAN      1
+#  else
+#    define LZO_ABI_LITTLE_ENDIAN   1
+#  endif
+#  define LZO_ABI_LITTLE_ENDIAN     1
+#elif 1 && (LZO_ARCH_ARM64) && defined(__AARCH64EB__) && !defined(__AARCH64EL__)
+#  define LZO_ABI_BIG_ENDIAN        1
+#elif 1 && (LZO_ARCH_ARM64) && defined(__AARCH64EL__) && !defined(__AARCH64EB__)
+#  define LZO_ABI_LITTLE_ENDIAN     1
 #elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEB__) && !defined(__MIPSEL__)
 #  define LZO_ABI_BIG_ENDIAN        1
 #elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEL__) && !defined(__MIPSEB__)
 #  define LZO_ABI_LITTLE_ENDIAN     1
 #endif
 #endif
-#if defined(LZO_ABI_BIG_ENDIAN) && defined(LZO_ABI_LITTLE_ENDIAN)
-#  error "this should not happen"
+#if (LZO_ABI_BIG_ENDIAN) && (LZO_ABI_LITTLE_ENDIAN)
+#  error "unexpected configuration - check your compiler defines"
 #endif
-#if defined(LZO_ABI_BIG_ENDIAN)
+#if (LZO_ABI_BIG_ENDIAN)
 #  define LZO_INFO_ABI_ENDIAN       "be"
-#elif defined(LZO_ABI_LITTLE_ENDIAN)
+#elif (LZO_ABI_LITTLE_ENDIAN)
 #  define LZO_INFO_ABI_ENDIAN       "le"
-#elif defined(LZO_ABI_NEUTRAL_ENDIAN)
+#elif (LZO_ABI_NEUTRAL_ENDIAN)
 #  define LZO_INFO_ABI_ENDIAN       "neutral"
 #endif
 #if (LZO_SIZEOF_INT == 1 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
@@ -1275,6 +2349,9 @@ extern "C" {
 #elif (LZO_SIZEOF_INT == 2 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
 #  define LZO_ABI_ILP16         1
 #  define LZO_INFO_ABI_PM       "ilp16"
+#elif (LZO_SIZEOF_INT == 2 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 4)
+#  define LZO_ABI_LP32          1
+#  define LZO_INFO_ABI_PM       "lp32"
 #elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 4)
 #  define LZO_ABI_ILP32         1
 #  define LZO_INFO_ABI_PM       "ilp32"
@@ -1291,17 +2368,21 @@ extern "C" {
 #  define LZO_ABI_IP32L64       1
 #  define LZO_INFO_ABI_PM       "ip32l64"
 #endif
-#if !defined(__LZO_LIBC_OVERRIDE)
-#if defined(LZO_LIBC_NAKED)
+#if 0
+#elif !defined(__LZO_LIBC_OVERRIDE)
+#if (LZO_LIBC_NAKED)
 #  define LZO_INFO_LIBC         "naked"
-#elif defined(LZO_LIBC_FREESTANDING)
+#elif (LZO_LIBC_FREESTANDING)
 #  define LZO_INFO_LIBC         "freestanding"
-#elif defined(LZO_LIBC_MOSTLY_FREESTANDING)
+#elif (LZO_LIBC_MOSTLY_FREESTANDING)
 #  define LZO_INFO_LIBC         "mfreestanding"
-#elif defined(LZO_LIBC_ISOC90)
+#elif (LZO_LIBC_ISOC90)
 #  define LZO_INFO_LIBC         "isoc90"
-#elif defined(LZO_LIBC_ISOC99)
+#elif (LZO_LIBC_ISOC99)
 #  define LZO_INFO_LIBC         "isoc99"
+#elif (LZO_CC_ARMCC_ARMCC) && defined(__ARMCLIB_VERSION)
+#  define LZO_LIBC_ISOC90       1
+#  define LZO_INFO_LIBC         "isoc90"
 #elif defined(__dietlibc__)
 #  define LZO_LIBC_DIETLIBC     1
 #  define LZO_INFO_LIBC         "dietlibc"
@@ -1310,13 +2391,13 @@ extern "C" {
 #  define LZO_INFO_LIBC         "newlib"
 #elif defined(__UCLIBC__) && defined(__UCLIBC_MAJOR__) && defined(__UCLIBC_MINOR__)
 #  if defined(__UCLIBC_SUBLEVEL__)
-#    define LZO_LIBC_UCLIBC     (__UCLIBC_MAJOR__ * 0x10000L + __UCLIBC_MINOR__ * 0x100 + __UCLIBC_SUBLEVEL__)
+#    define LZO_LIBC_UCLIBC     (__UCLIBC_MAJOR__ * 0x10000L + (__UCLIBC_MINOR__-0) * 0x100 + (__UCLIBC_SUBLEVEL__-0))
 #  else
 #    define LZO_LIBC_UCLIBC     0x00090bL
 #  endif
-#  define LZO_INFO_LIBC         "uclibc"
+#  define LZO_INFO_LIBC         "uc" "libc"
 #elif defined(__GLIBC__) && defined(__GLIBC_MINOR__)
-#  define LZO_LIBC_GLIBC        (__GLIBC__ * 0x10000L + __GLIBC_MINOR__ * 0x100)
+#  define LZO_LIBC_GLIBC        (__GLIBC__ * 0x10000L + (__GLIBC_MINOR__-0) * 0x100)
 #  define LZO_INFO_LIBC         "glibc"
 #elif (LZO_CC_MWERKS) && defined(__MSL__)
 #  define LZO_LIBC_MSL          __MSL__
@@ -1329,435 +2410,170 @@ extern "C" {
 #  define LZO_INFO_LIBC         "default"
 #endif
 #endif
-#if !defined(__lzo_gnuc_extension__)
-#if (LZO_CC_GNUC >= 0x020800ul)
-#  define __lzo_gnuc_extension__    __extension__
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_gnuc_extension__    __extension__
-#else
-#  define __lzo_gnuc_extension__
-#endif
-#endif
-#if !defined(__lzo_ua_volatile)
-#  define __lzo_ua_volatile     volatile
-#endif
-#if !defined(__lzo_alignof)
-#if (LZO_CC_CILLY || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
-#  define __lzo_alignof(e)      __alignof__(e)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 700))
-#  define __lzo_alignof(e)      __alignof__(e)
-#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
-#  define __lzo_alignof(e)      __alignof(e)
-#endif
-#endif
-#if defined(__lzo_alignof)
-#  define __lzo_HAVE_alignof 1
-#endif
-#if !defined(__lzo_constructor)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_constructor     __attribute__((__constructor__,__used__))
-#elif (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_constructor     __attribute__((__constructor__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_constructor     __attribute__((__constructor__))
-#endif
-#endif
-#if defined(__lzo_constructor)
-#  define __lzo_HAVE_constructor 1
-#endif
-#if !defined(__lzo_destructor)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_destructor      __attribute__((__destructor__,__used__))
-#elif (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_destructor      __attribute__((__destructor__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_destructor      __attribute__((__destructor__))
-#endif
-#endif
-#if defined(__lzo_destructor)
-#  define __lzo_HAVE_destructor 1
-#endif
-#if defined(__lzo_HAVE_destructor) && !defined(__lzo_HAVE_constructor)
-#  error "this should not happen"
-#endif
-#if !defined(__lzo_inline)
-#if (LZO_CC_TURBOC && (__TURBOC__ <= 0x0295))
-#elif defined(__cplusplus)
-#  define __lzo_inline          inline
-#elif (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0550))
-#  define __lzo_inline          __inline
-#elif (LZO_CC_CILLY || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
-#  define __lzo_inline          __inline__
-#elif (LZO_CC_DMC)
-#  define __lzo_inline          __inline
-#elif (LZO_CC_INTELC)
-#  define __lzo_inline          __inline
-#elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x2405))
-#  define __lzo_inline          __inline
-#elif (LZO_CC_MSC && (_MSC_VER >= 900))
-#  define __lzo_inline          __inline
-#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
-#  define __lzo_inline          inline
-#endif
-#endif
-#if defined(__lzo_inline)
-#  define __lzo_HAVE_inline 1
-#else
-#  define __lzo_inline
-#endif
-#if !defined(__lzo_forceinline)
-#if (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC)
-#  define __lzo_forceinline     __forceinline
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1200))
-#  define __lzo_forceinline     __forceinline
-#endif
-#endif
-#if defined(__lzo_forceinline)
-#  define __lzo_HAVE_forceinline 1
-#else
-#  define __lzo_forceinline
-#endif
-#if !defined(__lzo_noinline)
-#if 1 && (LZO_ARCH_I386) && (LZO_CC_GNUC >= 0x040000ul) && (LZO_CC_GNUC < 0x040003ul)
-#  define __lzo_noinline        __attribute__((__noinline__,__used__))
-#elif (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_MSC)
-#  define __lzo_noinline        __declspec(noinline)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
-#  define __lzo_noinline        __declspec(noinline)
-#elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x3200) && (LZO_OS_WIN32 || LZO_OS_WIN64))
-#  if defined(__cplusplus)
-#  else
-#    define __lzo_noinline      __declspec(noinline)
-#  endif
-#endif
-#endif
-#if defined(__lzo_noinline)
-#  define __lzo_HAVE_noinline 1
-#else
-#  define __lzo_noinline
-#endif
-#if (defined(__lzo_HAVE_forceinline) || defined(__lzo_HAVE_noinline)) && !defined(__lzo_HAVE_inline)
-#  error "this should not happen"
-#endif
-#if !defined(__lzo_noreturn)
-#if (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC)
-#  define __lzo_noreturn        __declspec(noreturn)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1200))
-#  define __lzo_noreturn        __declspec(noreturn)
-#endif
-#endif
-#if defined(__lzo_noreturn)
-#  define __lzo_HAVE_noreturn 1
-#else
-#  define __lzo_noreturn
-#endif
-#if !defined(__lzo_nothrow)
-#if (LZO_CC_GNUC >= 0x030300ul)
-#  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC) && defined(__cplusplus)
-#  define __lzo_nothrow         __declspec(nothrow)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1200)) && defined(__cplusplus)
-#  define __lzo_nothrow         __declspec(nothrow)
-#endif
-#endif
-#if defined(__lzo_nothrow)
-#  define __lzo_HAVE_nothrow 1
-#else
-#  define __lzo_nothrow
-#endif
-#if !defined(__lzo_restrict)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_restrict        __restrict__
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_restrict        __restrict__
-#elif (LZO_CC_LLVM)
-#  define __lzo_restrict        __restrict__
-#elif (LZO_CC_MSC && (_MSC_VER >= 1400))
-#  define __lzo_restrict        __restrict
-#endif
-#endif
-#if defined(__lzo_restrict)
-#  define __lzo_HAVE_restrict 1
-#else
-#  define __lzo_restrict
-#endif
-#if !defined(__lzo_likely) && !defined(__lzo_unlikely)
-#if (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800))
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#elif (LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#endif
+#if (LZO_ARCH_I386 && (LZO_OS_DOS32 || LZO_OS_WIN32) && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
+#  define LZO_ASM_SYNTAX_MSC 1
+#elif (LZO_OS_WIN64 && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
+#elif (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC == 0x011f00ul))
+#elif (LZO_ARCH_I386 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
+#  define LZO_ASM_SYNTAX_GNUC 1
+#elif (LZO_ARCH_AMD64 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
+#  define LZO_ASM_SYNTAX_GNUC 1
+#elif (LZO_CC_GNUC)
+#  define LZO_ASM_SYNTAX_GNUC 1
 #endif
-#if defined(__lzo_likely)
-#  define __lzo_HAVE_likely 1
-#else
-#  define __lzo_likely(e)       (e)
+#if (LZO_ASM_SYNTAX_GNUC)
+#if (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC < 0x020000ul))
+#  define __LZO_ASM_CLOBBER                     "ax"
+#  define __LZO_ASM_CLOBBER_LIST_CC             /*empty*/
+#  define __LZO_ASM_CLOBBER_LIST_CC_MEMORY      /*empty*/
+#  define __LZO_ASM_CLOBBER_LIST_EMPTY          /*empty*/
+#elif (LZO_CC_INTELC && (__INTEL_COMPILER < 1000))
+#  define __LZO_ASM_CLOBBER                     "memory"
+#  define __LZO_ASM_CLOBBER_LIST_CC             /*empty*/
+#  define __LZO_ASM_CLOBBER_LIST_CC_MEMORY      : "memory"
+#  define __LZO_ASM_CLOBBER_LIST_EMPTY          /*empty*/
+#else
+#  define __LZO_ASM_CLOBBER                     "cc", "memory"
+#  define __LZO_ASM_CLOBBER_LIST_CC             : "cc"
+#  define __LZO_ASM_CLOBBER_LIST_CC_MEMORY      : "cc", "memory"
+#  define __LZO_ASM_CLOBBER_LIST_EMPTY          /*empty*/
 #endif
-#if defined(__lzo_unlikely)
-#  define __lzo_HAVE_unlikely 1
-#else
-#  define __lzo_unlikely(e)     (e)
 #endif
-#if !defined(LZO_UNUSED)
-#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
-#    define LZO_UNUSED(var)         ((void) &var)
-#  elif (LZO_CC_BORLANDC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PELLESC || LZO_CC_TURBOC)
-#    define LZO_UNUSED(var)         if (&var) ; else
-#  elif (LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#    define LZO_UNUSED(var)         ((void) var)
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_UNUSED(var)         if (&var) ; else
-#  elif (LZO_CC_KEILC)
-#    define LZO_UNUSED(var)         {extern int __lzo_unused[1-2*!(sizeof(var)>0)];}
-#  elif (LZO_CC_PACIFICC)
-#    define LZO_UNUSED(var)         ((void) sizeof(var))
-#  elif (LZO_CC_WATCOMC) && defined(__cplusplus)
-#    define LZO_UNUSED(var)         ((void) var)
-#  else
-#    define LZO_UNUSED(var)         ((void) &var)
+#if (LZO_ARCH_ALPHA)
+#  define LZO_OPT_AVOID_UINT_INDEX          1
+#elif (LZO_ARCH_AMD64)
+#  define LZO_OPT_AVOID_INT_INDEX           1
+#  define LZO_OPT_AVOID_UINT_INDEX          1
+#  ifndef LZO_OPT_UNALIGNED16
+#  define LZO_OPT_UNALIGNED16               1
 #  endif
-#endif
-#if !defined(LZO_UNUSED_FUNC)
-#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
-#    define LZO_UNUSED_FUNC(func)   ((void) func)
-#  elif (LZO_CC_BORLANDC || LZO_CC_NDPC || LZO_CC_TURBOC)
-#    define LZO_UNUSED_FUNC(func)   if (func) ; else
-#  elif (LZO_CC_LLVM)
-#    define LZO_UNUSED_FUNC(func)   ((void) &func)
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_UNUSED_FUNC(func)   if (func) ; else
-#  elif (LZO_CC_MSC)
-#    define LZO_UNUSED_FUNC(func)   ((void) &func)
-#  elif (LZO_CC_KEILC || LZO_CC_PELLESC)
-#    define LZO_UNUSED_FUNC(func)   {extern int __lzo_unused[1-2*!(sizeof((int)func)>0)];}
-#  else
-#    define LZO_UNUSED_FUNC(func)   ((void) func)
+#  ifndef LZO_OPT_UNALIGNED32
+#  define LZO_OPT_UNALIGNED32               1
 #  endif
-#endif
-#if !defined(LZO_UNUSED_LABEL)
-#  if (LZO_CC_WATCOMC) && defined(__cplusplus)
-#    define LZO_UNUSED_LABEL(l)     switch(0) case 1:goto l
-#  elif (LZO_CC_INTELC || LZO_CC_WATCOMC)
-#    define LZO_UNUSED_LABEL(l)     if (0) goto l
-#  else
-#    define LZO_UNUSED_LABEL(l)     switch(0) case 1:goto l
+#  ifndef LZO_OPT_UNALIGNED64
+#  define LZO_OPT_UNALIGNED64               1
 #  endif
-#endif
-#if !defined(LZO_DEFINE_UNINITIALIZED_VAR)
-#  if 0
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var
-#  elif 0 && (LZO_CC_GNUC)
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = var
-#  else
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = init
+#elif (LZO_ARCH_ARM)
+#  if defined(__ARM_FEATURE_UNALIGNED)
+#    ifndef LZO_OPT_UNALIGNED16
+#    define LZO_OPT_UNALIGNED16             1
+#    endif
+#    ifndef LZO_OPT_UNALIGNED32
+#    define LZO_OPT_UNALIGNED32             1
+#    endif
+#  elif defined(__TARGET_ARCH_ARM) && ((__TARGET_ARCH_ARM+0) >= 7)
+#    ifndef LZO_OPT_UNALIGNED16
+#    define LZO_OPT_UNALIGNED16             1
+#    endif
+#    ifndef LZO_OPT_UNALIGNED32
+#    define LZO_OPT_UNALIGNED32             1
+#    endif
+#  elif defined(__TARGET_ARCH_ARM) && ((__TARGET_ARCH_ARM+0) >= 6) && !defined(__TARGET_PROFILE_M)
+#    ifndef LZO_OPT_UNALIGNED16
+#    define LZO_OPT_UNALIGNED16             1
+#    endif
+#    ifndef LZO_OPT_UNALIGNED32
+#    define LZO_OPT_UNALIGNED32             1
+#    endif
 #  endif
-#endif
-#if !defined(LZO_COMPILE_TIME_ASSERT_HEADER)
-#  if (LZO_CC_AZTECC || LZO_CC_ZORTECHC)
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-!(e)];
-#  elif (LZO_CC_DMC || LZO_CC_SYMANTECC)
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1u-2*!(e)];
-#  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-!(e)];
-#  else
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-2*!(e)];
+#elif (LZO_ARCH_ARM64)
+#  ifndef LZO_OPT_UNALIGNED16
+#  define LZO_OPT_UNALIGNED16               1
 #  endif
-#endif
-#if !defined(LZO_COMPILE_TIME_ASSERT)
-#  if (LZO_CC_AZTECC)
-#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __lzo_cta_t[1-!(e)];}
-#  elif (LZO_CC_DMC || LZO_CC_PACIFICC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
-#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
-#  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
-#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
-#  else
-#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __lzo_cta_t[1-2*!(e)];}
+#  ifndef LZO_OPT_UNALIGNED32
+#  define LZO_OPT_UNALIGNED32               1
 #  endif
-#endif
-#if (LZO_ARCH_I086 || LZO_ARCH_I386) && (LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_OS216 || LZO_OS_WIN16 || LZO_OS_WIN32 || LZO_OS_WIN64)
-#  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC)
-#  elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
-#    define __lzo_cdecl                 __cdecl
-#    define __lzo_cdecl_atexit
-#    define __lzo_cdecl_main            __cdecl
-#    if (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
-#      define __lzo_cdecl_qsort         __pascal
-#    elif (LZO_OS_OS2 && (LZO_CC_ZORTECHC))
-#      define __lzo_cdecl_qsort         _stdcall
-#    else
-#      define __lzo_cdecl_qsort         __cdecl
-#    endif
-#  elif (LZO_CC_WATCOMC)
-#    define __lzo_cdecl                 __cdecl
-#  else
-#    define __lzo_cdecl                 __cdecl
-#    define __lzo_cdecl_atexit          __cdecl
-#    define __lzo_cdecl_main            __cdecl
-#    define __lzo_cdecl_qsort           __cdecl
+#  ifndef LZO_OPT_UNALIGNED64
+#  define LZO_OPT_UNALIGNED64               1
 #  endif
-#  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC || LZO_CC_WATCOMC)
-#  elif (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
-#    define __lzo_cdecl_sighandler      __pascal
-#  elif (LZO_OS_OS2 && (LZO_CC_ZORTECHC))
-#    define __lzo_cdecl_sighandler      _stdcall
-#  elif (LZO_CC_MSC && (_MSC_VER >= 1400)) && defined(_M_CEE_PURE)
-#    define __lzo_cdecl_sighandler      __clrcall
-#  elif (LZO_CC_MSC && (_MSC_VER >= 600 && _MSC_VER < 700))
-#    if defined(_DLL)
-#      define __lzo_cdecl_sighandler    _far _cdecl _loadds
-#    elif defined(_MT)
-#      define __lzo_cdecl_sighandler    _far _cdecl
-#    else
-#      define __lzo_cdecl_sighandler    _cdecl
-#    endif
-#  else
-#    define __lzo_cdecl_sighandler      __cdecl
+#elif (LZO_ARCH_CRIS)
+#  ifndef LZO_OPT_UNALIGNED16
+#  define LZO_OPT_UNALIGNED16               1
 #  endif
-#elif (LZO_ARCH_I386) && (LZO_CC_WATCOMC)
-#  define __lzo_cdecl                   __cdecl
-#elif (LZO_ARCH_M68K && LZO_OS_TOS && (LZO_CC_PUREC || LZO_CC_TURBOC))
-#  define __lzo_cdecl                   cdecl
-#endif
-#if !defined(__lzo_cdecl)
-#  define __lzo_cdecl
-#endif
-#if !defined(__lzo_cdecl_atexit)
-#  define __lzo_cdecl_atexit
-#endif
-#if !defined(__lzo_cdecl_main)
-#  define __lzo_cdecl_main
-#endif
-#if !defined(__lzo_cdecl_qsort)
-#  define __lzo_cdecl_qsort
-#endif
-#if !defined(__lzo_cdecl_sighandler)
-#  define __lzo_cdecl_sighandler
-#endif
-#if !defined(__lzo_cdecl_va)
-#  define __lzo_cdecl_va                __lzo_cdecl
-#endif
-#if !defined(LZO_CFG_NO_WINDOWS_H)
-#if (LZO_OS_CYGWIN || (LZO_OS_EMX && defined(__RSXNT__)) || LZO_OS_WIN32 || LZO_OS_WIN64)
-#  if (LZO_CC_WATCOMC && (__WATCOMC__ < 1000))
-#  elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__PW32__)
-#  elif ((LZO_OS_CYGWIN || defined(__MINGW32__)) && (LZO_CC_GNUC && (LZO_CC_GNUC < 0x025f00ul)))
-#  else
-#    define LZO_HAVE_WINDOWS_H 1
+#  ifndef LZO_OPT_UNALIGNED32
+#  define LZO_OPT_UNALIGNED32               1
 #  endif
-#endif
-#endif
-#if (LZO_ARCH_ALPHA)
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_AVOID_SHORT       1
-#  define LZO_OPT_AVOID_USHORT      1
-#elif (LZO_ARCH_AMD64)
-#  define LZO_OPT_AVOID_INT_INDEX   1
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#  define LZO_OPT_UNALIGNED64       1
-#elif (LZO_ARCH_ARM && LZO_ARCH_ARM_THUMB)
-#elif (LZO_ARCH_ARM)
-#  define LZO_OPT_AVOID_SHORT       1
-#  define LZO_OPT_AVOID_USHORT      1
-#elif (LZO_ARCH_CRIS)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
 #elif (LZO_ARCH_I386)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
+#  ifndef LZO_OPT_UNALIGNED16
+#  define LZO_OPT_UNALIGNED16               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED32
+#  define LZO_OPT_UNALIGNED32               1
+#  endif
 #elif (LZO_ARCH_IA64)
-#  define LZO_OPT_AVOID_INT_INDEX   1
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_PREFER_POSTINC    1
+#  define LZO_OPT_AVOID_INT_INDEX           1
+#  define LZO_OPT_AVOID_UINT_INDEX          1
+#  define LZO_OPT_PREFER_POSTINC            1
 #elif (LZO_ARCH_M68K)
-#  define LZO_OPT_PREFER_POSTINC    1
-#  define LZO_OPT_PREFER_PREDEC     1
+#  define LZO_OPT_PREFER_POSTINC            1
+#  define LZO_OPT_PREFER_PREDEC             1
 #  if defined(__mc68020__) && !defined(__mcoldfire__)
-#    define LZO_OPT_UNALIGNED16     1
-#    define LZO_OPT_UNALIGNED32     1
+#    ifndef LZO_OPT_UNALIGNED16
+#    define LZO_OPT_UNALIGNED16             1
+#    endif
+#    ifndef LZO_OPT_UNALIGNED32
+#    define LZO_OPT_UNALIGNED32             1
+#    endif
 #  endif
 #elif (LZO_ARCH_MIPS)
-#  define LZO_OPT_AVOID_UINT_INDEX  1
+#  define LZO_OPT_AVOID_UINT_INDEX          1
 #elif (LZO_ARCH_POWERPC)
-#  define LZO_OPT_PREFER_PREINC     1
-#  define LZO_OPT_PREFER_PREDEC     1
-#  if defined(LZO_ABI_BIG_ENDIAN)
-#    define LZO_OPT_UNALIGNED16     1
-#    define LZO_OPT_UNALIGNED32     1
+#  define LZO_OPT_PREFER_PREINC             1
+#  define LZO_OPT_PREFER_PREDEC             1
+#  if (LZO_ABI_BIG_ENDIAN)
+#    ifndef LZO_OPT_UNALIGNED16
+#    define LZO_OPT_UNALIGNED16             1
+#    endif
+#    ifndef LZO_OPT_UNALIGNED32
+#    define LZO_OPT_UNALIGNED32             1
+#    endif
+#    if (LZO_WORDSIZE == 8)
+#      ifndef LZO_OPT_UNALIGNED64
+#      define LZO_OPT_UNALIGNED64           1
+#      endif
+#    endif
 #  endif
 #elif (LZO_ARCH_S390)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#  if (LZO_SIZEOF_SIZE_T == 8)
-#    define LZO_OPT_UNALIGNED64     1
+#  ifndef LZO_OPT_UNALIGNED16
+#  define LZO_OPT_UNALIGNED16               1
+#  endif
+#  ifndef LZO_OPT_UNALIGNED32
+#  define LZO_OPT_UNALIGNED32               1
+#  endif
+#  if (LZO_WORDSIZE == 8)
+#    ifndef LZO_OPT_UNALIGNED64
+#    define LZO_OPT_UNALIGNED64             1
+#    endif
 #  endif
 #elif (LZO_ARCH_SH)
-#  define LZO_OPT_PREFER_POSTINC    1
-#  define LZO_OPT_PREFER_PREDEC     1
+#  define LZO_OPT_PREFER_POSTINC            1
+#  define LZO_OPT_PREFER_PREDEC             1
 #endif
-#if !defined(LZO_CFG_NO_INLINE_ASM)
-#if defined(LZO_CC_LLVM)
+#ifndef LZO_CFG_NO_INLINE_ASM
+#if (LZO_ABI_NEUTRAL_ENDIAN) || (LZO_ARCH_GENERIC)
+#  define LZO_CFG_NO_INLINE_ASM 1
+#elif (LZO_CC_LLVM)
 #  define LZO_CFG_NO_INLINE_ASM 1
 #endif
 #endif
-#if !defined(LZO_CFG_NO_UNALIGNED)
-#if defined(LZO_ABI_NEUTRAL_ENDIAN) || defined(LZO_ARCH_GENERIC)
+#if (LZO_CFG_NO_INLINE_ASM)
+#  undef LZO_ASM_SYNTAX_MSC
+#  undef LZO_ASM_SYNTAX_GNUC
+#  undef __LZO_ASM_CLOBBER
+#  undef __LZO_ASM_CLOBBER_LIST_CC
+#  undef __LZO_ASM_CLOBBER_LIST_CC_MEMORY
+#  undef __LZO_ASM_CLOBBER_LIST_EMPTY
+#endif
+#ifndef LZO_CFG_NO_UNALIGNED
+#if (LZO_ABI_NEUTRAL_ENDIAN) || (LZO_ARCH_GENERIC)
 #  define LZO_CFG_NO_UNALIGNED 1
 #endif
 #endif
-#if defined(LZO_CFG_NO_UNALIGNED)
+#if (LZO_CFG_NO_UNALIGNED)
 #  undef LZO_OPT_UNALIGNED16
 #  undef LZO_OPT_UNALIGNED32
 #  undef LZO_OPT_UNALIGNED64
 #endif
-#if defined(LZO_CFG_NO_INLINE_ASM)
-#elif (LZO_ARCH_I386 && (LZO_OS_DOS32 || LZO_OS_WIN32) && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
-#  define LZO_ASM_SYNTAX_MSC 1
-#elif (LZO_OS_WIN64 && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
-#elif (LZO_ARCH_I386 && (LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
-#  define LZO_ASM_SYNTAX_GNUC 1
-#elif (LZO_ARCH_AMD64 && (LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
-#  define LZO_ASM_SYNTAX_GNUC 1
-#endif
-#if (LZO_ASM_SYNTAX_GNUC)
-#if (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC < 0x020000ul))
-#  define __LZO_ASM_CLOBBER         "ax"
-#elif (LZO_CC_INTELC)
-#  define __LZO_ASM_CLOBBER         "memory"
-#else
-#  define __LZO_ASM_CLOBBER         "cc", "memory"
-#endif
-#endif
 #if defined(__LZO_INFOSTR_MM)
 #elif (LZO_MM_FLAT) && (defined(__LZO_INFOSTR_PM) || defined(LZO_INFO_ABI_PM))
 #  define __LZO_INFOSTR_MM          ""
@@ -1801,7 +2617,382 @@ extern "C" {
 #define LZO_INFO_STRING \
     LZO_INFO_ARCH __LZO_INFOSTR_MM __LZO_INFOSTR_PM __LZO_INFOSTR_ENDIAN \
     " " __LZO_INFOSTR_OSNAME __LZO_INFOSTR_LIBC " " LZO_INFO_CC __LZO_INFOSTR_CCVER
+#if !(LZO_CFG_SKIP_LZO_TYPES)
+#if (!(LZO_SIZEOF_SHORT+0 > 0 && LZO_SIZEOF_INT+0 > 0 && LZO_SIZEOF_LONG+0 > 0))
+#  error "missing defines for sizes"
+#endif
+#if (!(LZO_SIZEOF_PTRDIFF_T+0 > 0 && LZO_SIZEOF_SIZE_T+0 > 0 && LZO_SIZEOF_VOID_P+0 > 0))
+#  error "missing defines for sizes"
+#endif
+#if !defined(lzo_llong_t)
+#if (LZO_SIZEOF_LONG_LONG+0 > 0)
+__lzo_gnuc_extension__ typedef long long lzo_llong_t__;
+__lzo_gnuc_extension__ typedef unsigned long long lzo_ullong_t__;
+#  define lzo_llong_t               lzo_llong_t__
+#  define lzo_ullong_t              lzo_ullong_t__
+#endif
+#endif
+#if !defined(lzo_int16e_t)
+#if (LZO_SIZEOF_LONG == 2)
+#  define lzo_int16e_t              long
+#  define lzo_uint16e_t             unsigned long
+#elif (LZO_SIZEOF_INT == 2)
+#  define lzo_int16e_t              int
+#  define lzo_uint16e_t             unsigned int
+#elif (LZO_SIZEOF_SHORT == 2)
+#  define lzo_int16e_t              short int
+#  define lzo_uint16e_t             unsigned short int
+#elif 1 && !(LZO_CFG_TYPE_NO_MODE_HI) && (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x025f00ul) || LZO_CC_LLVM)
+   typedef int lzo_int16e_hi_t__ __attribute__((__mode__(__HI__)));
+   typedef unsigned int lzo_uint16e_hi_t__ __attribute__((__mode__(__HI__)));
+#  define lzo_int16e_t              lzo_int16e_hi_t__
+#  define lzo_uint16e_t             lzo_uint16e_hi_t__
+#elif (LZO_SIZEOF___INT16 == 2)
+#  define lzo_int16e_t              __int16
+#  define lzo_uint16e_t             unsigned __int16
+#else
+#endif
+#endif
+#if defined(lzo_int16e_t)
+#  define LZO_SIZEOF_LZO_INT16E_T   2
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16e_t) == 2)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16e_t) == LZO_SIZEOF_LZO_INT16E_T)
+#endif
+#if !defined(lzo_int32e_t)
+#if (LZO_SIZEOF_LONG == 4)
+#  define lzo_int32e_t              long int
+#  define lzo_uint32e_t             unsigned long int
+#elif (LZO_SIZEOF_INT == 4)
+#  define lzo_int32e_t              int
+#  define lzo_uint32e_t             unsigned int
+#elif (LZO_SIZEOF_SHORT == 4)
+#  define lzo_int32e_t              short int
+#  define lzo_uint32e_t             unsigned short int
+#elif (LZO_SIZEOF_LONG_LONG == 4)
+#  define lzo_int32e_t              lzo_llong_t
+#  define lzo_uint32e_t             lzo_ullong_t
+#elif 1 && !(LZO_CFG_TYPE_NO_MODE_SI) && (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x025f00ul) || LZO_CC_LLVM) && (__INT_MAX__+0 > 2147483647L)
+   typedef int lzo_int32e_si_t__ __attribute__((__mode__(__SI__)));
+   typedef unsigned int lzo_uint32e_si_t__ __attribute__((__mode__(__SI__)));
+#  define lzo_int32e_t              lzo_int32e_si_t__
+#  define lzo_uint32e_t             lzo_uint32e_si_t__
+#elif 1 && !(LZO_CFG_TYPE_NO_MODE_SI) && (LZO_CC_GNUC >= 0x025f00ul) && defined(__AVR__) && (__LONG_MAX__+0 == 32767L)
+   typedef int lzo_int32e_si_t__ __attribute__((__mode__(__SI__)));
+   typedef unsigned int lzo_uint32e_si_t__ __attribute__((__mode__(__SI__)));
+#  define lzo_int32e_t              lzo_int32e_si_t__
+#  define lzo_uint32e_t             lzo_uint32e_si_t__
+#  define LZO_INT32_C(c)            (c##LL)
+#  define LZO_UINT32_C(c)           (c##ULL)
+#elif (LZO_SIZEOF___INT32 == 4)
+#  define lzo_int32e_t              __int32
+#  define lzo_uint32e_t             unsigned __int32
+#else
+#endif
+#endif
+#if defined(lzo_int32e_t)
+#  define LZO_SIZEOF_LZO_INT32E_T   4
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32e_t) == 4)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32e_t) == LZO_SIZEOF_LZO_INT32E_T)
+#endif
+#if !defined(lzo_int64e_t)
+#if (LZO_SIZEOF___INT64 == 8)
+#  if (LZO_CC_BORLANDC) && !(LZO_CFG_TYPE_PREFER___INT64)
+#    define LZO_CFG_TYPE_PREFER___INT64 1
+#  endif
+#endif
+#if (LZO_SIZEOF_INT == 8) && (LZO_SIZEOF_INT < LZO_SIZEOF_LONG)
+#  define lzo_int64e_t              int
+#  define lzo_uint64e_t             unsigned int
+#  define LZO_SIZEOF_LZO_INT64E_T   LZO_SIZEOF_INT
+#elif (LZO_SIZEOF_LONG == 8)
+#  define lzo_int64e_t              long int
+#  define lzo_uint64e_t             unsigned long int
+#  define LZO_SIZEOF_LZO_INT64E_T   LZO_SIZEOF_LONG
+#elif (LZO_SIZEOF_LONG_LONG == 8) && !(LZO_CFG_TYPE_PREFER___INT64)
+#  define lzo_int64e_t              lzo_llong_t
+#  define lzo_uint64e_t             lzo_ullong_t
+#  if (LZO_CC_BORLANDC)
+#    define LZO_INT64_C(c)          ((c) + 0ll)
+#    define LZO_UINT64_C(c)         ((c) + 0ull)
+#  elif 0
+#    define LZO_INT64_C(c)          (__lzo_gnuc_extension__ (c##LL))
+#    define LZO_UINT64_C(c)         (__lzo_gnuc_extension__ (c##ULL))
+#  else
+#    define LZO_INT64_C(c)          (c##LL)
+#    define LZO_UINT64_C(c)         (c##ULL)
+#  endif
+#  define LZO_SIZEOF_LZO_INT64E_T   LZO_SIZEOF_LONG_LONG
+#elif (LZO_SIZEOF___INT64 == 8)
+#  define lzo_int64e_t              __int64
+#  define lzo_uint64e_t             unsigned __int64
+#  if (LZO_CC_BORLANDC)
+#    define LZO_INT64_C(c)          ((c) + 0i64)
+#    define LZO_UINT64_C(c)         ((c) + 0ui64)
+#  else
+#    define LZO_INT64_C(c)          (c##i64)
+#    define LZO_UINT64_C(c)         (c##ui64)
+#  endif
+#  define LZO_SIZEOF_LZO_INT64E_T   LZO_SIZEOF___INT64
+#else
+#endif
+#endif
+#if defined(lzo_int64e_t)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64e_t) == 8)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64e_t) == LZO_SIZEOF_LZO_INT64E_T)
+#endif
+#if !defined(lzo_int32l_t)
+#if defined(lzo_int32e_t)
+#  define lzo_int32l_t              lzo_int32e_t
+#  define lzo_uint32l_t             lzo_uint32e_t
+#  define LZO_SIZEOF_LZO_INT32L_T   LZO_SIZEOF_LZO_INT32E_T
+#elif (LZO_SIZEOF_INT >= 4) && (LZO_SIZEOF_INT < LZO_SIZEOF_LONG)
+#  define lzo_int32l_t              int
+#  define lzo_uint32l_t             unsigned int
+#  define LZO_SIZEOF_LZO_INT32L_T   LZO_SIZEOF_INT
+#elif (LZO_SIZEOF_LONG >= 4)
+#  define lzo_int32l_t              long int
+#  define lzo_uint32l_t             unsigned long int
+#  define LZO_SIZEOF_LZO_INT32L_T   LZO_SIZEOF_LONG
+#else
+#  error "lzo_int32l_t"
+#endif
+#endif
+#if 1
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32l_t) >= 4)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32l_t) == LZO_SIZEOF_LZO_INT32L_T)
+#endif
+#if !defined(lzo_int64l_t)
+#if defined(lzo_int64e_t)
+#  define lzo_int64l_t              lzo_int64e_t
+#  define lzo_uint64l_t             lzo_uint64e_t
+#  define LZO_SIZEOF_LZO_INT64L_T   LZO_SIZEOF_LZO_INT64E_T
+#else
+#endif
+#endif
+#if defined(lzo_int64l_t)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64l_t) >= 8)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64l_t) == LZO_SIZEOF_LZO_INT64L_T)
+#endif
+#if !defined(lzo_int32f_t)
+#if (LZO_SIZEOF_SIZE_T >= 8)
+#  define lzo_int32f_t              lzo_int64l_t
+#  define lzo_uint32f_t             lzo_uint64l_t
+#  define LZO_SIZEOF_LZO_INT32F_T   LZO_SIZEOF_LZO_INT64L_T
+#else
+#  define lzo_int32f_t              lzo_int32l_t
+#  define lzo_uint32f_t             lzo_uint32l_t
+#  define LZO_SIZEOF_LZO_INT32F_T   LZO_SIZEOF_LZO_INT32L_T
+#endif
+#endif
+#if 1
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32f_t) >= 4)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32f_t) == LZO_SIZEOF_LZO_INT32F_T)
+#endif
+#if !defined(lzo_int64f_t)
+#if defined(lzo_int64l_t)
+#  define lzo_int64f_t              lzo_int64l_t
+#  define lzo_uint64f_t             lzo_uint64l_t
+#  define LZO_SIZEOF_LZO_INT64F_T   LZO_SIZEOF_LZO_INT64L_T
+#else
+#endif
+#endif
+#if defined(lzo_int64f_t)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64f_t) >= 8)
+   LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64f_t) == LZO_SIZEOF_LZO_INT64F_T)
+#endif
+#if !defined(lzo_intptr_t)
+#if 1 && (LZO_OS_OS400 && (LZO_SIZEOF_VOID_P == 16))
+#  define __LZO_INTPTR_T_IS_POINTER 1
+   typedef char*                    lzo_intptr_t;
+   typedef char*                    lzo_uintptr_t;
+#  define lzo_intptr_t              lzo_intptr_t
+#  define lzo_uintptr_t             lzo_uintptr_t
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_VOID_P
+#elif (LZO_CC_MSC && (_MSC_VER >= 1300) && (LZO_SIZEOF_VOID_P == 4) && (LZO_SIZEOF_INT == 4))
+   typedef __w64 int                lzo_intptr_t;
+   typedef __w64 unsigned int       lzo_uintptr_t;
+#  define lzo_intptr_t              lzo_intptr_t
+#  define lzo_uintptr_t             lzo_uintptr_t
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_INT
+#elif (LZO_SIZEOF_SHORT == LZO_SIZEOF_VOID_P) && (LZO_SIZEOF_INT > LZO_SIZEOF_VOID_P)
+#  define lzo_intptr_t              short
+#  define lzo_uintptr_t             unsigned short
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_SHORT
+#elif (LZO_SIZEOF_INT >= LZO_SIZEOF_VOID_P) && (LZO_SIZEOF_INT < LZO_SIZEOF_LONG)
+#  define lzo_intptr_t              int
+#  define lzo_uintptr_t             unsigned int
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_INT
+#elif (LZO_SIZEOF_LONG >= LZO_SIZEOF_VOID_P)
+#  define lzo_intptr_t              long
+#  define lzo_uintptr_t             unsigned long
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_LONG
+#elif (LZO_SIZEOF_LZO_INT64L_T >= LZO_SIZEOF_VOID_P)
+#  define lzo_intptr_t              lzo_int64l_t
+#  define lzo_uintptr_t             lzo_uint64l_t
+#  define LZO_SIZEOF_LZO_INTPTR_T   LZO_SIZEOF_LZO_INT64L_T
+#else
+#  error "lzo_intptr_t"
+#endif
+#endif
+#if 1
+    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_intptr_t) >= sizeof(void *))
+    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_intptr_t) == sizeof(lzo_uintptr_t))
+#endif
+#if !defined(lzo_word_t)
+#if defined(LZO_WORDSIZE) && (LZO_WORDSIZE+0 > 0)
+#if (LZO_WORDSIZE == LZO_SIZEOF_LZO_INTPTR_T) && !(__LZO_INTPTR_T_IS_POINTER)
+#  define lzo_word_t                lzo_uintptr_t
+#  define lzo_sword_t               lzo_intptr_t
+#  define LZO_SIZEOF_LZO_WORD_T LZO_SIZEOF_LZO_INTPTR_T
+#elif (LZO_WORDSIZE == LZO_SIZEOF_LONG)
+#  define lzo_word_t                unsigned long
+#  define lzo_sword_t               long
+#  define LZO_SIZEOF_LZO_WORD_T LZO_SIZEOF_LONG
+#elif (LZO_WORDSIZE == LZO_SIZEOF_INT)
+#  define lzo_word_t                unsigned int
+#  define lzo_sword_t               int
+#  define LZO_SIZEOF_LZO_WORD_T LZO_SIZEOF_INT
+#elif (LZO_WORDSIZE == LZO_SIZEOF_SHORT)
+#  define lzo_word_t                unsigned short
+#  define lzo_sword_t               short
+#  define LZO_SIZEOF_LZO_WORD_T LZO_SIZEOF_SHORT
+#elif (LZO_WORDSIZE == 1)
+#  define lzo_word_t                unsigned char
+#  define lzo_sword_t               signed char
+#  define LZO_SIZEOF_LZO_WORD_T 1
+#elif (LZO_WORDSIZE == LZO_SIZEOF_LZO_INT64L_T)
+#  define lzo_word_t                lzo_uint64l_t
+#  define lzo_sword_t               lzo_int64l_t
+#  define LZO_SIZEOF_LZO_WORD_T LZO_SIZEOF_LZO_INT64L_T
+#elif (LZO_ARCH_SPU) && (LZO_CC_GNUC)
+#if 0
+   typedef unsigned lzo_word_t  __attribute__((__mode__(__V16QI__)));
+   typedef int      lzo_sword_t __attribute__((__mode__(__V16QI__)));
+#  define lzo_word_t                lzo_word_t
+#  define lzo_sword_t               lzo_sword_t
+#  define LZO_SIZEOF_LZO_WORD_T     16
+#endif
+#else
+#  error "lzo_word_t"
+#endif
+#endif
+#endif
+#if 1 && defined(lzo_word_t)
+    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_word_t)  == LZO_WORDSIZE)
+    LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_sword_t) == LZO_WORDSIZE)
+#endif
+#if 1
+#define lzo_int8_t                  signed char
+#define lzo_uint8_t                 unsigned char
+#define LZO_SIZEOF_LZO_INT8_T       1
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int8_t) == 1)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int8_t) == sizeof(lzo_uint8_t))
+#endif
+#if defined(lzo_int16e_t)
+#define lzo_int16_t                 lzo_int16e_t
+#define lzo_uint16_t                lzo_uint16e_t
+#define LZO_SIZEOF_LZO_INT16_T      LZO_SIZEOF_LZO_INT16E_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16_t) == 2)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16_t) == sizeof(lzo_uint16_t))
+#endif
+#if defined(lzo_int32e_t)
+#define lzo_int32_t                 lzo_int32e_t
+#define lzo_uint32_t                lzo_uint32e_t
+#define LZO_SIZEOF_LZO_INT32_T      LZO_SIZEOF_LZO_INT32E_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32_t) == 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32_t) == sizeof(lzo_uint32_t))
+#endif
+#if defined(lzo_int64e_t)
+#define lzo_int64_t                 lzo_int64e_t
+#define lzo_uint64_t                lzo_uint64e_t
+#define LZO_SIZEOF_LZO_INT64_T      LZO_SIZEOF_LZO_INT64E_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64_t) == 8)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64_t) == sizeof(lzo_uint64_t))
+#endif
+#if 1
+#define lzo_int_least32_t           lzo_int32l_t
+#define lzo_uint_least32_t          lzo_uint32l_t
+#define LZO_SIZEOF_LZO_INT_LEAST32_T LZO_SIZEOF_LZO_INT32L_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least32_t) >= 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least32_t) == sizeof(lzo_uint_least32_t))
+#endif
+#if defined(lzo_int64l_t)
+#define lzo_int_least64_t           lzo_int64l_t
+#define lzo_uint_least64_t          lzo_uint64l_t
+#define LZO_SIZEOF_LZO_INT_LEAST64_T LZO_SIZEOF_LZO_INT64L_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least64_t) >= 8)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_least64_t) == sizeof(lzo_uint_least64_t))
+#endif
+#if 1
+#define lzo_int_fast32_t           lzo_int32f_t
+#define lzo_uint_fast32_t          lzo_uint32f_t
+#define LZO_SIZEOF_LZO_INT_FAST32_T LZO_SIZEOF_LZO_INT32F_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast32_t) >= 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast32_t) == sizeof(lzo_uint_fast32_t))
+#endif
+#if defined(lzo_int64f_t)
+#define lzo_int_fast64_t           lzo_int64f_t
+#define lzo_uint_fast64_t          lzo_uint64f_t
+#define LZO_SIZEOF_LZO_INT_FAST64_T LZO_SIZEOF_LZO_INT64F_T
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast64_t) >= 8)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int_fast64_t) == sizeof(lzo_uint_fast64_t))
+#endif
+#if !defined(LZO_INT16_C)
+#  if (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_INT >= 2)
+#    define LZO_INT16_C(c)          ((c) + 0)
+#    define LZO_UINT16_C(c)         ((c) + 0U)
+#  elif (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_LONG >= 2)
+#    define LZO_INT16_C(c)          ((c) + 0L)
+#    define LZO_UINT16_C(c)         ((c) + 0UL)
+#  elif (LZO_SIZEOF_INT >= 2)
+#    define LZO_INT16_C(c)          (c)
+#    define LZO_UINT16_C(c)         (c##U)
+#  elif (LZO_SIZEOF_LONG >= 2)
+#    define LZO_INT16_C(c)          (c##L)
+#    define LZO_UINT16_C(c)         (c##UL)
+#  else
+#    error "LZO_INT16_C"
+#  endif
+#endif
+#if !defined(LZO_INT32_C)
+#  if (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_INT >= 4)
+#    define LZO_INT32_C(c)          ((c) + 0)
+#    define LZO_UINT32_C(c)         ((c) + 0U)
+#  elif (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_LONG >= 4)
+#    define LZO_INT32_C(c)          ((c) + 0L)
+#    define LZO_UINT32_C(c)         ((c) + 0UL)
+#  elif (LZO_SIZEOF_INT >= 4)
+#    define LZO_INT32_C(c)          (c)
+#    define LZO_UINT32_C(c)         (c##U)
+#  elif (LZO_SIZEOF_LONG >= 4)
+#    define LZO_INT32_C(c)          (c##L)
+#    define LZO_UINT32_C(c)         (c##UL)
+#  elif (LZO_SIZEOF_LONG_LONG >= 4)
+#    define LZO_INT32_C(c)          (c##LL)
+#    define LZO_UINT32_C(c)         (c##ULL)
+#  else
+#    error "LZO_INT32_C"
+#  endif
+#endif
+#if !defined(LZO_INT64_C) && defined(lzo_int64l_t)
+#  if (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_INT >= 8)
+#    define LZO_INT64_C(c)          ((c) + 0)
+#    define LZO_UINT64_C(c)         ((c) + 0U)
+#  elif (LZO_BROKEN_INTEGRAL_CONSTANTS) && (LZO_SIZEOF_LONG >= 8)
+#    define LZO_INT64_C(c)          ((c) + 0L)
+#    define LZO_UINT64_C(c)         ((c) + 0UL)
+#  elif (LZO_SIZEOF_INT >= 8)
+#    define LZO_INT64_C(c)          (c)
+#    define LZO_UINT64_C(c)         (c##U)
+#  elif (LZO_SIZEOF_LONG >= 8)
+#    define LZO_INT64_C(c)          (c##L)
+#    define LZO_UINT64_C(c)         (c##UL)
+#  else
+#    error "LZO_INT64_C"
+#  endif
+#endif
+#endif
 
 #endif /* already included */
 
-/* vim:set ts=4 et: */
+/* vim:set ts=4 sw=4 et: */
diff -uprN -X dontdiff Syslinux-4.07a/lzo/include/lzo/lzoutil.h syslinux-4.07b/lzo/include/lzo/lzoutil.h
--- Syslinux-4.07a/lzo/include/lzo/lzoutil.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/include/lzo/lzoutil.h	2023-02-08 12:45:25.599552219 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -39,7 +27,7 @@
 
 
 #ifndef __LZOUTIL_H_INCLUDED
-#define __LZOUTIL_H_INCLUDED
+#define __LZOUTIL_H_INCLUDED 1
 
 #ifndef __LZOCONF_H_INCLUDED
 #include "lzoconf.h"
diff -uprN -X dontdiff Syslinux-4.07a/lzo/prepcore.c syslinux-4.07b/lzo/prepcore.c
--- Syslinux-4.07a/lzo/prepcore.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/prepcore.c	2023-02-08 12:45:49.119689626 +0100
@@ -331,7 +331,7 @@ int main(int argc, char *argv[])
 	unsigned int ptr;
 	outfile_len =
 	    ((offset - start + out_len + 2047) & ~2047) - (offset - start);
-	for (ptr = 64; ptr < offset; ptr += 4)
+	for (ptr = start + 64; ptr < offset; ptr += 4)
 	    csum += get_32((uint32_t *) (infile + ptr));
 	for (ptr = 0; ptr < outfile_len; ptr += 4)
 	    csum += get_32((uint32_t *) (out + ptr));
@@ -340,10 +340,12 @@ int main(int argc, char *argv[])
 	set_32((uint32_t *) (infile + soff + 4), csum);
     }
 
+	/*
     if (offset+outfile_len > get_32(&prefix->pfx_maxlma))
 	error("output too big (%lu, max %lu)",
 	      (unsigned long)offset+outfile_len,
 	      (unsigned long)get_32(&prefix->pfx_maxlma));
+	      */
 
     f = fopen(out_name, "wb");
     if (!f)
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/compr1b.h syslinux-4.07b/lzo/src/compr1b.h
--- Syslinux-4.07a/lzo/src/compr1b.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/compr1b.h	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -38,12 +26,12 @@
  */
 
 
-#define LZO_NEED_DICT_H
+#define LZO_NEED_DICT_H 1
 #include "config1b.h"
 
 
 #if !defined(COMPRESS_ID)
-#define COMPRESS_ID     LZO_CPP_ECONCAT2(DD_BITS,CLEVEL)
+#define COMPRESS_ID     LZO_PP_ECONCAT2(DD_BITS,CLEVEL)
 #endif
 
 
@@ -55,10 +43,10 @@
 ************************************************************************/
 
 #define LZO_COMPRESS \
-    LZO_CPP_ECONCAT3(lzo1b_,COMPRESS_ID,_compress)
+    LZO_PP_ECONCAT3(lzo1b_,COMPRESS_ID,_compress)
 
 #define LZO_COMPRESS_FUNC \
-    LZO_CPP_ECONCAT3(_lzo1b_,COMPRESS_ID,_compress_func)
+    LZO_PP_ECONCAT3(_lzo1b_,COMPRESS_ID,_compress_func)
 
 
 
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/compr1c.h syslinux-4.07b/lzo/src/compr1c.h
--- Syslinux-4.07a/lzo/src/compr1c.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/compr1c.h	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -38,12 +26,12 @@
  */
 
 
-#define LZO_NEED_DICT_H
+#define LZO_NEED_DICT_H 1
 #include "config1c.h"
 
 
 #if !defined(COMPRESS_ID)
-#define COMPRESS_ID     LZO_CPP_ECONCAT2(DD_BITS,CLEVEL)
+#define COMPRESS_ID     LZO_PP_ECONCAT2(DD_BITS,CLEVEL)
 #endif
 
 
@@ -55,10 +43,10 @@
 ************************************************************************/
 
 #define LZO_COMPRESS \
-    LZO_CPP_ECONCAT3(lzo1c_,COMPRESS_ID,_compress)
+    LZO_PP_ECONCAT3(lzo1c_,COMPRESS_ID,_compress)
 
 #define LZO_COMPRESS_FUNC \
-    LZO_CPP_ECONCAT3(_lzo1c_,COMPRESS_ID,_compress_func)
+    LZO_PP_ECONCAT3(_lzo1c_,COMPRESS_ID,_compress_func)
 
 
 
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/config1x.h syslinux-4.07b/lzo/src/config1x.h
--- Syslinux-4.07a/lzo/src/config1x.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/config1x.h	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -45,10 +33,10 @@
 
 
 #ifndef __LZO_CONFIG1X_H
-#define __LZO_CONFIG1X_H
+#define __LZO_CONFIG1X_H 1
 
 #if !defined(LZO1X) && !defined(LZO1Y) && !defined(LZO1Z)
-#  define LZO1X
+#  define LZO1X 1
 #endif
 
 #include "lzo_conf.h"
@@ -61,7 +49,9 @@
 //
 ************************************************************************/
 
-#define LZO_EOF_CODE
+#ifndef LZO_EOF_CODE
+#define LZO_EOF_CODE 1
+#endif
 #undef LZO_DETERMINISTIC
 
 #define M1_MAX_OFFSET   0x0400
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo1_d.ch syslinux-4.07b/lzo/src/lzo1_d.ch
--- Syslinux-4.07a/lzo/src/lzo1_d.ch	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo1_d.ch	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -47,7 +35,7 @@
 #    define LZO_TEST_OVERRUN_OUTPUT      2
 #  endif
 #  if !defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-#    define LZO_TEST_OVERRUN_LOOKBEHIND
+#    define LZO_TEST_OVERRUN_LOOKBEHIND  1
 #  endif
 #endif
 
@@ -61,7 +49,7 @@
 //   TEST_OP    test output overrun at loop begin
 //   NEED_OP    test output overrun at every output byte
 //
-//   TEST_LB    test match postion
+//   TEST_LB    test match position
 //
 // The fastest decompressor results when testing for no overruns
 // and using LZO_EOF_CODE.
@@ -69,10 +57,13 @@
 
 #undef TEST_IP
 #undef TEST_OP
+#undef TEST_IP_AND_TEST_OP
 #undef TEST_LB
 #undef TEST_LBO
 #undef NEED_IP
 #undef NEED_OP
+#undef TEST_IV
+#undef TEST_OV
 #undef HAVE_TEST_IP
 #undef HAVE_TEST_OP
 #undef HAVE_NEED_IP
@@ -88,6 +79,7 @@
 #  if (LZO_TEST_OVERRUN_INPUT >= 2)
 #    define NEED_IP(x) \
             if ((lzo_uint)(ip_end - ip) < (lzo_uint)(x))  goto input_overrun
+#    define TEST_IV(x)          if ((x) >  (lzo_uint)0 - (511)) goto input_overrun
 #  endif
 #endif
 
@@ -99,12 +91,13 @@
 #    undef TEST_OP              /* don't need both of the tests here */
 #    define NEED_OP(x) \
             if ((lzo_uint)(op_end - op) < (lzo_uint)(x))  goto output_overrun
+#    define TEST_OV(x)          if ((x) >  (lzo_uint)0 - (511)) goto output_overrun
 #  endif
 #endif
 
 #if defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-#  define TEST_LB(m_pos)        if (m_pos < out || m_pos >= op) goto lookbehind_overrun
-#  define TEST_LBO(m_pos,o)     if (m_pos < out || m_pos >= op - (o)) goto lookbehind_overrun
+#  define TEST_LB(m_pos)        if (PTR_LT(m_pos,out) || PTR_GE(m_pos,op)) goto lookbehind_overrun
+#  define TEST_LBO(m_pos,o)     if (PTR_LT(m_pos,out) || PTR_GE(m_pos,op-(o))) goto lookbehind_overrun
 #else
 #  define TEST_LB(m_pos)        ((void) 0)
 #  define TEST_LBO(m_pos,o)     ((void) 0)
@@ -118,33 +111,45 @@
 
 
 #if defined(TEST_IP)
-#  define HAVE_TEST_IP
+#  define HAVE_TEST_IP 1
 #else
 #  define TEST_IP               1
 #endif
 #if defined(TEST_OP)
-#  define HAVE_TEST_OP
+#  define HAVE_TEST_OP 1
 #else
 #  define TEST_OP               1
 #endif
 
+#if defined(HAVE_TEST_IP) && defined(HAVE_TEST_OP)
+#  define TEST_IP_AND_TEST_OP   (TEST_IP && TEST_OP)
+#elif defined(HAVE_TEST_IP)
+#  define TEST_IP_AND_TEST_OP   TEST_IP
+#elif defined(HAVE_TEST_OP)
+#  define TEST_IP_AND_TEST_OP   TEST_OP
+#else
+#  define TEST_IP_AND_TEST_OP   1
+#endif
+
 #if defined(NEED_IP)
-#  define HAVE_NEED_IP
+#  define HAVE_NEED_IP 1
 #else
 #  define NEED_IP(x)            ((void) 0)
+#  define TEST_IV(x)            ((void) 0)
 #endif
 #if defined(NEED_OP)
-#  define HAVE_NEED_OP
+#  define HAVE_NEED_OP 1
 #else
 #  define NEED_OP(x)            ((void) 0)
+#  define TEST_OV(x)            ((void) 0)
 #endif
 
 
 #if defined(HAVE_TEST_IP) || defined(HAVE_NEED_IP)
-#  define HAVE_ANY_IP
+#  define HAVE_ANY_IP 1
 #endif
 #if defined(HAVE_TEST_OP) || defined(HAVE_NEED_OP)
-#  define HAVE_ANY_OP
+#  define HAVE_ANY_OP 1
 #endif
 
 
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo1x_1.c syslinux-4.07b/lzo/src/lzo1x_1.c
--- Syslinux-4.07a/lzo/src/lzo1x_1.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo1x_1.c	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -38,13 +26,30 @@
  */
 
 
-#define LZO_NEED_DICT_H
+#include "lzo_conf.h"
+#if 1 && defined(UA_GET_LE32)
+#undef  LZO_DICT_USE_PTR
+#define LZO_DICT_USE_PTR 0
+#undef  lzo_dict_t
+#define lzo_dict_t lzo_uint16_t
+#endif
+
+#define LZO_NEED_DICT_H 1
+#ifndef D_BITS
 #define D_BITS          14
+#endif
 #define D_INDEX1(d,p)       d = DM(DMUL(0x21,DX3(p,5,5,6)) >> 5)
 #define D_INDEX2(d,p)       d = (d & (D_MASK & 0x7ff)) ^ (D_HIGH | 0x1f)
-
+#if 1
+#define DINDEX(dv,p)        DM(((DMUL(0x1824429d,dv)) >> (32-D_BITS)))
+#else
+#define DINDEX(dv,p)        DM((dv) + ((dv) >> (32-D_BITS)))
+#endif
 #include "config1x.h"
+#define LZO_DETERMINISTIC !(LZO_DICT_USE_PTR)
 
+#ifndef DO_COMPRESS
 #define DO_COMPRESS     lzo1x_1_compress
+#endif
 
 #include "lzo1x_c.ch"
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo1x_1k.c syslinux-4.07b/lzo/src/lzo1x_1k.c
--- Syslinux-4.07a/lzo/src/lzo1x_1k.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo1x_1k.c	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -38,13 +26,30 @@
  */
 
 
-#define LZO_NEED_DICT_H
+#include "lzo_conf.h"
+#if 1 && defined(UA_GET_LE32)
+#undef  LZO_DICT_USE_PTR
+#define LZO_DICT_USE_PTR 0
+#undef  lzo_dict_t
+#define lzo_dict_t lzo_uint16_t
+#endif
+
+#define LZO_NEED_DICT_H 1
+#ifndef D_BITS
 #define D_BITS          11
+#endif
 #define D_INDEX1(d,p)       d = DM(DMUL(0x21,DX2(p,3,5)) >> 5)
 #define D_INDEX2(d,p)       d = d ^ D_MASK
-
+#if 1
+#define DINDEX(dv,p)        DM(((DMUL(0x1824429d,dv)) >> (32-D_BITS)))
+#else
+#define DINDEX(dv,p)        DM((dv) + ((dv) >> (32-D_BITS)))
+#endif
 #include "config1x.h"
+#define LZO_DETERMINISTIC !(LZO_DICT_USE_PTR)
 
+#ifndef DO_COMPRESS
 #define DO_COMPRESS     lzo1x_1_11_compress
+#endif
 
 #include "lzo1x_c.ch"
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo1x_1l.c syslinux-4.07b/lzo/src/lzo1x_1l.c
--- Syslinux-4.07a/lzo/src/lzo1x_1l.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo1x_1l.c	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -38,13 +26,30 @@
  */
 
 
-#define LZO_NEED_DICT_H
+#include "lzo_conf.h"
+#if 1 && defined(UA_GET_LE32)
+#undef  LZO_DICT_USE_PTR
+#define LZO_DICT_USE_PTR 0
+#undef  lzo_dict_t
+#define lzo_dict_t lzo_uint16_t
+#endif
+
+#define LZO_NEED_DICT_H 1
+#ifndef D_BITS
 #define D_BITS          12
+#endif
 #define D_INDEX1(d,p)       d = DM(DMUL(0x21,DX2(p,4,5)) >> 5)
 #define D_INDEX2(d,p)       d = d ^ D_MASK
-
+#if 1
+#define DINDEX(dv,p)        DM(((DMUL(0x1824429d,dv)) >> (32-D_BITS)))
+#else
+#define DINDEX(dv,p)        DM((dv) + ((dv) >> (32-D_BITS)))
+#endif
 #include "config1x.h"
+#define LZO_DETERMINISTIC !(LZO_DICT_USE_PTR)
 
+#ifndef DO_COMPRESS
 #define DO_COMPRESS     lzo1x_1_12_compress
+#endif
 
 #include "lzo1x_c.ch"
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo1x_1o.c syslinux-4.07b/lzo/src/lzo1x_1o.c
--- Syslinux-4.07a/lzo/src/lzo1x_1o.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo1x_1o.c	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -38,13 +26,31 @@
  */
 
 
-#define LZO_NEED_DICT_H
+#include "lzo_conf.h"
+#if 1 && defined(UA_GET_LE32)
+#undef  LZO_DICT_USE_PTR
+#define LZO_DICT_USE_PTR 0
+#undef  lzo_dict_t
+#define lzo_dict_t lzo_uint16_t
+#define D_BITS 13
+#endif
+
+#define LZO_NEED_DICT_H 1
+#ifndef D_BITS
 #define D_BITS          15
+#endif
 #define D_INDEX1(d,p)       d = DM(DMUL(0x21,DX3(p,5,5,6)) >> 5)
 #define D_INDEX2(d,p)       d = (d & (D_MASK & 0x7ff)) ^ (D_HIGH | 0x1f)
-
+#if 1
+#define DINDEX(dv,p)        DM(((DMUL(0x1824429d,dv)) >> (32-D_BITS)))
+#else
+#define DINDEX(dv,p)        DM((dv) + ((dv) >> (32-D_BITS)))
+#endif
 #include "config1x.h"
+#define LZO_DETERMINISTIC !(LZO_DICT_USE_PTR)
 
+#ifndef DO_COMPRESS
 #define DO_COMPRESS     lzo1x_1_15_compress
+#endif
 
 #include "lzo1x_c.ch"
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo1x_9x.c syslinux-4.07b/lzo/src/lzo1x_9x.c
--- Syslinux-4.07a/lzo/src/lzo1x_9x.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo1x_9x.c	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -39,7 +27,7 @@
 
 
 #if !defined(LZO1X) && !defined(LZO1Y) && !defined(LZO1Z)
-#  define LZO1X
+#  define LZO1X 1
 #endif
 
 #if defined(LZO1X)
@@ -57,9 +45,9 @@
 //
 ************************************************************************/
 
-#define N           M4_MAX_OFFSET   /* size of ring buffer */
-#define THRESHOLD       1           /* lower limit for match length */
-#define F            2048           /* upper limit for match length */
+#define SWD_N           M4_MAX_OFFSET   /* size of ring buffer */
+#define SWD_THRESHOLD       1           /* lower limit for match length */
+#define SWD_F            2048           /* upper limit for match length */
 
 #define SWD_BEST_OFF    (LZO_MAX3( M2_MAX_LEN, M3_MAX_LEN, M4_MAX_LEN ) + 1)
 
@@ -88,9 +76,9 @@
 #  define HEAD3(b,p) \
     ((((((lzo_xint)b[p]<<3)^b[p+1])<<3)^b[p+2]) & (SWD_HSIZE-1))
 #endif
-#if 0 && defined(LZO_UNALIGNED_OK_4) && defined(LZO_ABI_LITTLE_ENDIAN)
+#if 0 && (LZO_OPT_UNALIGNED32) && (LZO_ABI_LITTLE_ENDIAN)
 #  define HEAD3(b,p) \
-    (((* (lzo_uint32p) &b[p]) ^ ((* (lzo_uint32p) &b[p])>>10)) & (SWD_HSIZE-1))
+    (((* (lzo_uint32_tp) &b[p]) ^ ((* (lzo_uint32_tp) &b[p])>>10)) & (SWD_HSIZE-1))
 #endif
 
 #include "lzo_mchw.ch"
@@ -103,12 +91,12 @@ lzo1x_999_compress_internal ( const lzo_
                                     lzo_voidp wrkmem,
                               const lzo_bytep dict, lzo_uint dict_len,
                                     lzo_callback_p cb,
-                                    int try_lazy,
+                                    int try_lazy_parm,
                                     lzo_uint good_length,
                                     lzo_uint max_lazy,
                                     lzo_uint nice_length,
                                     lzo_uint max_chain,
-                                    lzo_uint32 flags );
+                                    lzo_uint32_t flags );
 
 
 /***********************************************************************
@@ -127,8 +115,8 @@ code_match ( LZO_COMPRESS_T *c, lzo_byte
 /*
     static lzo_uint last_m_len = 0, last_m_off = 0;
     static lzo_uint prev_m_off[4];
-    static int prev_m_off_ptr = 0;
-    int i;
+    static unsigned prev_m_off_ptr = 0;
+    unsigned i;
 
     //if (m_len >= 3 && m_len <= M2_MAX_LEN && m_off <= M2_MAX_OFFSET)
     if (m_len >= 3 && m_len <= M2_MAX_LEN)
@@ -142,7 +130,7 @@ code_match ( LZO_COMPRESS_T *c, lzo_byte
     {
         for (i = 0; i < 4; i++)
             if (m_off == prev_m_off[i])
-                printf("prev_m_off %d: %5ld\n",i,(long)m_off);
+                printf("prev_m_off %u: %5ld\n",i,(long)m_off);
     }
     }
     last_m_len = m_len;
@@ -286,9 +274,9 @@ STORE_RUN ( LZO_COMPRESS_T *c, lzo_bytep
     else if (t <= 3)
     {
 #if defined(LZO1Z)
-        op[-1] |= LZO_BYTE(t);
+        op[-1] = LZO_BYTE(op[-1] | t);
 #else
-        op[-2] |= LZO_BYTE(t);
+        op[-2] = LZO_BYTE(op[-2] | t);
 #endif
         c->lit1_r++;
     }
@@ -343,15 +331,15 @@ code_run ( LZO_COMPRESS_T *c, lzo_bytep
 //
 ************************************************************************/
 
-static int
+static lzo_uint
 len_of_coded_match ( lzo_uint m_len, lzo_uint m_off, lzo_uint lit )
 {
-    int n = 4;
+    lzo_uint n = 4;
 
     if (m_len < 2)
-        return -1;
+        return 0;
     if (m_len == 2)
-        return (m_off <= M1_MAX_OFFSET && lit > 0 && lit < 4) ? 2 : -1;
+        return (m_off <= M1_MAX_OFFSET && lit > 0 && lit < 4) ? 2 : 0;
     if (m_len <= M2_MAX_LEN && m_off <= M2_MAX_OFFSET)
         return 2;
     if (m_len == M2_MIN_LEN && m_off <= MX_MAX_OFFSET && lit >= 4)
@@ -380,20 +368,20 @@ len_of_coded_match ( lzo_uint m_len, lzo
         }
         return n;
     }
-    return -1;
+    return 0;
 }
 
 
-static lzo_int
-min_gain(lzo_uint ahead, lzo_uint lit1, lzo_uint lit2, int l1, int l2, int l3)
+static lzo_uint
+min_gain(lzo_uint ahead, lzo_uint lit1, lzo_uint lit2, lzo_uint l1, lzo_uint l2, lzo_uint l3)
 {
-    lzo_int lazy_match_min_gain = 0;
+    lzo_uint lazy_match_min_gain;
 
     assert (ahead >= 1);
-    lazy_match_min_gain += ahead;
+    lazy_match_min_gain = ahead;
 
 #if 0
-    if (l3 > 0)
+    if (l3)
         lit2 -= ahead;
 #endif
 
@@ -403,10 +391,10 @@ min_gain(lzo_uint ahead, lzo_uint lit1,
         lazy_match_min_gain += (lit2 <= 18) ? 0 : 1;
 
     lazy_match_min_gain += (l2 - l1) * 2;
-    if (l3 > 0)
+    if (l3)
         lazy_match_min_gain -= (ahead - l3) * 2;
 
-    if (lazy_match_min_gain < 0)
+    if ((lzo_int) lazy_match_min_gain < 0)
         lazy_match_min_gain = 0;
 
 #if 0
@@ -535,12 +523,12 @@ lzo1x_999_compress_internal ( const lzo_
                                     lzo_voidp wrkmem,
                               const lzo_bytep dict, lzo_uint dict_len,
                                     lzo_callback_p cb,
-                                    int try_lazy,
+                                    int try_lazy_parm,
                                     lzo_uint good_length,
                                     lzo_uint max_lazy,
                                     lzo_uint nice_length,
                                     lzo_uint max_chain,
-                                    lzo_uint32 flags )
+                                    lzo_uint32_t flags )
 {
     lzo_bytep op;
     const lzo_bytep ii;
@@ -549,6 +537,7 @@ lzo1x_999_compress_internal ( const lzo_
     LZO_COMPRESS_T cc;
     LZO_COMPRESS_T * const c = &cc;
     lzo_swd_p const swd = (lzo_swd_p) wrkmem;
+    lzo_uint try_lazy;
     int r;
 
     /* sanity check */
@@ -564,19 +553,20 @@ lzo1x_999_compress_internal ( const lzo_
 
 /* setup parameter defaults */
     /* number of lazy match tries */
-    if (try_lazy < 0)
+    try_lazy = (lzo_uint) try_lazy_parm;
+    if (try_lazy_parm < 0)
         try_lazy = 1;
     /* reduce lazy match search if we already have a match with this length */
-    if (good_length <= 0)
+    if (good_length == 0)
         good_length = 32;
     /* do not try a lazy match if we already have a match with this length */
-    if (max_lazy <= 0)
+    if (max_lazy == 0)
         max_lazy = 32;
     /* stop searching for longer matches than this one */
-    if (nice_length <= 0)
+    if (nice_length == 0)
         nice_length = 0;
     /* don't search more positions than this */
-    if (max_chain <= 0)
+    if (max_chain == 0)
         max_chain = SWD_MAX_CHAIN;
 
     c->init = 0;
@@ -607,7 +597,7 @@ lzo1x_999_compress_internal ( const lzo_
     {
         lzo_uint ahead;
         lzo_uint max_ahead;
-        int l1, l2, l3;
+        lzo_uint l1, l2, l3;
 
         c->codesize = pd(op, out);
 
@@ -648,7 +638,7 @@ lzo1x_999_compress_internal ( const lzo_
             lit++;
             swd->max_chain = max_chain;
             r = find_match(c,swd,1,0);
-            assert(r == 0);
+            assert(r == 0); LZO_UNUSED(r);
             continue;
         }
 
@@ -660,10 +650,9 @@ lzo1x_999_compress_internal ( const lzo_
         assert_match(swd,m_len,m_off);
 
 
-
         /* shall we try a lazy match ? */
         ahead = 0;
-        if (try_lazy <= 0 || m_len >= max_lazy)
+        if (try_lazy == 0 || m_len >= max_lazy)
         {
             /* no */
             l1 = 0;
@@ -675,7 +664,7 @@ lzo1x_999_compress_internal ( const lzo_
             l1 = len_of_coded_match(m_len,m_off,lit);
             assert(l1 > 0);
 #if 1
-            max_ahead = LZO_MIN((lzo_uint)try_lazy, (lzo_uint)l1 - 1);
+            max_ahead = LZO_MIN(try_lazy, l1 - 1);
 #else
             max_ahead = LZO_MIN3(try_lazy, l1, m_len - 1);
 #endif
@@ -684,7 +673,7 @@ lzo1x_999_compress_internal ( const lzo_
 
         while (ahead < max_ahead && c->look > m_len)
         {
-            lzo_int lazy_match_min_gain;
+            lzo_uint lazy_match_min_gain;
 
             if (m_len >= good_length)
                 swd->max_chain = max_chain >> 2;
@@ -693,7 +682,7 @@ lzo1x_999_compress_internal ( const lzo_
             r = find_match(c,swd,1,0);
             ahead++;
 
-            assert(r == 0);
+            assert(r == 0); LZO_UNUSED(r);
             assert(c->look > 0);
             assert(ii + lit + ahead == c->bp);
 
@@ -713,7 +702,7 @@ lzo1x_999_compress_internal ( const lzo_
                 better_match(swd,&c->m_len,&c->m_off);
 #endif
             l2 = len_of_coded_match(c->m_len,c->m_off,lit+ahead);
-            if (l2 < 0)
+            if (l2 == 0)
                 continue;
 #if 0
             if (c->m_len == m_len && l2 >= l1)
@@ -723,7 +712,7 @@ lzo1x_999_compress_internal ( const lzo_
 
 #if 1
             /* compressed-data compatibility [see above] */
-            l3 = (op == out) ? -1 : len_of_coded_match(ahead,m_off,lit);
+            l3 = (op == out) ? 0 : len_of_coded_match(ahead,m_off,lit);
 #else
             l3 = len_of_coded_match(ahead,m_off,lit);
 #endif
@@ -734,7 +723,7 @@ lzo1x_999_compress_internal ( const lzo_
                 c->lazy++;
                 assert_match(swd,c->m_len,c->m_off);
 
-                if (l3 > 0)
+                if (l3)
                 {
                     /* code previous run */
                     op = code_run(c,op,ii,lit,ahead);
@@ -762,7 +751,7 @@ lzo1x_999_compress_internal ( const lzo_
         op = code_match(c,op,m_len,m_off);
         swd->max_chain = max_chain;
         r = find_match(c,swd,m_len,1+ahead);
-        assert(r == 0);
+        assert(r == 0); LZO_UNUSED(r);
 
 lazy_match_done: ;
     }
@@ -812,24 +801,24 @@ lzo1x_999_compress_level    ( const lzo_
 {
     static const struct
     {
-        int try_lazy;
+        int try_lazy_parm;
         lzo_uint good_length;
         lzo_uint max_lazy;
         lzo_uint nice_length;
         lzo_uint max_chain;
-        lzo_uint32 flags;
+        lzo_uint32_t flags;
     } c[9] = {
-        {   0,   0,   0,   8,    4,   0 },      /* faster compression */
-        {   0,   0,   0,  16,    8,   0 },
-        {   0,   0,   0,  32,   16,   0 },
-
-        {   1,   4,   4,  16,   16,   0 },
-        {   1,   8,  16,  32,   32,   0 },
-        {   1,   8,  16, 128,  128,   0 },
-
-        {   2,   8,  32, 128,  256,   0 },
-        {   2,  32, 128,   F, 2048,   1 },
-        {   2,   F,   F,   F, 4096,   1 }       /* max. compression */
+        /* faster compression */
+        {   0,     0,     0,     8,    4,   0 },
+        {   0,     0,     0,    16,    8,   0 },
+        {   0,     0,     0,    32,   16,   0 },
+        {   1,     4,     4,    16,   16,   0 },
+        {   1,     8,    16,    32,   32,   0 },
+        {   1,     8,    16,   128,  128,   0 },
+        {   2,     8,    32,   128,  256,   0 },
+        {   2,    32,   128, SWD_F, 2048,   1 },
+        {   2, SWD_F, SWD_F, SWD_F, 4096,   1 }
+        /* max. compression */
     };
 
     if (compression_level < 1 || compression_level > 9)
@@ -838,7 +827,7 @@ lzo1x_999_compress_level    ( const lzo_
     compression_level -= 1;
     return lzo1x_999_compress_internal(in, in_len, out, out_len, wrkmem,
                                        dict, dict_len, cb,
-                                       c[compression_level].try_lazy,
+                                       c[compression_level].try_lazy_parm,
                                        c[compression_level].good_length,
                                        c[compression_level].max_lazy,
 #if 0
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo1x_c.ch syslinux-4.07b/lzo/src/lzo1x_c.ch
--- Syslinux-4.07a/lzo/src/lzo1x_c.ch	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo1x_c.ch	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -39,6 +27,12 @@
 
 
 
+#if 1 && defined(DO_COMPRESS) && !defined(do_compress)
+   /* choose a unique name to better help PGO optimizations */
+#  define do_compress       LZO_PP_ECONCAT2(DO_COMPRESS,_core)
+#endif
+
+
 /***********************************************************************
 // compress a block of data.
 ************************************************************************/
@@ -46,12 +40,12 @@
 static __lzo_noinline lzo_uint
 do_compress ( const lzo_bytep in , lzo_uint  in_len,
                     lzo_bytep out, lzo_uintp out_len,
-                    lzo_voidp wrkmem )
+                    lzo_uint  ti,  lzo_voidp wrkmem)
 {
-    register const lzo_bytep ip;
+    const lzo_bytep ip;
     lzo_bytep op;
     const lzo_bytep const in_end = in + in_len;
-    const lzo_bytep const ip_end = in + in_len - M2_MAX_LEN - 5;
+    const lzo_bytep const ip_end = in + in_len - 20;
     const lzo_bytep ii;
     lzo_dict_p const dict = (lzo_dict_p) wrkmem;
 
@@ -59,14 +53,17 @@ do_compress ( const lzo_bytep in , lzo_u
     ip = in;
     ii = ip;
 
-    ip += 4;
+    ip += ti < 4 ? 4 - ti : 0;
     for (;;)
     {
-        register const lzo_bytep m_pos;
-        lzo_uint m_off;
+        const lzo_bytep m_pos;
+#if !(LZO_DETERMINISTIC)
+        LZO_DEFINE_UNINITIALIZED_VAR(lzo_uint, m_off, 0);
         lzo_uint m_len;
         lzo_uint dindex;
-
+next:
+        if __lzo_unlikely(ip >= ip_end)
+            break;
         DINDEX1(dindex,ip);
         GINDEX(m_pos,m_off,dict,dindex,in);
         if (LZO_CHECK_MPOS_NON_DET(m_pos,m_off,in,ip,M4_MAX_OFFSET))
@@ -83,210 +80,252 @@ do_compress ( const lzo_bytep in , lzo_u
             goto try_match;
         goto literal;
 
-
 try_match:
-#if 1 && defined(LZO_UNALIGNED_OK_2)
-        if (* (const lzo_ushortp) m_pos != * (const lzo_ushortp) ip)
+#if (LZO_OPT_UNALIGNED32)
+        if (UA_GET_NE32(m_pos) != UA_GET_NE32(ip))
 #else
-        if (m_pos[0] != ip[0] || m_pos[1] != ip[1])
+        if (m_pos[0] != ip[0] || m_pos[1] != ip[1] || m_pos[2] != ip[2] || m_pos[3] != ip[3])
 #endif
         {
+            /* a literal */
+literal:
+            UPDATE_I(dict,0,dindex,ip,in);
+            ip += 1 + ((ip - ii) >> 5);
+            continue;
         }
-        else
-        {
-            if __lzo_likely(m_pos[2] == ip[2])
-            {
-#if 0
-                if (m_off <= M2_MAX_OFFSET)
-                    goto match;
-                if (lit <= 3)
-                    goto match;
-                if (lit == 3)           /* better compression, but slower */
-                {
-                    assert(op - 2 > out); op[-2] |= LZO_BYTE(3);
-                    *op++ = *ii++; *op++ = *ii++; *op++ = *ii++;
-                    goto code_match;
-                }
-                if (m_pos[3] == ip[3])
-#endif
-                    goto match;
-            }
-            else
-            {
-                /* still need a better way for finding M1 matches */
-#if 0
-                /* a M1 match */
-#if 0
-                if (m_off <= M1_MAX_OFFSET && lit > 0 && lit <= 3)
+/*match:*/
+        UPDATE_I(dict,0,dindex,ip,in);
 #else
-                if (m_off <= M1_MAX_OFFSET && lit == 3)
-#endif
-                {
-                    register lzo_uint t;
-
-                    t = lit;
-                    assert(op - 2 > out); op[-2] |= LZO_BYTE(t);
-                    do *op++ = *ii++; while (--t > 0);
-                    assert(ii == ip);
-                    m_off -= 1;
-                    *op++ = LZO_BYTE(M1_MARKER | ((m_off & 3) << 2));
-                    *op++ = LZO_BYTE(m_off >> 2);
-                    ip += 2;
-                    goto match_done;
-                }
-#endif
-            }
-        }
-
-
-    /* a literal */
+        lzo_uint m_off;
+        lzo_uint m_len;
+        {
+        lzo_uint32_t dv;
+        lzo_uint dindex;
 literal:
-        UPDATE_I(dict,0,dindex,ip,in);
-        ++ip;
+        ip += 1 + ((ip - ii) >> 5);
+next:
         if __lzo_unlikely(ip >= ip_end)
             break;
-        continue;
-
+        dv = UA_GET_LE32(ip);
+        dindex = DINDEX(dv,ip);
+        GINDEX(m_off,m_pos,in+dict,dindex,in);
+        UPDATE_I(dict,0,dindex,ip,in);
+        if __lzo_unlikely(dv != UA_GET_LE32(m_pos))
+            goto literal;
+        }
+#endif
 
     /* a match */
-match:
-        UPDATE_I(dict,0,dindex,ip,in);
-        /* store current literal run */
-        if (pd(ip,ii) > 0)
-        {
-            register lzo_uint t = pd(ip,ii);
 
+        ii -= ti; ti = 0;
+        {
+        lzo_uint t = pd(ip,ii);
+        if (t != 0)
+        {
             if (t <= 3)
             {
-                assert(op - 2 > out);
-                op[-2] |= LZO_BYTE(t);
+                op[-2] = LZO_BYTE(op[-2] | t);
+#if (LZO_OPT_UNALIGNED32)
+                UA_COPY4(op, ii);
+                op += t;
+#else
+                { do *op++ = *ii++; while (--t > 0); }
+#endif
             }
-            else if (t <= 18)
+#if (LZO_OPT_UNALIGNED32) || (LZO_OPT_UNALIGNED64)
+            else if (t <= 16)
+            {
                 *op++ = LZO_BYTE(t - 3);
+                UA_COPY8(op, ii);
+                UA_COPY8(op+8, ii+8);
+                op += t;
+            }
+#endif
             else
             {
-                register lzo_uint tt = t - 18;
-
-                *op++ = 0;
-                while (tt > 255)
+                if (t <= 18)
+                    *op++ = LZO_BYTE(t - 3);
+                else
                 {
-                    tt -= 255;
+                    lzo_uint tt = t - 18;
                     *op++ = 0;
+                    while __lzo_unlikely(tt > 255)
+                    {
+                        tt -= 255;
+                        UA_SET1(op, 0);
+                        op++;
+                    }
+                    assert(tt > 0);
+                    *op++ = LZO_BYTE(tt);
                 }
-                assert(tt > 0);
-                *op++ = LZO_BYTE(tt);
+#if (LZO_OPT_UNALIGNED32) || (LZO_OPT_UNALIGNED64)
+                do {
+                    UA_COPY8(op, ii);
+                    UA_COPY8(op+8, ii+8);
+                    op += 16; ii += 16; t -= 16;
+                } while (t >= 16); if (t > 0)
+#endif
+                { do *op++ = *ii++; while (--t > 0); }
             }
-            do *op++ = *ii++; while (--t > 0);
         }
-
-        /* code the match */
-        assert(ii == ip);
-        ip += 3;
-        if (m_pos[3] != *ip++ || m_pos[4] != *ip++ || m_pos[5] != *ip++ ||
-            m_pos[6] != *ip++ || m_pos[7] != *ip++ || m_pos[8] != *ip++
-#ifdef LZO1Y
-            || m_pos[ 9] != *ip++ || m_pos[10] != *ip++ || m_pos[11] != *ip++
-            || m_pos[12] != *ip++ || m_pos[13] != *ip++ || m_pos[14] != *ip++
+        }
+        m_len = 4;
+        {
+#if (LZO_OPT_UNALIGNED64)
+        lzo_uint64_t v;
+        v = UA_GET_NE64(ip + m_len) ^ UA_GET_NE64(m_pos + m_len);
+        if __lzo_unlikely(v == 0) {
+            do {
+                m_len += 8;
+                v = UA_GET_NE64(ip + m_len) ^ UA_GET_NE64(m_pos + m_len);
+                if __lzo_unlikely(ip + m_len >= ip_end)
+                    goto m_len_done;
+            } while (v == 0);
+        }
+#if (LZO_ABI_BIG_ENDIAN) && defined(lzo_bitops_ctlz64)
+        m_len += lzo_bitops_ctlz64(v) / CHAR_BIT;
+#elif (LZO_ABI_BIG_ENDIAN)
+        if ((v >> (64 - CHAR_BIT)) == 0) do {
+            v <<= CHAR_BIT;
+            m_len += 1;
+        } while ((v >> (64 - CHAR_BIT)) == 0);
+#elif (LZO_ABI_LITTLE_ENDIAN) && defined(lzo_bitops_cttz64)
+        m_len += lzo_bitops_cttz64(v) / CHAR_BIT;
+#elif (LZO_ABI_LITTLE_ENDIAN)
+        if ((v & UCHAR_MAX) == 0) do {
+            v >>= CHAR_BIT;
+            m_len += 1;
+        } while ((v & UCHAR_MAX) == 0);
+#else
+        if (ip[m_len] == m_pos[m_len]) do {
+            m_len += 1;
+        } while (ip[m_len] == m_pos[m_len]);
+#endif
+#elif (LZO_OPT_UNALIGNED32)
+        lzo_uint32_t v;
+        v = UA_GET_NE32(ip + m_len) ^ UA_GET_NE32(m_pos + m_len);
+        if __lzo_unlikely(v == 0) {
+            do {
+                m_len += 4;
+                v = UA_GET_NE32(ip + m_len) ^ UA_GET_NE32(m_pos + m_len);
+                if (v != 0)
+                    break;
+                m_len += 4;
+                v = UA_GET_NE32(ip + m_len) ^ UA_GET_NE32(m_pos + m_len);
+                if __lzo_unlikely(ip + m_len >= ip_end)
+                    goto m_len_done;
+            } while (v == 0);
+        }
+#if (LZO_ABI_BIG_ENDIAN) && defined(lzo_bitops_ctlz32)
+        m_len += lzo_bitops_ctlz32(v) / CHAR_BIT;
+#elif (LZO_ABI_BIG_ENDIAN)
+        if ((v >> (32 - CHAR_BIT)) == 0) do {
+            v <<= CHAR_BIT;
+            m_len += 1;
+        } while ((v >> (32 - CHAR_BIT)) == 0);
+#elif (LZO_ABI_LITTLE_ENDIAN) && defined(lzo_bitops_cttz32)
+        m_len += lzo_bitops_cttz32(v) / CHAR_BIT;
+#elif (LZO_ABI_LITTLE_ENDIAN)
+        if ((v & UCHAR_MAX) == 0) do {
+            v >>= CHAR_BIT;
+            m_len += 1;
+        } while ((v & UCHAR_MAX) == 0);
+#else
+        if (ip[m_len] == m_pos[m_len]) do {
+            m_len += 1;
+        } while (ip[m_len] == m_pos[m_len]);
+#endif
+#else
+        if __lzo_unlikely(ip[m_len] == m_pos[m_len]) {
+            do {
+                m_len += 1;
+                if (ip[m_len] != m_pos[m_len])
+                    break;
+                m_len += 1;
+                if (ip[m_len] != m_pos[m_len])
+                    break;
+                m_len += 1;
+                if (ip[m_len] != m_pos[m_len])
+                    break;
+                m_len += 1;
+                if (ip[m_len] != m_pos[m_len])
+                    break;
+                m_len += 1;
+                if (ip[m_len] != m_pos[m_len])
+                    break;
+                m_len += 1;
+                if (ip[m_len] != m_pos[m_len])
+                    break;
+                m_len += 1;
+                if (ip[m_len] != m_pos[m_len])
+                    break;
+                m_len += 1;
+                if __lzo_unlikely(ip + m_len >= ip_end)
+                    goto m_len_done;
+            } while (ip[m_len] == m_pos[m_len]);
+        }
 #endif
-           )
+        }
+m_len_done:
+        m_off = pd(ip,m_pos);
+        ip += m_len;
+        ii = ip;
+        if (m_len <= M2_MAX_LEN && m_off <= M2_MAX_OFFSET)
         {
-            --ip;
-            m_len = pd(ip, ii);
-            assert(m_len >= 3); assert(m_len <= M2_MAX_LEN);
-
-            if (m_off <= M2_MAX_OFFSET)
-            {
-                m_off -= 1;
+            m_off -= 1;
 #if defined(LZO1X)
-                *op++ = LZO_BYTE(((m_len - 1) << 5) | ((m_off & 7) << 2));
-                *op++ = LZO_BYTE(m_off >> 3);
+            *op++ = LZO_BYTE(((m_len - 1) << 5) | ((m_off & 7) << 2));
+            *op++ = LZO_BYTE(m_off >> 3);
 #elif defined(LZO1Y)
-                *op++ = LZO_BYTE(((m_len + 1) << 4) | ((m_off & 3) << 2));
-                *op++ = LZO_BYTE(m_off >> 2);
+            *op++ = LZO_BYTE(((m_len + 1) << 4) | ((m_off & 3) << 2));
+            *op++ = LZO_BYTE(m_off >> 2);
 #endif
-            }
-            else if (m_off <= M3_MAX_OFFSET)
-            {
-                m_off -= 1;
+        }
+        else if (m_off <= M3_MAX_OFFSET)
+        {
+            m_off -= 1;
+            if (m_len <= M3_MAX_LEN)
                 *op++ = LZO_BYTE(M3_MARKER | (m_len - 2));
-                goto m3_m4_offset;
-            }
             else
-#if defined(LZO1X)
             {
-                m_off -= 0x4000;
-                assert(m_off > 0); assert(m_off <= 0x7fff);
-                *op++ = LZO_BYTE(M4_MARKER |
-                                 ((m_off & 0x4000) >> 11) | (m_len - 2));
-                goto m3_m4_offset;
+                m_len -= M3_MAX_LEN;
+                *op++ = M3_MARKER | 0;
+                while __lzo_unlikely(m_len > 255)
+                {
+                    m_len -= 255;
+                    UA_SET1(op, 0);
+                    op++;
+                }
+                *op++ = LZO_BYTE(m_len);
             }
-#elif defined(LZO1Y)
-                goto m4_match;
-#endif
+            *op++ = LZO_BYTE(m_off << 2);
+            *op++ = LZO_BYTE(m_off >> 6);
         }
         else
         {
-            {
-                const lzo_bytep end = in_end;
-                const lzo_bytep m = m_pos + M2_MAX_LEN + 1;
-                while (ip < end && *m == *ip)
-                    m++, ip++;
-                m_len = pd(ip, ii);
-            }
-            assert(m_len > M2_MAX_LEN);
-
-            if (m_off <= M3_MAX_OFFSET)
-            {
-                m_off -= 1;
-                if (m_len <= 33)
-                    *op++ = LZO_BYTE(M3_MARKER | (m_len - 2));
-                else
-                {
-                    m_len -= 33;
-                    *op++ = M3_MARKER | 0;
-                    goto m3_m4_len;
-                }
-            }
+            m_off -= 0x4000;
+            if (m_len <= M4_MAX_LEN)
+                *op++ = LZO_BYTE(M4_MARKER | ((m_off >> 11) & 8) | (m_len - 2));
             else
             {
-#if defined(LZO1Y)
-m4_match:
-#endif
-                m_off -= 0x4000;
-                assert(m_off > 0); assert(m_off <= 0x7fff);
-                if (m_len <= M4_MAX_LEN)
-                    *op++ = LZO_BYTE(M4_MARKER |
-                                     ((m_off & 0x4000) >> 11) | (m_len - 2));
-                else
+                m_len -= M4_MAX_LEN;
+                *op++ = LZO_BYTE(M4_MARKER | ((m_off >> 11) & 8));
+                while __lzo_unlikely(m_len > 255)
                 {
-                    m_len -= M4_MAX_LEN;
-                    *op++ = LZO_BYTE(M4_MARKER | ((m_off & 0x4000) >> 11));
-m3_m4_len:
-                    while (m_len > 255)
-                    {
-                        m_len -= 255;
-                        *op++ = 0;
-                    }
-                    assert(m_len > 0);
-                    *op++ = LZO_BYTE(m_len);
+                    m_len -= 255;
+                    UA_SET1(op, 0);
+                    op++;
                 }
+                *op++ = LZO_BYTE(m_len);
             }
-
-m3_m4_offset:
-            *op++ = LZO_BYTE((m_off & 63) << 2);
+            *op++ = LZO_BYTE(m_off << 2);
             *op++ = LZO_BYTE(m_off >> 6);
         }
-
-#if 0
-match_done:
-#endif
-        ii = ip;
-        if __lzo_unlikely(ip >= ip_end)
-            break;
+        goto next;
     }
 
     *out_len = pd(op, out);
-    return pd(in_end,ii);
+    return pd(in_end,ii-ti);
 }
 
 
@@ -299,16 +338,30 @@ DO_COMPRESS      ( const lzo_bytep in ,
                          lzo_bytep out, lzo_uintp out_len,
                          lzo_voidp wrkmem )
 {
+    const lzo_bytep ip = in;
     lzo_bytep op = out;
-    lzo_uint t;
+    lzo_uint l = in_len;
+    lzo_uint t = 0;
 
-    if __lzo_unlikely(in_len <= M2_MAX_LEN + 5)
-        t = in_len;
-    else
+    while (l > 20)
     {
-        t = do_compress(in,in_len,op,out_len,wrkmem);
+        lzo_uint ll = l;
+        lzo_uintptr_t ll_end;
+#if 0 || (LZO_DETERMINISTIC)
+        ll = LZO_MIN(ll, 49152);
+#endif
+        ll_end = (lzo_uintptr_t)ip + ll;
+        if ((ll_end + ((t + ll) >> 5)) <= ll_end || (const lzo_bytep)(ll_end + ((t + ll) >> 5)) <= ip + ll)
+            break;
+#if (LZO_DETERMINISTIC)
+        lzo_memset(wrkmem, 0, ((lzo_uint)1 << D_BITS) * sizeof(lzo_dict_t));
+#endif
+        t = do_compress(ip,ll,op,out_len,t,wrkmem);
+        ip += ll;
         op += *out_len;
+        l  -= ll;
     }
+    t += l;
 
     if (t > 0)
     {
@@ -317,7 +370,7 @@ DO_COMPRESS      ( const lzo_bytep in ,
         if (op == out && t <= 238)
             *op++ = LZO_BYTE(17 + t);
         else if (t <= 3)
-            op[-2] |= LZO_BYTE(t);
+            op[-2] = LZO_BYTE(op[-2] | t);
         else if (t <= 18)
             *op++ = LZO_BYTE(t - 3);
         else
@@ -328,12 +381,14 @@ DO_COMPRESS      ( const lzo_bytep in ,
             while (tt > 255)
             {
                 tt -= 255;
-                *op++ = 0;
+                UA_SET1(op, 0);
+                op++;
             }
             assert(tt > 0);
             *op++ = LZO_BYTE(tt);
         }
-        do *op++ = *ii++; while (--t > 0);
+        UA_COPYN(op, ii, t);
+        op += t;
     }
 
     *op++ = M4_MARKER | 1;
@@ -348,4 +403,3 @@ DO_COMPRESS      ( const lzo_bytep in ,
 /*
 vi:ts=4:et
 */
-
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo1x_d.ch syslinux-4.07b/lzo/src/lzo1x_d.ch
--- Syslinux-4.07a/lzo/src/lzo1x_d.ch	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo1x_d.ch	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -41,17 +29,6 @@
 #include "lzo1_d.ch"
 
 
-#undef __COPY4
-#define __COPY4(dst,src)    * (lzo_uint32p)(dst) = * (const lzo_uint32p)(src)
-
-#undef COPY4
-#if defined(LZO_UNALIGNED_OK_4)
-#  define COPY4(dst,src)    __COPY4(dst,src)
-#elif defined(LZO_ALIGNED_OK_4)
-#  define COPY4(dst,src)    __COPY4((lzo_uintptr_t)(dst),(lzo_uintptr_t)(src))
-#endif
-
-
 /***********************************************************************
 // decompress a block of data.
 ************************************************************************/
@@ -63,14 +40,14 @@ DO_DECOMPRESS  ( const lzo_bytep in , lz
                        lzo_voidp wrkmem )
 #endif
 {
-    register lzo_bytep op;
-    register const lzo_bytep ip;
-    register lzo_uint t;
+    lzo_bytep op;
+    const lzo_bytep ip;
+    lzo_uint t;
 #if defined(COPY_DICT)
     lzo_uint m_off;
     const lzo_bytep dict_end;
 #else
-    register const lzo_bytep m_pos;
+    const lzo_bytep m_pos;
 #endif
 
     const lzo_bytep const ip_end = in + in_len;
@@ -105,48 +82,67 @@ DO_DECOMPRESS  ( const lzo_bytep in , lz
     op = out;
     ip = in;
 
+    NEED_IP(1);
     if (*ip > 17)
     {
         t = *ip++ - 17;
         if (t < 4)
             goto match_next;
-        assert(t > 0); NEED_OP(t); NEED_IP(t+1);
+        assert(t > 0); NEED_OP(t); NEED_IP(t+3);
         do *op++ = *ip++; while (--t > 0);
         goto first_literal_run;
     }
 
-    while (TEST_IP && TEST_OP)
+    for (;;)
     {
+        NEED_IP(3);
         t = *ip++;
         if (t >= 16)
             goto match;
         /* a literal run */
         if (t == 0)
         {
-            NEED_IP(1);
             while (*ip == 0)
             {
                 t += 255;
                 ip++;
+                TEST_IV(t);
                 NEED_IP(1);
             }
             t += 15 + *ip++;
         }
         /* copy literals */
-        assert(t > 0); NEED_OP(t+3); NEED_IP(t+4);
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#if !defined(LZO_UNALIGNED_OK_4)
+        assert(t > 0); NEED_OP(t+3); NEED_IP(t+6);
+#if (LZO_OPT_UNALIGNED64) && (LZO_OPT_UNALIGNED32)
+        t += 3;
+        if (t >= 8) do
+        {
+            UA_COPY8(op,ip);
+            op += 8; ip += 8; t -= 8;
+        } while (t >= 8);
+        if (t >= 4)
+        {
+            UA_COPY4(op,ip);
+            op += 4; ip += 4; t -= 4;
+        }
+        if (t > 0)
+        {
+            *op++ = *ip++;
+            if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }
+        }
+#elif (LZO_OPT_UNALIGNED32) || (LZO_ALIGNED_OK_4)
+#if !(LZO_OPT_UNALIGNED32)
         if (PTR_ALIGNED2_4(op,ip))
         {
 #endif
-        COPY4(op,ip);
+        UA_COPY4(op,ip);
         op += 4; ip += 4;
         if (--t > 0)
         {
             if (t >= 4)
             {
                 do {
-                    COPY4(op,ip);
+                    UA_COPY4(op,ip);
                     op += 4; ip += 4; t -= 4;
                 } while (t >= 4);
                 if (t > 0) do *op++ = *ip++; while (--t > 0);
@@ -154,12 +150,12 @@ DO_DECOMPRESS  ( const lzo_bytep in , lz
             else
                 do *op++ = *ip++; while (--t > 0);
         }
-#if !defined(LZO_UNALIGNED_OK_4)
+#if !(LZO_OPT_UNALIGNED32)
         }
         else
 #endif
 #endif
-#if !defined(LZO_UNALIGNED_OK_4)
+#if !(LZO_OPT_UNALIGNED32)
         {
             *op++ = *ip++; *op++ = *ip++; *op++ = *ip++;
             do *op++ = *ip++; while (--t > 0);
@@ -199,7 +195,7 @@ first_literal_run:
 
 
         /* handle matches */
-        do {
+        for (;;) {
 match:
             if (t >= 64)                /* a M2 match */
             {
@@ -259,14 +255,15 @@ match:
                 t &= 31;
                 if (t == 0)
                 {
-                    NEED_IP(1);
                     while (*ip == 0)
                     {
                         t += 255;
                         ip++;
+                        TEST_OV(t);
                         NEED_IP(1);
                     }
                     t += 31 + *ip++;
+                    NEED_IP(2);
                 }
 #if defined(COPY_DICT)
 #if defined(LZO1Z)
@@ -282,9 +279,9 @@ match:
                     m_pos = op - off;
                     last_m_off = off;
                 }
-#elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
+#elif (LZO_OPT_UNALIGNED16) && (LZO_ABI_LITTLE_ENDIAN)
                 m_pos = op - 1;
-                m_pos -= (* (const lzo_ushortp) ip) >> 2;
+                m_pos -= UA_GET_LE16(ip) >> 2;
 #else
                 m_pos = op - 1;
                 m_pos -= (ip[0] >> 2) + (ip[1] << 6);
@@ -303,14 +300,15 @@ match:
                 t &= 7;
                 if (t == 0)
                 {
-                    NEED_IP(1);
                     while (*ip == 0)
                     {
                         t += 255;
                         ip++;
+                        TEST_OV(t);
                         NEED_IP(1);
                     }
                     t += 7 + *ip++;
+                    NEED_IP(2);
                 }
 #if defined(COPY_DICT)
 #if defined(LZO1Z)
@@ -328,8 +326,8 @@ match:
 #else /* !COPY_DICT */
 #if defined(LZO1Z)
                 m_pos -= (ip[0] << 6) + (ip[1] >> 2);
-#elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
-                m_pos -= (* (const lzo_ushortp) ip) >> 2;
+#elif (LZO_OPT_UNALIGNED16) && (LZO_ABI_LITTLE_ENDIAN)
+                m_pos -= UA_GET_LE16(ip) >> 2;
 #else
                 m_pos -= (ip[0] >> 2) + (ip[1] << 6);
 #endif
@@ -378,8 +376,29 @@ match:
 #else /* !COPY_DICT */
 
             TEST_LB(m_pos); assert(t > 0); NEED_OP(t+3-1);
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#if !defined(LZO_UNALIGNED_OK_4)
+#if (LZO_OPT_UNALIGNED64) && (LZO_OPT_UNALIGNED32)
+            if (op - m_pos >= 8)
+            {
+                t += (3 - 1);
+                if (t >= 8) do
+                {
+                    UA_COPY8(op,m_pos);
+                    op += 8; m_pos += 8; t -= 8;
+                } while (t >= 8);
+                if (t >= 4)
+                {
+                    UA_COPY4(op,m_pos);
+                    op += 4; m_pos += 4; t -= 4;
+                }
+                if (t > 0)
+                {
+                    *op++ = m_pos[0];
+                    if (t > 1) { *op++ = m_pos[1]; if (t > 2) { *op++ = m_pos[2]; } }
+                }
+            }
+            else
+#elif (LZO_OPT_UNALIGNED32) || (LZO_ALIGNED_OK_4)
+#if !(LZO_OPT_UNALIGNED32)
             if (t >= 2 * 4 - (3 - 1) && PTR_ALIGNED2_4(op,m_pos))
             {
                 assert((op - m_pos) >= 4);  /* both pointers are aligned */
@@ -387,10 +406,10 @@ match:
             if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4)
             {
 #endif
-                COPY4(op,m_pos);
+                UA_COPY4(op,m_pos);
                 op += 4; m_pos += 4; t -= 4 - (3 - 1);
                 do {
-                    COPY4(op,m_pos);
+                    UA_COPY4(op,m_pos);
                     op += 4; m_pos += 4; t -= 4;
                 } while (t >= 4);
                 if (t > 0) do *op++ = *m_pos++; while (--t > 0);
@@ -416,7 +435,7 @@ match_done:
 
             /* copy literals */
 match_next:
-            assert(t > 0); assert(t < 4); NEED_OP(t); NEED_IP(t+1);
+            assert(t > 0); assert(t < 4); NEED_OP(t); NEED_IP(t+3);
 #if 0
             do *op++ = *ip++; while (--t > 0);
 #else
@@ -424,17 +443,10 @@ match_next:
             if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }
 #endif
             t = *ip++;
-        } while (TEST_IP && TEST_OP);
+        }
     }
 
-#if defined(HAVE_TEST_IP) || defined(HAVE_TEST_OP)
-    /* no EOF code was found */
-    *out_len = pd(op, out);
-    return LZO_E_EOF_NOT_FOUND;
-#endif
-
 eof_found:
-    assert(t == 1);
     *out_len = pd(op, out);
     return (ip == ip_end ? LZO_E_OK :
            (ip < ip_end  ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN));
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo1x_d1.c syslinux-4.07b/lzo/src/lzo1x_d1.c
--- Syslinux-4.07a/lzo/src/lzo1x_d1.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo1x_d1.c	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo1x_d2.c syslinux-4.07b/lzo/src/lzo1x_d2.c
--- Syslinux-4.07a/lzo/src/lzo1x_d2.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo1x_d2.c	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -40,7 +28,32 @@
 
 #include "config1x.h"
 
-#define LZO_TEST_OVERRUN
+#define LZO_TEST_OVERRUN 1
 #define DO_DECOMPRESS       lzo1x_decompress_safe
 
 #include "lzo1x_d.ch"
+
+#if defined(LZO_ARCH_I386) && defined(LZO_USE_ASM)
+LZO_EXTERN(int) lzo1x_decompress_asm_safe
+                                (const lzo_bytep src, lzo_uint  src_len,
+                                       lzo_bytep dst, lzo_uintp dst_len,
+                                       lzo_voidp wrkmem);
+LZO_PUBLIC(int) lzo1x_decompress_asm_safe
+                                (const lzo_bytep src, lzo_uint  src_len,
+                                       lzo_bytep dst, lzo_uintp dst_len,
+                                       lzo_voidp wrkmem)
+{
+    return lzo1x_decompress_safe(src, src_len, dst, dst_len, wrkmem);
+}
+LZO_EXTERN(int) lzo1x_decompress_asm_fast_safe
+                                (const lzo_bytep src, lzo_uint  src_len,
+                                       lzo_bytep dst, lzo_uintp dst_len,
+                                       lzo_voidp wrkmem);
+LZO_PUBLIC(int) lzo1x_decompress_asm_fast_safe
+                                (const lzo_bytep src, lzo_uint  src_len,
+                                       lzo_bytep dst, lzo_uintp dst_len,
+                                       lzo_voidp wrkmem)
+{
+    return lzo1x_decompress_safe(src, src_len, dst, dst_len, wrkmem);
+}
+#endif
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo1x_d3.c syslinux-4.07b/lzo/src/lzo1x_d3.c
--- Syslinux-4.07a/lzo/src/lzo1x_d3.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo1x_d3.c	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -40,7 +28,7 @@
 
 #include "config1x.h"
 
-#define LZO_TEST_OVERRUN
+#define LZO_TEST_OVERRUN 1
 
 
 #define SLOW_MEMCPY(a,b,l)      { do *a++ = *b++; while (--l > 0); }
@@ -64,7 +52,7 @@
 
 #define COPY_DICT_DICT(m_len,m_off) \
     { \
-        register const lzo_bytep m_pos; \
+        const lzo_bytep m_pos; \
         m_off -= pd(op, out); assert(m_off > 0); \
         if (m_off > dict_len) goto lookbehind_overrun; \
         m_pos = dict_end - m_off; \
@@ -83,7 +71,7 @@
     assert(m_len >= 2); assert(m_off > 0); assert(op > out); \
     if (m_off <= pd(op, out)) \
     { \
-        register const lzo_bytep m_pos = op - m_off; \
+        const lzo_bytep m_pos = op - m_off; \
         DICT_MEMMOVE(op,m_pos,m_len,m_off) \
     } \
     else \
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo1x_o.c syslinux-4.07b/lzo/src/lzo1x_o.c
--- Syslinux-4.07a/lzo/src/lzo1x_o.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo1x_o.c	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo1x_oo.ch syslinux-4.07b/lzo/src/lzo1x_oo.ch
--- Syslinux-4.07a/lzo/src/lzo1x_oo.ch	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo1x_oo.ch	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -40,6 +28,7 @@
 
 #define TEST_IP     (ip < ip_end)
 #define TEST_OP     (op <= op_end)
+#define TEST_IP_AND_TEST_OP (TEST_IP && TEST_OP)
 
 #define NO_LIT      LZO_UINT_MAX
 
@@ -118,7 +107,7 @@ DO_OPTIMIZE          (       lzo_bytep i
     }
     assert(*ip < 16 || (*ip == 17 && in_len == 3));
 
-    while (TEST_IP && TEST_OP)
+    while (TEST_IP_AND_TEST_OP)
     {
         t = *ip++;
         if (t >= 16)
@@ -339,7 +328,7 @@ match_done:
 match_next:
             do *op++ = *ip++; while (--t > 0);
             t = *ip++;
-        } while (TEST_IP && TEST_OP);
+        } while (TEST_IP_AND_TEST_OP);
     }
 
     /* no EOF code was found */
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo_conf.h syslinux-4.07b/lzo/src/lzo_conf.h
--- Syslinux-4.07a/lzo/src/lzo_conf.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo_conf.h	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -45,26 +33,12 @@
 
 
 #ifndef __LZO_CONF_H
-#define __LZO_CONF_H
+#define __LZO_CONF_H 1
 
 #if !defined(__LZO_IN_MINILZO)
-#if defined(LZO_CFG_FREESTANDING)
+#if defined(LZO_CFG_FREESTANDING) && (LZO_CFG_FREESTANDING)
 #  define LZO_LIBC_FREESTANDING 1
 #  define LZO_OS_FREESTANDING 1
-#  define ACC_LIBC_FREESTANDING 1
-#  define ACC_OS_FREESTANDING 1
-#endif
-#if defined(LZO_CFG_NO_UNALIGNED)
-#  define ACC_CFG_NO_UNALIGNED 1
-#endif
-#if defined(LZO_ARCH_GENERIC)
-#  define ACC_ARCH_GENERIC 1
-#endif
-#if defined(LZO_ABI_NEUTRAL_ENDIAN)
-#  define ACC_ABI_NEUTRAL_ENDIAN 1
-#endif
-#if defined(LZO_HAVE_CONFIG_H)
-#  define ACC_CONFIG_NO_HEADER 1
 #endif
 #if defined(LZO_CFG_EXTRA_CONFIG_HEADER)
 #  include LZO_CFG_EXTRA_CONFIG_HEADER
@@ -73,9 +47,12 @@
 #  error "include this file first"
 #endif
 #include "lzo/lzoconf.h"
+#if defined(LZO_CFG_EXTRA_CONFIG_HEADER2)
+#  include LZO_CFG_EXTRA_CONFIG_HEADER2
+#endif
 #endif
 
-#if (LZO_VERSION < 0x02000) || !defined(__LZOCONF_H_INCLUDED)
+#if (LZO_VERSION < 0x2070) || !defined(__LZOCONF_H_INCLUDED)
 #  error "version mismatch"
 #endif
 
@@ -84,23 +61,30 @@
 // pragmas
 ************************************************************************/
 
-#if (LZO_CC_BORLANDC && LZO_ARCH_I086)
-#  pragma option -h         /* enable fast huge pointers */
+#if (LZO_CC_MSC && (_MSC_VER >= 1000 && _MSC_VER < 1100))
+   /* disable bogus "unreachable code" warnings */
+#  pragma warning(disable: 4702)
 #endif
-
 #if (LZO_CC_MSC && (_MSC_VER >= 1000))
 #  pragma warning(disable: 4127 4701)
+   /* disable warnings about inlining */
+#  pragma warning(disable: 4514 4710 4711)
 #endif
 #if (LZO_CC_MSC && (_MSC_VER >= 1300))
-   /* avoid `-Wall' warnings in system header files */
+   /* disable '-Wall' warnings in system header files */
 #  pragma warning(disable: 4820)
-   /* avoid warnings about inlining */
-#  pragma warning(disable: 4514 4710 4711)
+#endif
+#if (LZO_CC_MSC && (_MSC_VER >= 1800))
+   /* disable '-Wall' warnings in system header files */
+#  pragma warning(disable: 4746)
 #endif
 
 #if (LZO_CC_SUNPROC)
+#if !defined(__cplusplus)
 #  pragma error_messages(off,E_END_OF_LOOP_CODE_NOT_REACHED)
 #  pragma error_messages(off,E_LOOP_NOT_ENTERED_AT_TOP)
+#  pragma error_messages(off,E_STATEMENT_NOT_REACHED)
+#endif
 #endif
 
 
@@ -108,58 +92,73 @@
 //
 ************************************************************************/
 
-#if defined(__LZO_MMODEL_HUGE) && (!LZO_HAVE_MM_HUGE_PTR)
-#  error "this should not happen - check defines for __huge"
-#endif
-
-#if defined(__LZO_IN_MINILZO) || defined(LZO_CFG_FREESTANDING)
-#elif (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#  define ACC_WANT_ACC_INCD_H 1
-#  define ACC_WANT_ACC_INCE_H 1
-#  define ACC_WANT_ACC_INCI_H 1
+#if defined(__LZO_IN_MINILZO) || (LZO_CFG_FREESTANDING)
 #elif 1
 #  include <string.h>
 #else
-#  define ACC_WANT_ACC_INCD_H 1
+#  define LZO_WANT_ACC_INCD_H 1
+#endif
+#if defined(LZO_HAVE_CONFIG_H)
+#  define LZO_CFG_NO_CONFIG_HEADER 1
 #endif
-#include "miniacc.h"
+#include "lzo_supp.h"
 
+/* Integral types */
+#if 1 || defined(lzo_int8_t) || defined(lzo_uint8_t)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int8_t)  == 1)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint8_t) == 1)
+#endif
+#if 1 || defined(lzo_int16_t) || defined(lzo_uint16_t)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int16_t)  == 2)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint16_t) == 2)
+#endif
+#if 1 || defined(lzo_int32_t) || defined(lzo_uint32_t)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int32_t)  == 4)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint32_t) == 4)
+#endif
+#if defined(lzo_int64_t) || defined(lzo_uint64_t)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_int64_t)  == 8)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint64_t) == 8)
+#endif
 
-#if defined(LZO_CFG_FREESTANDING)
+#if (LZO_CFG_FREESTANDING)
 #  undef HAVE_MEMCMP
 #  undef HAVE_MEMCPY
 #  undef HAVE_MEMMOVE
 #  undef HAVE_MEMSET
 #endif
 
-#if !defined(HAVE_MEMCMP)
+#if !(HAVE_MEMCMP)
 #  undef memcmp
 #  define memcmp(a,b,c)         lzo_memcmp(a,b,c)
-#elif !defined(__LZO_MMODEL_HUGE)
+#else
+#  undef lzo_memcmp
 #  define lzo_memcmp(a,b,c)     memcmp(a,b,c)
 #endif
-#if !defined(HAVE_MEMCPY)
+#if !(HAVE_MEMCPY)
 #  undef memcpy
 #  define memcpy(a,b,c)         lzo_memcpy(a,b,c)
-#elif !defined(__LZO_MMODEL_HUGE)
+#else
+#  undef lzo_memcpy
 #  define lzo_memcpy(a,b,c)     memcpy(a,b,c)
 #endif
-#if !defined(HAVE_MEMMOVE)
+#if !(HAVE_MEMMOVE)
 #  undef memmove
 #  define memmove(a,b,c)        lzo_memmove(a,b,c)
-#elif !defined(__LZO_MMODEL_HUGE)
+#else
+#  undef lzo_memmove
 #  define lzo_memmove(a,b,c)    memmove(a,b,c)
 #endif
-#if !defined(HAVE_MEMSET)
+#if !(HAVE_MEMSET)
 #  undef memset
 #  define memset(a,b,c)         lzo_memset(a,b,c)
-#elif !defined(__LZO_MMODEL_HUGE)
+#else
+#  undef lzo_memset
 #  define lzo_memset(a,b,c)     memset(a,b,c)
 #endif
 
-
 #undef NDEBUG
-#if defined(LZO_CFG_FREESTANDING)
+#if (LZO_CFG_FREESTANDING)
 #  undef LZO_DEBUG
 #  define NDEBUG 1
 #  undef assert
@@ -178,15 +177,28 @@
 #  define BOUNDS_CHECKING_OFF_IN_EXPR(expr)     (expr)
 #endif
 
-#if !defined(__lzo_inline)
-#  define __lzo_inline
-#endif
-#if !defined(__lzo_forceinline)
-#  define __lzo_forceinline
-#endif
-#if !defined(__lzo_noinline)
-#  define __lzo_noinline
-#endif
+#if (LZO_CFG_PGO)
+#  undef __lzo_likely
+#  undef __lzo_unlikely
+#  define __lzo_likely(e)       (e)
+#  define __lzo_unlikely(e)     (e)
+#endif
+
+#undef _
+#undef __
+#undef ___
+#undef ____
+#undef _p0
+#undef _p1
+#undef _p2
+#undef _p3
+#undef _p4
+#undef _s0
+#undef _s1
+#undef _s2
+#undef _s3
+#undef _s4
+#undef _ww
 
 
 /***********************************************************************
@@ -208,13 +220,10 @@
 
 #define LZO_HIGH(array)     ((lzo_uint) (sizeof(array)/sizeof(*(array))))
 
-/* this always fits into 16 bits */
+/* this always fits into 32 bits */
 #define LZO_SIZE(bits)      (1u << (bits))
 #define LZO_MASK(bits)      (LZO_SIZE(bits) - 1)
 
-#define LZO_LSIZE(bits)     (1ul << (bits))
-#define LZO_LMASK(bits)     (LZO_LSIZE(bits) - 1)
-
 #define LZO_USIZE(bits)     ((lzo_uint) 1 << (bits))
 #define LZO_UMASK(bits)     (LZO_USIZE(bits) - 1)
 
@@ -222,7 +231,7 @@
 #if 0
    /* 32*32 multiplies may be faster than 64*64 on some 64-bit machines,
     * but then we need extra casts from unsigned<->size_t */
-#  define DMUL(a,b) ((lzo_xint) ((lzo_uint32)(a) * (lzo_uint32)(b)))
+#  define DMUL(a,b) ((lzo_xint) ((lzo_uint32_t)(a) * (lzo_uint32_t)(b)))
 #else
 #  define DMUL(a,b) ((lzo_xint) ((a) * (b)))
 #endif
@@ -238,24 +247,89 @@
  * even if it is allowed by your system.
  */
 
-#if 1 && !defined(LZO_CFG_NO_UNALIGNED)
-#if 1 && (LZO_ARCH_AMD64 || LZO_ARCH_I386)
-#  if (LZO_SIZEOF_SHORT == 2)
-#    define LZO_UNALIGNED_OK_2
-#  endif
-#  if (LZO_SIZEOF_INT == 4)
-#    define LZO_UNALIGNED_OK_4
-#  endif
+#include "lzo_func.h"
+
+#ifndef UA_SET1
+#define UA_SET1             LZO_MEMOPS_SET1
 #endif
+#ifndef UA_SET2
+#define UA_SET2             LZO_MEMOPS_SET2
 #endif
-
-#if defined(LZO_UNALIGNED_OK_2)
-  LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(short) == 2)
+#ifndef UA_SET3
+#define UA_SET3             LZO_MEMOPS_SET3
 #endif
-#if defined(LZO_UNALIGNED_OK_4)
-  LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint32) == 4)
-#elif defined(LZO_ALIGNED_OK_4)
-  LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint32) == 4)
+#ifndef UA_SET4
+#define UA_SET4             LZO_MEMOPS_SET4
+#endif
+#ifndef UA_MOVE1
+#define UA_MOVE1            LZO_MEMOPS_MOVE1
+#endif
+#ifndef UA_MOVE2
+#define UA_MOVE2            LZO_MEMOPS_MOVE2
+#endif
+#ifndef UA_MOVE3
+#define UA_MOVE3            LZO_MEMOPS_MOVE3
+#endif
+#ifndef UA_MOVE4
+#define UA_MOVE4            LZO_MEMOPS_MOVE4
+#endif
+#ifndef UA_MOVE8
+#define UA_MOVE8            LZO_MEMOPS_MOVE8
+#endif
+#ifndef UA_COPY1
+#define UA_COPY1            LZO_MEMOPS_COPY1
+#endif
+#ifndef UA_COPY2
+#define UA_COPY2            LZO_MEMOPS_COPY2
+#endif
+#ifndef UA_COPY3
+#define UA_COPY3            LZO_MEMOPS_COPY3
+#endif
+#ifndef UA_COPY4
+#define UA_COPY4            LZO_MEMOPS_COPY4
+#endif
+#ifndef UA_COPY8
+#define UA_COPY8            LZO_MEMOPS_COPY8
+#endif
+#ifndef UA_COPYN
+#define UA_COPYN            LZO_MEMOPS_COPYN
+#endif
+#ifndef UA_COPYN_X
+#define UA_COPYN_X          LZO_MEMOPS_COPYN
+#endif
+#ifndef UA_GET_LE16
+#define UA_GET_LE16         LZO_MEMOPS_GET_LE16
+#endif
+#ifndef UA_GET_LE32
+#define UA_GET_LE32         LZO_MEMOPS_GET_LE32
+#endif
+#ifdef LZO_MEMOPS_GET_LE64
+#ifndef UA_GET_LE64
+#define UA_GET_LE64         LZO_MEMOPS_GET_LE64
+#endif
+#endif
+#ifndef UA_GET_NE16
+#define UA_GET_NE16         LZO_MEMOPS_GET_NE16
+#endif
+#ifndef UA_GET_NE32
+#define UA_GET_NE32         LZO_MEMOPS_GET_NE32
+#endif
+#ifdef LZO_MEMOPS_GET_NE64
+#ifndef UA_GET_NE64
+#define UA_GET_NE64         LZO_MEMOPS_GET_NE64
+#endif
+#endif
+#ifndef UA_PUT_LE16
+#define UA_PUT_LE16         LZO_MEMOPS_PUT_LE16
+#endif
+#ifndef UA_PUT_LE32
+#define UA_PUT_LE32         LZO_MEMOPS_PUT_LE32
+#endif
+#ifndef UA_PUT_NE16
+#define UA_PUT_NE16         LZO_MEMOPS_PUT_NE16
+#endif
+#ifndef UA_PUT_NE32
+#define UA_PUT_NE32         LZO_MEMOPS_PUT_NE32
 #endif
 
 
@@ -276,21 +350,13 @@
 
 
 /***********************************************************************
-// some globals
+//
 ************************************************************************/
 
-__LZO_EXTERN_C int __lzo_init_done;
-__LZO_EXTERN_C const char __lzo_copyright[];
 LZO_EXTERN(const lzo_bytep) lzo_copyright(void);
 
-
-/***********************************************************************
-//
-************************************************************************/
-
 #include "lzo_ptr.h"
 
-
 /* Generate compressed data in a deterministic way.
  * This is fully portable, and compression can be faster as well.
  * A reason NOT to be deterministic is when the block size is
@@ -298,20 +364,21 @@ LZO_EXTERN(const lzo_bytep) lzo_copyrigh
  * then the initialization of the dictionary becomes a relevant
  * magnitude for compression speed.
  */
-#define LZO_DETERMINISTIC
+#ifndef LZO_DETERMINISTIC
+#define LZO_DETERMINISTIC 1
+#endif
 
 
-#define LZO_DICT_USE_PTR
-#if 0 && (LZO_ARCH_I086)
-#  undef LZO_DICT_USE_PTR
+#ifndef LZO_DICT_USE_PTR
+#define LZO_DICT_USE_PTR 1
 #endif
 
-#if defined(LZO_DICT_USE_PTR)
+#if (LZO_DICT_USE_PTR)
 #  define lzo_dict_t    const lzo_bytep
-#  define lzo_dict_p    lzo_dict_t __LZO_MMODEL *
+#  define lzo_dict_p    lzo_dict_t *
 #else
 #  define lzo_dict_t    lzo_uint
-#  define lzo_dict_p    lzo_dict_t __LZO_MMODEL *
+#  define lzo_dict_p    lzo_dict_t *
 #endif
 
 
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo_crc.c syslinux-4.07b/lzo/src/lzo_crc.c
--- Syslinux-4.07a/lzo/src/lzo_crc.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo_crc.c	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -47,7 +35,7 @@
 // see http://www.zlib.org/
 ************************************************************************/
 
-static const lzo_uint32 lzo_crc32_table[256] = {
+static const lzo_uint32_t lzo_crc32_table[256] = {
   0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
   0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
   0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
@@ -103,7 +91,7 @@ static const lzo_uint32 lzo_crc32_table[
 };
 
 
-LZO_PUBLIC(const lzo_uint32p)
+LZO_PUBLIC(const lzo_uint32_tp)
 lzo_get_crc32_table(void)
 {
     return lzo_crc32_table;
@@ -112,7 +100,7 @@ lzo_get_crc32_table(void)
 
 #if 1
 #define LZO_DO1(buf,i) \
-    crc = table[((int)crc ^ buf[i]) & 0xff] ^ (crc >> 8)
+    crc = table[((unsigned)crc ^ buf[i]) & 0xff] ^ (crc >> 8)
 #else
 #define LZO_DO1(buf,i) \
     crc = table[(unsigned char)((unsigned char)crc ^ buf[i])] ^ (crc >> 8)
@@ -123,15 +111,15 @@ lzo_get_crc32_table(void)
 #define LZO_DO16(buf,i) LZO_DO8(buf,i); LZO_DO8(buf,i+8);
 
 
-LZO_PUBLIC(lzo_uint32)
-lzo_crc32(lzo_uint32 c, const lzo_bytep buf, lzo_uint len)
+LZO_PUBLIC(lzo_uint32_t)
+lzo_crc32(lzo_uint32_t c, const lzo_bytep buf, lzo_uint len)
 {
-    lzo_uint32 crc;
+    lzo_uint32_t crc;
 #undef table
 #if 1
 #  define table lzo_crc32_table
 #else
-   const lzo_uint32 * table = lzo_crc32_table;
+   const lzo_uint32_t * table = lzo_crc32_table;
 #endif
 
     if (buf == NULL)
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo_dict.h syslinux-4.07b/lzo/src/lzo_dict.h
--- Syslinux-4.07a/lzo/src/lzo_dict.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo_dict.h	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -45,7 +33,7 @@
 
 
 #ifndef __LZO_DICT_H
-#define __LZO_DICT_H
+#define __LZO_DICT_H 1
 
 #ifdef __cplusplus
 extern "C" {
@@ -97,10 +85,10 @@ extern "C" {
 #if (D_BITS != DL_BITS + DD_BITS)
 #  error "D_BITS does not match"
 #endif
-#if (D_BITS < 8 || D_BITS > 18)
+#if (D_BITS < 6 || D_BITS > 18)
 #  error "invalid D_BITS"
 #endif
-#if (DL_BITS < 8 || DL_BITS > 20)
+#if (DL_BITS < 6 || DL_BITS > 20)
 #  error "invalid DL_BITS"
 #endif
 #if (DD_BITS < 0 || DD_BITS > 6)
@@ -169,7 +157,7 @@ extern "C" {
 
 #elif (LZO_HASH == LZO_HASH_GZIP_INCREMENTAL)
    /* incremental hash like in gzip/zlib (deflate) */
-#  define __LZO_HASH_INCREMENTAL
+#  define __LZO_HASH_INCREMENTAL 1
 #  define DVAL_FIRST(dv,p)  dv = _DV_A((p),DL_SHIFT)
 #  define DVAL_NEXT(dv,p)   dv = (((dv) << DL_SHIFT) ^ p[2])
 #  define _DINDEX(dv,p)     (dv)
@@ -177,7 +165,7 @@ extern "C" {
 
 #elif (LZO_HASH == LZO_HASH_LZO_INCREMENTAL_A)
    /* incremental LZO hash version A */
-#  define __LZO_HASH_INCREMENTAL
+#  define __LZO_HASH_INCREMENTAL 1
 #  define DVAL_FIRST(dv,p)  dv = _DV_A((p),5)
 #  define DVAL_NEXT(dv,p) \
                 dv ^= (lzo_xint)(p[-1]) << (2*5); dv = (((dv) << 5) ^ p[2])
@@ -186,7 +174,7 @@ extern "C" {
 
 #elif (LZO_HASH == LZO_HASH_LZO_INCREMENTAL_B)
    /* incremental LZO hash version B */
-#  define __LZO_HASH_INCREMENTAL
+#  define __LZO_HASH_INCREMENTAL 1
 #  define DVAL_FIRST(dv,p)  dv = _DV_B((p),5)
 #  define DVAL_NEXT(dv,p) \
                 dv ^= p[-1]; dv = (((dv) >> 5) ^ ((lzo_xint)(p[2]) << (2*5)))
@@ -219,7 +207,12 @@ extern "C" {
 
 #if !defined(DVAL_ASSERT)
 #if defined(__LZO_HASH_INCREMENTAL) && !defined(NDEBUG)
-static void DVAL_ASSERT(lzo_xint dv, const lzo_bytep p)
+#if (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x020700ul) || LZO_CC_LLVM)
+static void __attribute__((__unused__))
+#else
+static void
+#endif
+DVAL_ASSERT(lzo_xint dv, const lzo_bytep p)
 {
     lzo_xint df;
     DVAL_FIRST(df,(p));
@@ -236,11 +229,11 @@ static void DVAL_ASSERT(lzo_xint dv, con
 // dictionary updating
 ************************************************************************/
 
-#if defined(LZO_DICT_USE_PTR)
+#if (LZO_DICT_USE_PTR)
 #  define DENTRY(p,in)                          (p)
 #  define GINDEX(m_pos,m_off,dict,dindex,in)    m_pos = dict[dindex]
 #else
-#  define DENTRY(p,in)                          ((lzo_uint) ((p)-(in)))
+#  define DENTRY(p,in)                          ((lzo_dict_t) pd(p, in))
 #  define GINDEX(m_pos,m_off,dict,dindex,in)    m_off = dict[dindex]
 #endif
 
@@ -267,7 +260,7 @@ static void DVAL_ASSERT(lzo_xint dv, con
 // test for a match
 ************************************************************************/
 
-#if defined(LZO_DICT_USE_PTR)
+#if (LZO_DICT_USE_PTR)
 
 /* m_pos is either NULL or a valid pointer */
 #define LZO_CHECK_MPOS_DET(m_pos,m_off,in,ip,max_offset) \
@@ -278,7 +271,7 @@ static void DVAL_ASSERT(lzo_xint dv, con
     (BOUNDS_CHECKING_OFF_IN_EXPR(( \
         m_pos = ip - (lzo_uint) PTR_DIFF(ip,m_pos), \
         PTR_LT(m_pos,in) || \
-        (m_off = (lzo_uint) PTR_DIFF(ip,m_pos)) <= 0 || \
+        (m_off = (lzo_uint) PTR_DIFF(ip,m_pos)) == 0 || \
          m_off > max_offset )))
 
 #else
@@ -296,7 +289,7 @@ static void DVAL_ASSERT(lzo_xint dv, con
 #endif
 
 
-#if defined(LZO_DETERMINISTIC)
+#if (LZO_DETERMINISTIC)
 #  define LZO_CHECK_MPOS    LZO_CHECK_MPOS_DET
 #else
 #  define LZO_CHECK_MPOS    LZO_CHECK_MPOS_NON_DET
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo_dll.ch syslinux-4.07b/lzo/src/lzo_dll.ch
--- Syslinux-4.07a/lzo/src/lzo_dll.ch	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo_dll.ch	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo_func.h syslinux-4.07b/lzo/src/lzo_func.h
--- Syslinux-4.07a/lzo/src/lzo_func.h	1970-01-01 01:00:00.000000000 +0100
+++ syslinux-4.07b/lzo/src/lzo_func.h	2023-02-08 12:45:19.367515476 +0100
@@ -0,0 +1,494 @@
+/* lzo_func.h -- functions
+
+   This file is part of the LZO real-time data compression library.
+
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
+   All Rights Reserved.
+
+   The LZO library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of
+   the License, or (at your option) any later version.
+
+   The LZO library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with the LZO library; see the file COPYING.
+   If not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+   Markus F.X.J. Oberhumer
+   <markus@oberhumer.com>
+   http://www.oberhumer.com/opensource/lzo/
+ */
+
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the library and is subject
+   to change.
+ */
+
+
+#ifndef __LZO_FUNC_H
+#define __LZO_FUNC_H 1
+
+
+/***********************************************************************
+// bitops
+************************************************************************/
+
+#if !defined(LZO_BITOPS_USE_ASM_BITSCAN) && !defined(LZO_BITOPS_USE_GNUC_BITSCAN) && !defined(LZO_BITOPS_USE_MSC_BITSCAN)
+#if 1 && (LZO_ARCH_AMD64) && (LZO_CC_GNUC && (LZO_CC_GNUC < 0x040000ul)) && (LZO_ASM_SYNTAX_GNUC)
+#define LZO_BITOPS_USE_ASM_BITSCAN 1
+#elif (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x030400ul) || (LZO_CC_INTELC_GNUC && (__INTEL_COMPILER >= 1000)) || (LZO_CC_LLVM && (!defined(__llvm_tools_version__) || (__llvm_tools_version__+0 >= 0x010500ul))))
+#define LZO_BITOPS_USE_GNUC_BITSCAN 1
+#elif (LZO_OS_WIN32 || LZO_OS_WIN64) && ((LZO_CC_INTELC_MSC && (__INTEL_COMPILER >= 1010)) || (LZO_CC_MSC && (_MSC_VER >= 1400)))
+#define LZO_BITOPS_USE_MSC_BITSCAN 1
+#if (LZO_CC_MSC) && (LZO_ARCH_AMD64 || LZO_ARCH_I386)
+#include <intrin.h>
+#endif
+#if (LZO_CC_MSC) && (LZO_ARCH_AMD64 || LZO_ARCH_I386)
+#pragma intrinsic(_BitScanReverse)
+#pragma intrinsic(_BitScanForward)
+#endif
+#if (LZO_CC_MSC) && (LZO_ARCH_AMD64)
+#pragma intrinsic(_BitScanReverse64)
+#pragma intrinsic(_BitScanForward64)
+#endif
+#endif
+#endif
+
+__lzo_static_forceinline unsigned lzo_bitops_ctlz32_func(lzo_uint32_t v)
+{
+#if (LZO_BITOPS_USE_MSC_BITSCAN) && (LZO_ARCH_AMD64 || LZO_ARCH_I386)
+    unsigned long r; (void) _BitScanReverse(&r, v); return (unsigned) r ^ 31;
+#define lzo_bitops_ctlz32(v)    lzo_bitops_ctlz32_func(v)
+#elif (LZO_BITOPS_USE_ASM_BITSCAN) && (LZO_ARCH_AMD64 || LZO_ARCH_I386) && (LZO_ASM_SYNTAX_GNUC)
+    lzo_uint32_t r;
+    __asm__("bsr %1,%0" : "=r" (r) : "rm" (v) __LZO_ASM_CLOBBER_LIST_CC);
+    return (unsigned) r ^ 31;
+#define lzo_bitops_ctlz32(v)    lzo_bitops_ctlz32_func(v)
+#elif (LZO_BITOPS_USE_GNUC_BITSCAN) && (LZO_SIZEOF_INT == 4)
+    unsigned r; r = (unsigned) __builtin_clz(v); return r;
+#define lzo_bitops_ctlz32(v)    ((unsigned) __builtin_clz(v))
+#else
+    LZO_UNUSED(v); return 0;
+#endif
+}
+
+#if defined(lzo_uint64_t)
+__lzo_static_forceinline unsigned lzo_bitops_ctlz64_func(lzo_uint64_t v)
+{
+#if (LZO_BITOPS_USE_MSC_BITSCAN) && (LZO_ARCH_AMD64)
+    unsigned long r; (void) _BitScanReverse64(&r, v); return (unsigned) r ^ 63;
+#define lzo_bitops_ctlz64(v)    lzo_bitops_ctlz64_func(v)
+#elif (LZO_BITOPS_USE_ASM_BITSCAN) && (LZO_ARCH_AMD64) && (LZO_ASM_SYNTAX_GNUC)
+    lzo_uint64_t r;
+    __asm__("bsr %1,%0" : "=r" (r) : "rm" (v) __LZO_ASM_CLOBBER_LIST_CC);
+    return (unsigned) r ^ 63;
+#define lzo_bitops_ctlz64(v)    lzo_bitops_ctlz64_func(v)
+#elif (LZO_BITOPS_USE_GNUC_BITSCAN) && (LZO_SIZEOF_LONG == 8) && (LZO_WORDSIZE >= 8)
+    unsigned r; r = (unsigned) __builtin_clzl(v); return r;
+#define lzo_bitops_ctlz64(v)    ((unsigned) __builtin_clzl(v))
+#elif (LZO_BITOPS_USE_GNUC_BITSCAN) && (LZO_SIZEOF_LONG_LONG == 8) && (LZO_WORDSIZE >= 8)
+    unsigned r; r = (unsigned) __builtin_clzll(v); return r;
+#define lzo_bitops_ctlz64(v)    ((unsigned) __builtin_clzll(v))
+#else
+    LZO_UNUSED(v); return 0;
+#endif
+}
+#endif
+
+__lzo_static_forceinline unsigned lzo_bitops_cttz32_func(lzo_uint32_t v)
+{
+#if (LZO_BITOPS_USE_MSC_BITSCAN) && (LZO_ARCH_AMD64 || LZO_ARCH_I386)
+    unsigned long r; (void) _BitScanForward(&r, v); return (unsigned) r;
+#define lzo_bitops_cttz32(v)    lzo_bitops_cttz32_func(v)
+#elif (LZO_BITOPS_USE_ASM_BITSCAN) && (LZO_ARCH_AMD64 || LZO_ARCH_I386) && (LZO_ASM_SYNTAX_GNUC)
+    lzo_uint32_t r;
+    __asm__("bsf %1,%0" : "=r" (r) : "rm" (v) __LZO_ASM_CLOBBER_LIST_CC);
+    return (unsigned) r;
+#define lzo_bitops_cttz32(v)    lzo_bitops_cttz32_func(v)
+#elif (LZO_BITOPS_USE_GNUC_BITSCAN) && (LZO_SIZEOF_INT >= 4)
+    unsigned r; r = (unsigned) __builtin_ctz(v); return r;
+#define lzo_bitops_cttz32(v)    ((unsigned) __builtin_ctz(v))
+#else
+    LZO_UNUSED(v); return 0;
+#endif
+}
+
+#if defined(lzo_uint64_t)
+__lzo_static_forceinline unsigned lzo_bitops_cttz64_func(lzo_uint64_t v)
+{
+#if (LZO_BITOPS_USE_MSC_BITSCAN) && (LZO_ARCH_AMD64)
+    unsigned long r; (void) _BitScanForward64(&r, v); return (unsigned) r;
+#define lzo_bitops_cttz64(v)    lzo_bitops_cttz64_func(v)
+#elif (LZO_BITOPS_USE_ASM_BITSCAN) && (LZO_ARCH_AMD64) && (LZO_ASM_SYNTAX_GNUC)
+    lzo_uint64_t r;
+    __asm__("bsf %1,%0" : "=r" (r) : "rm" (v) __LZO_ASM_CLOBBER_LIST_CC);
+    return (unsigned) r;
+#define lzo_bitops_cttz64(v)    lzo_bitops_cttz64_func(v)
+#elif (LZO_BITOPS_USE_GNUC_BITSCAN) && (LZO_SIZEOF_LONG >= 8) && (LZO_WORDSIZE >= 8)
+    unsigned r; r = (unsigned) __builtin_ctzl(v); return r;
+#define lzo_bitops_cttz64(v)    ((unsigned) __builtin_ctzl(v))
+#elif (LZO_BITOPS_USE_GNUC_BITSCAN) && (LZO_SIZEOF_LONG_LONG >= 8) && (LZO_WORDSIZE >= 8)
+    unsigned r; r = (unsigned) __builtin_ctzll(v); return r;
+#define lzo_bitops_cttz64(v)    ((unsigned) __builtin_ctzll(v))
+#else
+    LZO_UNUSED(v); return 0;
+#endif
+}
+#endif
+
+#if 1 && (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || (LZO_CC_GNUC >= 0x020700ul) || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
+static void __attribute__((__unused__))
+#else
+__lzo_static_forceinline void
+#endif
+lzo_bitops_unused_funcs(void)
+{
+    LZO_UNUSED_FUNC(lzo_bitops_ctlz32_func);
+    LZO_UNUSED_FUNC(lzo_bitops_cttz32_func);
+#if defined(lzo_uint64_t)
+    LZO_UNUSED_FUNC(lzo_bitops_ctlz64_func);
+    LZO_UNUSED_FUNC(lzo_bitops_cttz64_func);
+#endif
+    LZO_UNUSED_FUNC(lzo_bitops_unused_funcs);
+}
+
+
+/***********************************************************************
+// memops
+************************************************************************/
+
+#if defined(__lzo_alignof) && !(LZO_CFG_NO_UNALIGNED)
+#ifndef __lzo_memops_tcheck
+#define __lzo_memops_tcheck(t,a,b) ((void)0, sizeof(t) == (a) && __lzo_alignof(t) == (b))
+#endif
+#endif
+#ifndef lzo_memops_TU0p
+#define lzo_memops_TU0p void __LZO_MMODEL *
+#endif
+#ifndef lzo_memops_TU1p
+#define lzo_memops_TU1p unsigned char __LZO_MMODEL *
+#endif
+#ifndef lzo_memops_TU2p
+#if (LZO_OPT_UNALIGNED16)
+typedef lzo_uint16_t __lzo_may_alias lzo_memops_TU2;
+#define lzo_memops_TU2p volatile lzo_memops_TU2 *
+#elif defined(__lzo_byte_struct)
+__lzo_byte_struct(lzo_memops_TU2_struct,2)
+typedef struct lzo_memops_TU2_struct lzo_memops_TU2;
+#else
+struct lzo_memops_TU2_struct { unsigned char a[2]; } __lzo_may_alias;
+typedef struct lzo_memops_TU2_struct lzo_memops_TU2;
+#endif
+#ifndef lzo_memops_TU2p
+#define lzo_memops_TU2p lzo_memops_TU2 *
+#endif
+#endif
+#ifndef lzo_memops_TU4p
+#if (LZO_OPT_UNALIGNED32)
+typedef lzo_uint32_t __lzo_may_alias lzo_memops_TU4;
+#define lzo_memops_TU4p volatile lzo_memops_TU4 __LZO_MMODEL *
+#elif defined(__lzo_byte_struct)
+__lzo_byte_struct(lzo_memops_TU4_struct,4)
+typedef struct lzo_memops_TU4_struct lzo_memops_TU4;
+#else
+struct lzo_memops_TU4_struct { unsigned char a[4]; } __lzo_may_alias;
+typedef struct lzo_memops_TU4_struct lzo_memops_TU4;
+#endif
+#ifndef lzo_memops_TU4p
+#define lzo_memops_TU4p lzo_memops_TU4 __LZO_MMODEL *
+#endif
+#endif
+#ifndef lzo_memops_TU8p
+#if (LZO_OPT_UNALIGNED64)
+typedef lzo_uint64_t __lzo_may_alias lzo_memops_TU8;
+#define lzo_memops_TU8p volatile lzo_memops_TU8 __LZO_MMODEL *
+#elif defined(__lzo_byte_struct)
+__lzo_byte_struct(lzo_memops_TU8_struct,8)
+typedef struct lzo_memops_TU8_struct lzo_memops_TU8;
+#else
+struct lzo_memops_TU8_struct { unsigned char a[8]; } __lzo_may_alias;
+typedef struct lzo_memops_TU8_struct lzo_memops_TU8;
+#endif
+#ifndef lzo_memops_TU8p
+#define lzo_memops_TU8p lzo_memops_TU8 __LZO_MMODEL *
+#endif
+#endif
+#ifndef lzo_memops_set_TU1p
+#define lzo_memops_set_TU1p     volatile lzo_memops_TU1p
+#endif
+#ifndef lzo_memops_move_TU1p
+#define lzo_memops_move_TU1p    lzo_memops_TU1p
+#endif
+#define LZO_MEMOPS_SET1(dd,cc) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_set_TU1p d__1 = (lzo_memops_set_TU1p) (lzo_memops_TU0p) (dd); \
+    d__1[0] = LZO_BYTE(cc); \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_SET2(dd,cc) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_set_TU1p d__2 = (lzo_memops_set_TU1p) (lzo_memops_TU0p) (dd); \
+    d__2[0] = LZO_BYTE(cc); d__2[1] = LZO_BYTE(cc); \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_SET3(dd,cc) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_set_TU1p d__3 = (lzo_memops_set_TU1p) (lzo_memops_TU0p) (dd); \
+    d__3[0] = LZO_BYTE(cc); d__3[1] = LZO_BYTE(cc); d__3[2] = LZO_BYTE(cc); \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_SET4(dd,cc) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_set_TU1p d__4 = (lzo_memops_set_TU1p) (lzo_memops_TU0p) (dd); \
+    d__4[0] = LZO_BYTE(cc); d__4[1] = LZO_BYTE(cc); d__4[2] = LZO_BYTE(cc); d__4[3] = LZO_BYTE(cc); \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_MOVE1(dd,ss) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_move_TU1p d__1 = (lzo_memops_move_TU1p) (lzo_memops_TU0p) (dd); \
+    const lzo_memops_move_TU1p s__1 = (const lzo_memops_move_TU1p) (const lzo_memops_TU0p) (ss); \
+    d__1[0] = s__1[0]; \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_MOVE2(dd,ss) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_move_TU1p d__2 = (lzo_memops_move_TU1p) (lzo_memops_TU0p) (dd); \
+    const lzo_memops_move_TU1p s__2 = (const lzo_memops_move_TU1p) (const lzo_memops_TU0p) (ss); \
+    d__2[0] = s__2[0]; d__2[1] = s__2[1]; \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_MOVE3(dd,ss) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_move_TU1p d__3 = (lzo_memops_move_TU1p) (lzo_memops_TU0p) (dd); \
+    const lzo_memops_move_TU1p s__3 = (const lzo_memops_move_TU1p) (const lzo_memops_TU0p) (ss); \
+    d__3[0] = s__3[0]; d__3[1] = s__3[1]; d__3[2] = s__3[2]; \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_MOVE4(dd,ss) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_move_TU1p d__4 = (lzo_memops_move_TU1p) (lzo_memops_TU0p) (dd); \
+    const lzo_memops_move_TU1p s__4 = (const lzo_memops_move_TU1p) (const lzo_memops_TU0p) (ss); \
+    d__4[0] = s__4[0]; d__4[1] = s__4[1]; d__4[2] = s__4[2]; d__4[3] = s__4[3]; \
+    LZO_BLOCK_END
+#define LZO_MEMOPS_MOVE8(dd,ss) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_move_TU1p d__8 = (lzo_memops_move_TU1p) (lzo_memops_TU0p) (dd); \
+    const lzo_memops_move_TU1p s__8 = (const lzo_memops_move_TU1p) (const lzo_memops_TU0p) (ss); \
+    d__8[0] = s__8[0]; d__8[1] = s__8[1]; d__8[2] = s__8[2]; d__8[3] = s__8[3]; \
+    d__8[4] = s__8[4]; d__8[5] = s__8[5]; d__8[6] = s__8[6]; d__8[7] = s__8[7]; \
+    LZO_BLOCK_END
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(*(lzo_memops_TU1p)0)==1)
+#define LZO_MEMOPS_COPY1(dd,ss) LZO_MEMOPS_MOVE1(dd,ss)
+#if (LZO_OPT_UNALIGNED16)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(*(lzo_memops_TU2p)0)==2)
+#define LZO_MEMOPS_COPY2(dd,ss) \
+    * (lzo_memops_TU2p) (lzo_memops_TU0p) (dd) = * (const lzo_memops_TU2p) (const lzo_memops_TU0p) (ss)
+#elif defined(__lzo_memops_tcheck)
+#define LZO_MEMOPS_COPY2(dd,ss) \
+    LZO_BLOCK_BEGIN if (__lzo_memops_tcheck(lzo_memops_TU2,2,1)) { \
+        * (lzo_memops_TU2p) (lzo_memops_TU0p) (dd) = * (const lzo_memops_TU2p) (const lzo_memops_TU0p) (ss); \
+    } else { LZO_MEMOPS_MOVE2(dd,ss); } LZO_BLOCK_END
+#else
+#define LZO_MEMOPS_COPY2(dd,ss) LZO_MEMOPS_MOVE2(dd,ss)
+#endif
+#if (LZO_OPT_UNALIGNED32)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(*(lzo_memops_TU4p)0)==4)
+#define LZO_MEMOPS_COPY4(dd,ss) \
+    * (lzo_memops_TU4p) (lzo_memops_TU0p) (dd) = * (const lzo_memops_TU4p) (const lzo_memops_TU0p) (ss)
+#elif defined(__lzo_memops_tcheck)
+#define LZO_MEMOPS_COPY4(dd,ss) \
+    LZO_BLOCK_BEGIN if (__lzo_memops_tcheck(lzo_memops_TU4,4,1)) { \
+        * (lzo_memops_TU4p) (lzo_memops_TU0p) (dd) = * (const lzo_memops_TU4p) (const lzo_memops_TU0p) (ss); \
+    } else { LZO_MEMOPS_MOVE4(dd,ss); } LZO_BLOCK_END
+#else
+#define LZO_MEMOPS_COPY4(dd,ss) LZO_MEMOPS_MOVE4(dd,ss)
+#endif
+#if (LZO_WORDSIZE != 8)
+#define LZO_MEMOPS_COPY8(dd,ss) \
+    LZO_BLOCK_BEGIN LZO_MEMOPS_COPY4(dd,ss); LZO_MEMOPS_COPY4((lzo_memops_TU1p)(lzo_memops_TU0p)(dd)+4,(const lzo_memops_TU1p)(const lzo_memops_TU0p)(ss)+4); LZO_BLOCK_END
+#else
+#if (LZO_OPT_UNALIGNED64)
+LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(*(lzo_memops_TU8p)0)==8)
+#define LZO_MEMOPS_COPY8(dd,ss) \
+    * (lzo_memops_TU8p) (lzo_memops_TU0p) (dd) = * (const lzo_memops_TU8p) (const lzo_memops_TU0p) (ss)
+#elif (LZO_OPT_UNALIGNED32)
+#define LZO_MEMOPS_COPY8(dd,ss) \
+    LZO_BLOCK_BEGIN LZO_MEMOPS_COPY4(dd,ss); LZO_MEMOPS_COPY4((lzo_memops_TU1p)(lzo_memops_TU0p)(dd)+4,(const lzo_memops_TU1p)(const lzo_memops_TU0p)(ss)+4); LZO_BLOCK_END
+#elif defined(__lzo_memops_tcheck)
+#define LZO_MEMOPS_COPY8(dd,ss) \
+    LZO_BLOCK_BEGIN if (__lzo_memops_tcheck(lzo_memops_TU8,8,1)) { \
+        * (lzo_memops_TU8p) (lzo_memops_TU0p) (dd) = * (const lzo_memops_TU8p) (const lzo_memops_TU0p) (ss); \
+    } else { LZO_MEMOPS_MOVE8(dd,ss); } LZO_BLOCK_END
+#else
+#define LZO_MEMOPS_COPY8(dd,ss) LZO_MEMOPS_MOVE8(dd,ss)
+#endif
+#endif
+#define LZO_MEMOPS_COPYN(dd,ss,nn) \
+    LZO_BLOCK_BEGIN \
+    lzo_memops_TU1p d__n = (lzo_memops_TU1p) (lzo_memops_TU0p) (dd); \
+    const lzo_memops_TU1p s__n = (const lzo_memops_TU1p) (const lzo_memops_TU0p) (ss); \
+    lzo_uint n__n = (nn); \
+    while ((void)0, n__n >= 8) { LZO_MEMOPS_COPY8(d__n, s__n); d__n += 8; s__n += 8; n__n -= 8; } \
+    if ((void)0, n__n >= 4) { LZO_MEMOPS_COPY4(d__n, s__n); d__n += 4; s__n += 4; n__n -= 4; } \
+    if ((void)0, n__n > 0) do { *d__n++ = *s__n++; } while (--n__n > 0); \
+    LZO_BLOCK_END
+
+__lzo_static_forceinline lzo_uint16_t lzo_memops_get_le16(const lzo_voidp ss)
+{
+    lzo_uint16_t v;
+#if (LZO_ABI_LITTLE_ENDIAN)
+    LZO_MEMOPS_COPY2(&v, ss);
+#elif (LZO_OPT_UNALIGNED16 && LZO_ARCH_POWERPC && LZO_ABI_BIG_ENDIAN) && (LZO_ASM_SYNTAX_GNUC)
+    const lzo_memops_TU2p s = (const lzo_memops_TU2p) ss;
+    unsigned long vv;
+    __asm__("lhbrx %0,0,%1" : "=r" (vv) : "r" (s), "m" (*s));
+    v = (lzo_uint16_t) vv;
+#else
+    const lzo_memops_TU1p s = (const lzo_memops_TU1p) ss;
+    v = (lzo_uint16_t) (((lzo_uint16_t)s[0]) | ((lzo_uint16_t)s[1] << 8));
+#endif
+    return v;
+}
+#if (LZO_OPT_UNALIGNED16) && (LZO_ABI_LITTLE_ENDIAN)
+#define LZO_MEMOPS_GET_LE16(ss)    * (const lzo_memops_TU2p) (const lzo_memops_TU0p) (ss)
+#else
+#define LZO_MEMOPS_GET_LE16(ss)    lzo_memops_get_le16(ss)
+#endif
+
+__lzo_static_forceinline lzo_uint32_t lzo_memops_get_le32(const lzo_voidp ss)
+{
+    lzo_uint32_t v;
+#if (LZO_ABI_LITTLE_ENDIAN)
+    LZO_MEMOPS_COPY4(&v, ss);
+#elif (LZO_OPT_UNALIGNED32 && LZO_ARCH_POWERPC && LZO_ABI_BIG_ENDIAN) && (LZO_ASM_SYNTAX_GNUC)
+    const lzo_memops_TU4p s = (const lzo_memops_TU4p) ss;
+    unsigned long vv;
+    __asm__("lwbrx %0,0,%1" : "=r" (vv) : "r" (s), "m" (*s));
+    v = (lzo_uint32_t) vv;
+#else
+    const lzo_memops_TU1p s = (const lzo_memops_TU1p) ss;
+    v = (lzo_uint32_t) (((lzo_uint32_t)s[0] << 24) | ((lzo_uint32_t)s[1] << 16) | ((lzo_uint32_t)s[2] << 8) | ((lzo_uint32_t)s[3]));
+#endif
+    return v;
+}
+#if (LZO_OPT_UNALIGNED32) && (LZO_ABI_LITTLE_ENDIAN)
+#define LZO_MEMOPS_GET_LE32(ss)    * (const lzo_memops_TU4p) (const lzo_memops_TU0p) (ss)
+#else
+#define LZO_MEMOPS_GET_LE32(ss)    lzo_memops_get_le32(ss)
+#endif
+
+#if (LZO_OPT_UNALIGNED64) && (LZO_ABI_LITTLE_ENDIAN)
+#define LZO_MEMOPS_GET_LE64(ss)    * (const lzo_memops_TU8p) (const lzo_memops_TU0p) (ss)
+#endif
+
+__lzo_static_forceinline lzo_uint16_t lzo_memops_get_ne16(const lzo_voidp ss)
+{
+    lzo_uint16_t v;
+    LZO_MEMOPS_COPY2(&v, ss);
+    return v;
+}
+#if (LZO_OPT_UNALIGNED16)
+#define LZO_MEMOPS_GET_NE16(ss)    * (const lzo_memops_TU2p) (const lzo_memops_TU0p) (ss)
+#else
+#define LZO_MEMOPS_GET_NE16(ss)    lzo_memops_get_ne16(ss)
+#endif
+
+__lzo_static_forceinline lzo_uint32_t lzo_memops_get_ne32(const lzo_voidp ss)
+{
+    lzo_uint32_t v;
+    LZO_MEMOPS_COPY4(&v, ss);
+    return v;
+}
+#if (LZO_OPT_UNALIGNED32)
+#define LZO_MEMOPS_GET_NE32(ss)    * (const lzo_memops_TU4p) (const lzo_memops_TU0p) (ss)
+#else
+#define LZO_MEMOPS_GET_NE32(ss)    lzo_memops_get_ne32(ss)
+#endif
+
+#if (LZO_OPT_UNALIGNED64)
+#define LZO_MEMOPS_GET_NE64(ss)    * (const lzo_memops_TU8p) (const lzo_memops_TU0p) (ss)
+#endif
+
+__lzo_static_forceinline void lzo_memops_put_le16(lzo_voidp dd, lzo_uint16_t vv)
+{
+#if (LZO_ABI_LITTLE_ENDIAN)
+    LZO_MEMOPS_COPY2(dd, &vv);
+#elif (LZO_OPT_UNALIGNED16 && LZO_ARCH_POWERPC && LZO_ABI_BIG_ENDIAN) && (LZO_ASM_SYNTAX_GNUC)
+    lzo_memops_TU2p d = (lzo_memops_TU2p) dd;
+    unsigned long v = vv;
+    __asm__("sthbrx %2,0,%1" : "=m" (*d) : "r" (d), "r" (v));
+#else
+    lzo_memops_TU1p d = (lzo_memops_TU1p) dd;
+    d[0] = LZO_BYTE((vv      ) & 0xff);
+    d[1] = LZO_BYTE((vv >>  8) & 0xff);
+#endif
+}
+#if (LZO_OPT_UNALIGNED16) && (LZO_ABI_LITTLE_ENDIAN)
+#define LZO_MEMOPS_PUT_LE16(dd,vv) (* (lzo_memops_TU2p) (lzo_memops_TU0p) (dd) = (vv))
+#else
+#define LZO_MEMOPS_PUT_LE16(dd,vv) lzo_memops_put_le16(dd,vv)
+#endif
+
+__lzo_static_forceinline void lzo_memops_put_le32(lzo_voidp dd, lzo_uint32_t vv)
+{
+#if (LZO_ABI_LITTLE_ENDIAN)
+    LZO_MEMOPS_COPY4(dd, &vv);
+#elif (LZO_OPT_UNALIGNED32 && LZO_ARCH_POWERPC && LZO_ABI_BIG_ENDIAN) && (LZO_ASM_SYNTAX_GNUC)
+    lzo_memops_TU4p d = (lzo_memops_TU4p) dd;
+    unsigned long v = vv;
+    __asm__("stwbrx %2,0,%1" : "=m" (*d) : "r" (d), "r" (v));
+#else
+    lzo_memops_TU1p d = (lzo_memops_TU1p) dd;
+    d[0] = LZO_BYTE((vv      ) & 0xff);
+    d[1] = LZO_BYTE((vv >>  8) & 0xff);
+    d[2] = LZO_BYTE((vv >> 16) & 0xff);
+    d[3] = LZO_BYTE((vv >> 24) & 0xff);
+#endif
+}
+#if (LZO_OPT_UNALIGNED32) && (LZO_ABI_LITTLE_ENDIAN)
+#define LZO_MEMOPS_PUT_LE32(dd,vv) (* (lzo_memops_TU4p) (lzo_memops_TU0p) (dd) = (vv))
+#else
+#define LZO_MEMOPS_PUT_LE32(dd,vv) lzo_memops_put_le32(dd,vv)
+#endif
+
+__lzo_static_forceinline void lzo_memops_put_ne16(lzo_voidp dd, lzo_uint16_t vv)
+{
+    LZO_MEMOPS_COPY2(dd, &vv);
+}
+#if (LZO_OPT_UNALIGNED16)
+#define LZO_MEMOPS_PUT_NE16(dd,vv) (* (lzo_memops_TU2p) (lzo_memops_TU0p) (dd) = (vv))
+#else
+#define LZO_MEMOPS_PUT_NE16(dd,vv) lzo_memops_put_ne16(dd,vv)
+#endif
+
+__lzo_static_forceinline void lzo_memops_put_ne32(lzo_voidp dd, lzo_uint32_t vv)
+{
+    LZO_MEMOPS_COPY4(dd, &vv);
+}
+#if (LZO_OPT_UNALIGNED32)
+#define LZO_MEMOPS_PUT_NE32(dd,vv) (* (lzo_memops_TU4p) (lzo_memops_TU0p) (dd) = (vv))
+#else
+#define LZO_MEMOPS_PUT_NE32(dd,vv) lzo_memops_put_ne32(dd,vv)
+#endif
+
+#if 1 && (LZO_CC_ARMCC_GNUC || LZO_CC_CLANG || (LZO_CC_GNUC >= 0x020700ul) || LZO_CC_INTELC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
+static void __attribute__((__unused__))
+#else
+__lzo_static_forceinline void
+#endif
+lzo_memops_unused_funcs(void)
+{
+    LZO_UNUSED_FUNC(lzo_memops_get_le16);
+    LZO_UNUSED_FUNC(lzo_memops_get_le32);
+    LZO_UNUSED_FUNC(lzo_memops_get_ne16);
+    LZO_UNUSED_FUNC(lzo_memops_get_ne32);
+    LZO_UNUSED_FUNC(lzo_memops_put_le16);
+    LZO_UNUSED_FUNC(lzo_memops_put_le32);
+    LZO_UNUSED_FUNC(lzo_memops_put_ne16);
+    LZO_UNUSED_FUNC(lzo_memops_put_ne32);
+    LZO_UNUSED_FUNC(lzo_memops_unused_funcs);
+}
+
+#endif /* already included */
+
+/* vim:set ts=4 sw=4 et: */
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo_init.c syslinux-4.07b/lzo/src/lzo_init.c
--- Syslinux-4.07a/lzo/src/lzo_init.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo_init.c	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -56,65 +44,130 @@
 
 #if !defined(__LZO_IN_MINILZO)
 
-#define ACC_WANT_ACC_CHK_CH 1
-#undef ACCCHK_ASSERT
-#include "miniacc.h"
+#define LZO_WANT_ACC_CHK_CH 1
+#undef LZOCHK_ASSERT
+#include "lzo_supp.h"
 
-    ACCCHK_ASSERT_IS_SIGNED_T(lzo_int)
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_uint)
-
-    ACCCHK_ASSERT_IS_SIGNED_T(lzo_int32)
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_uint32)
-    ACCCHK_ASSERT((LZO_UINT32_C(1) << (int)(8*sizeof(LZO_UINT32_C(1))-1)) > 0)
-    ACCCHK_ASSERT(sizeof(lzo_uint32) >= 4)
-
-#if !defined(__LZO_UINTPTR_T_IS_POINTER)
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_uintptr_t)
+    LZOCHK_ASSERT((LZO_UINT32_C(1) << (int)(8*sizeof(LZO_UINT32_C(1))-1)) > 0)
+    LZOCHK_ASSERT_IS_SIGNED_T(lzo_int)
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_uint)
+#if !(__LZO_UINTPTR_T_IS_POINTER)
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_uintptr_t)
 #endif
-    ACCCHK_ASSERT(sizeof(lzo_uintptr_t) >= sizeof(lzo_voidp))
-
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_xint)
-    ACCCHK_ASSERT(sizeof(lzo_xint) >= sizeof(lzo_uint32))
-    ACCCHK_ASSERT(sizeof(lzo_xint) >= sizeof(lzo_uint))
-    ACCCHK_ASSERT(sizeof(lzo_xint) == sizeof(lzo_uint32) || sizeof(lzo_xint) == sizeof(lzo_uint))
+    LZOCHK_ASSERT(sizeof(lzo_uintptr_t) >= sizeof(lzo_voidp))
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_xint)
 
 #endif
-#undef ACCCHK_ASSERT
+#undef LZOCHK_ASSERT
 
 
 /***********************************************************************
 //
 ************************************************************************/
 
+union lzo_config_check_union {
+    lzo_uint a[2];
+    unsigned char b[2*LZO_MAX(8,sizeof(lzo_uint))];
+#if defined(lzo_uint64_t)
+    lzo_uint64_t c[2];
+#endif
+};
+
+
+#if 0
+#define u2p(ptr,off) ((lzo_voidp) (((lzo_bytep)(lzo_voidp)(ptr)) + (off)))
+#else
+static __lzo_noinline lzo_voidp u2p(lzo_voidp ptr, lzo_uint off)
+{
+    return (lzo_voidp) ((lzo_bytep) ptr + off);
+}
+#endif
+
+
 LZO_PUBLIC(int)
 _lzo_config_check(void)
 {
-    lzo_bool r = 1;
-    union { unsigned char c[2*sizeof(lzo_xint)]; lzo_xint l[2]; } u;
-    lzo_uintptr_t p;
-
-#if !defined(LZO_CFG_NO_CONFIG_CHECK)
-#if defined(LZO_ABI_BIG_ENDIAN)
-    u.l[0] = u.l[1] = 0; u.c[sizeof(lzo_xint) - 1] = 128;
-    r &= (u.l[0] == 128);
-#endif
-#if defined(LZO_ABI_LITTLE_ENDIAN)
-    u.l[0] = u.l[1] = 0; u.c[0] = 128;
-    r &= (u.l[0] == 128);
-#endif
-#if defined(LZO_UNALIGNED_OK_2)
-    p = (lzo_uintptr_t) (const lzo_voidp) &u.c[0];
-    u.l[0] = u.l[1] = 0;
-    r &= ((* (const lzo_ushortp) (p+1)) == 0);
-#endif
-#if defined(LZO_UNALIGNED_OK_4)
-    p = (lzo_uintptr_t) (const lzo_voidp) &u.c[0];
-    u.l[0] = u.l[1] = 0;
-    r &= ((* (const lzo_uint32p) (p+1)) == 0);
+#if (LZO_CC_CLANG && (LZO_CC_CLANG >= 0x030100ul && LZO_CC_CLANG < 0x030300ul))
+# if 0
+    /* work around a clang 3.1 and clang 3.2 compiler bug; clang 3.3 and 3.4 work */
+    volatile
+# endif
+#endif
+    union lzo_config_check_union u;
+    lzo_voidp p;
+    unsigned r = 1;
+
+    u.a[0] = u.a[1] = 0;
+    p = u2p(&u, 0);
+    r &= ((* (lzo_bytep) p) == 0);
+#if !(LZO_CFG_NO_CONFIG_CHECK)
+#if (LZO_ABI_BIG_ENDIAN)
+    u.a[0] = u.a[1] = 0; u.b[sizeof(lzo_uint) - 1] = 128;
+    p = u2p(&u, 0);
+    r &= ((* (lzo_uintp) p) == 128);
+#endif
+#if (LZO_ABI_LITTLE_ENDIAN)
+    u.a[0] = u.a[1] = 0; u.b[0] = 128;
+    p = u2p(&u, 0);
+    r &= ((* (lzo_uintp) p) == 128);
+#endif
+    u.a[0] = u.a[1] = 0;
+    u.b[0] = 1; u.b[3] = 2;
+    p = u2p(&u, 1);
+    r &= UA_GET_NE16(p) == 0;
+    r &= UA_GET_LE16(p) == 0;
+    u.b[1] = 128;
+    r &= UA_GET_LE16(p) == 128;
+    u.a[0] = u.a[1] = 0;
+    u.b[0] = 3; u.b[5] = 4;
+    p = u2p(&u, 1);
+    r &= UA_GET_NE32(p) == 0;
+    r &= UA_GET_LE32(p) == 0;
+    u.b[1] = 128;
+    r &= UA_GET_LE32(p) == 128;
+#if defined(UA_GET_NE64)
+    u.c[0] = u.c[1] = 0;
+    u.b[0] = 5; u.b[9] = 6;
+    p = u2p(&u, 1);
+    u.c[0] = u.c[1] = 0;
+    r &= UA_GET_NE64(p) == 0;
+#if defined(UA_GET_LE64)
+    r &= UA_GET_LE64(p) == 0;
+    u.b[1] = 128;
+    r &= UA_GET_LE64(p) == 128;
+#endif
+#endif
+#if defined(lzo_bitops_ctlz32)
+    { unsigned i = 0; lzo_uint32_t v;
+    for (v = 1; v != 0 && r == 1; v <<= 1, i++) {
+        r &= lzo_bitops_ctlz32(v) == 31 - i;
+        r &= lzo_bitops_ctlz32_func(v) == 31 - i;
+    }}
+#endif
+#if defined(lzo_bitops_ctlz64)
+    { unsigned i = 0; lzo_uint64_t v;
+    for (v = 1; v != 0 && r == 1; v <<= 1, i++) {
+        r &= lzo_bitops_ctlz64(v) == 63 - i;
+        r &= lzo_bitops_ctlz64_func(v) == 63 - i;
+    }}
+#endif
+#if defined(lzo_bitops_cttz32)
+    { unsigned i = 0; lzo_uint32_t v;
+    for (v = 1; v != 0 && r == 1; v <<= 1, i++) {
+        r &= lzo_bitops_cttz32(v) == i;
+        r &= lzo_bitops_cttz32_func(v) == i;
+    }}
+#endif
+#if defined(lzo_bitops_cttz64)
+    { unsigned i = 0; lzo_uint64_t v;
+    for (v = 1; v != 0 && r == 1; v <<= 1, i++) {
+        r &= lzo_bitops_cttz64(v) == i;
+        r &= lzo_bitops_cttz64_func(v) == i;
+    }}
 #endif
 #endif
+    LZO_UNUSED_FUNC(lzo_bitops_unused_funcs);
 
-    LZO_UNUSED(u); LZO_UNUSED(p);
     return r == 1 ? LZO_E_OK : LZO_E_ERROR;
 }
 
@@ -123,8 +176,6 @@ _lzo_config_check(void)
 //
 ************************************************************************/
 
-int __lzo_init_done = 0;
-
 LZO_PUBLIC(int)
 __lzo_init_v2(unsigned v, int s1, int s2, int s3, int s4, int s5,
                           int s6, int s7, int s8, int s9)
@@ -134,14 +185,12 @@ __lzo_init_v2(unsigned v, int s1, int s2
 #if defined(__LZO_IN_MINILZO)
 #elif (LZO_CC_MSC && ((_MSC_VER) < 700))
 #else
-#define ACC_WANT_ACC_CHK_CH 1
-#undef ACCCHK_ASSERT
-#define ACCCHK_ASSERT(expr)  LZO_COMPILE_TIME_ASSERT(expr)
-#include "miniacc.h"
+#define LZO_WANT_ACC_CHK_CH 1
+#undef LZOCHK_ASSERT
+#define LZOCHK_ASSERT(expr)  LZO_COMPILE_TIME_ASSERT(expr)
+#include "lzo_supp.h"
 #endif
-#undef ACCCHK_ASSERT
-
-    __lzo_init_done = 1;
+#undef LZOCHK_ASSERT
 
     if (v == 0)
         return LZO_E_ERROR;
@@ -149,7 +198,7 @@ __lzo_init_v2(unsigned v, int s1, int s2
     r = (s1 == -1 || s1 == (int) sizeof(short)) &&
         (s2 == -1 || s2 == (int) sizeof(int)) &&
         (s3 == -1 || s3 == (int) sizeof(long)) &&
-        (s4 == -1 || s4 == (int) sizeof(lzo_uint32)) &&
+        (s4 == -1 || s4 == (int) sizeof(lzo_uint32_t)) &&
         (s5 == -1 || s5 == (int) sizeof(lzo_uint)) &&
         (s6 == -1 || s6 == (int) lzo_sizeof_dict_t) &&
         (s7 == -1 || s7 == (int) sizeof(char *)) &&
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo_mchw.ch syslinux-4.07b/lzo/src/lzo_mchw.ch
--- Syslinux-4.07a/lzo/src/lzo_mchw.ch	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo_mchw.ch	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -44,7 +32,7 @@
 
 typedef struct
 {
-    int init;
+    unsigned init;
 
     lzo_uint look;          /* bytes in lookahead buffer */
 
@@ -112,15 +100,7 @@ typedef struct
 LZO_COMPRESS_T;
 
 
-#if (LZO_CC_BORLANDC && LZO_ARCH_I086) && (__BORLANDC__ < 0x0450)
-   /* work around a Borland C 3.1 bug */
-#  define getbyte(c)  ((c).ip < (c).in_end ? (c).ip +=1, (c).ip[-1] : (-1))
-#elif defined(__TURBOC__) && defined(__TOS__)
-   /* work around a bug in Turbo C / Pure C (Atari ST) */
-#  define getbyte(c)  ((c).ip < (c).in_end ? (int)(unsigned) *((c).ip)++ : (-1))
-#else
-#  define getbyte(c)  ((c).ip < (c).in_end ? *((c).ip)++ : (-1))
-#endif
+#define getbyte(c)  ((c).ip < (c).in_end ? *((c).ip)++ : (-1))
 
 #include "lzo_swd.ch"
 
@@ -132,7 +112,7 @@ LZO_COMPRESS_T;
 static int
 init_match ( LZO_COMPRESS_T *c, lzo_swd_p s,
              const lzo_bytep dict, lzo_uint dict_len,
-             lzo_uint32 flags )
+             lzo_uint32_t flags )
 {
     int r;
 
@@ -148,11 +128,14 @@ init_match ( LZO_COMPRESS_T *c, lzo_swd_
     c->lazy = 0;
 
     r = swd_init(s,dict,dict_len);
-    if (r != 0)
+    if (r != LZO_E_OK)
+    {
+        swd_exit(s);
         return r;
+    }
 
     s->use_best_off = (flags & 1) ? 1 : 0;
-    return r;
+    return LZO_E_OK;
 }
 
 
@@ -178,8 +161,8 @@ find_match ( LZO_COMPRESS_T *c, lzo_swd_
         c->textsize += this_len - skip;
     }
 
-    s->m_len = 1;
-    s->m_len = THRESHOLD;
+    s->m_len = SWD_THRESHOLD;
+    s->m_off = 0;
 #ifdef SWD_BEST_OFF
     if (s->use_best_off)
         lzo_memset(s->best_pos,0,sizeof(s->best_pos));
@@ -204,14 +187,14 @@ find_match ( LZO_COMPRESS_T *c, lzo_swd_
 
 #if 0
     /* brute force match search */
-    if (c->m_len > THRESHOLD && c->m_len + 1 <= c->look)
+    if (c->m_len > SWD_THRESHOLD && c->m_len + 1 <= c->look)
     {
         const lzo_bytep ip = c->bp;
         const lzo_bytep m  = c->bp - c->m_off;
         const lzo_bytep in = c->in;
 
-        if (ip - in > N)
-            in = ip - N;
+        if (ip - in > s->swd_n)
+            in = ip - s->swd_n;
         for (;;)
         {
             while (*in != *ip)
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo_ptr.c syslinux-4.07b/lzo/src/lzo_ptr.c
--- Syslinux-4.07a/lzo/src/lzo_ptr.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo_ptr.c	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -51,10 +39,9 @@ __lzo_ptr_linear(const lzo_voidp ptr)
     lzo_uintptr_t p;
 
 #if (LZO_ARCH_I086)
-    p = (((lzo_uintptr_t)(ACC_PTR_FP_SEG(ptr))) << (16 - ACC_MM_AHSHIFT)) + (ACC_PTR_FP_OFF(ptr));
+#error "LZO_ARCH_I086 is unsupported"
 #elif (LZO_MM_PVP)
-    p = (lzo_uintptr_t) (ptr);
-    p = (p << 3) | (p >> 61);
+#error "LZO_MM_PVP is unsupported"
 #else
     p = (lzo_uintptr_t) PTR_LINEAR(ptr);
 #endif
@@ -70,9 +57,8 @@ __lzo_ptr_linear(const lzo_voidp ptr)
 LZO_PUBLIC(unsigned)
 __lzo_align_gap(const lzo_voidp ptr, lzo_uint size)
 {
-#if defined(__LZO_UINTPTR_T_IS_POINTER)
-    size_t n = (size_t) ptr;
-    n = (((n + size - 1) / size) * size) - n;
+#if (__LZO_UINTPTR_T_IS_POINTER)
+#error "__LZO_UINTPTR_T_IS_POINTER is unsupported"
 #else
     lzo_uintptr_t p, n;
     p = __lzo_ptr_linear(ptr);
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo_ptr.h syslinux-4.07b/lzo/src/lzo_ptr.h
--- Syslinux-4.07a/lzo/src/lzo_ptr.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo_ptr.h	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -45,7 +33,7 @@
 
 
 #ifndef __LZO_PTR_H
-#define __LZO_PTR_H
+#define __LZO_PTR_H 1
 
 #ifdef __cplusplus
 extern "C" {
@@ -53,45 +41,20 @@ extern "C" {
 
 
 /***********************************************************************
-// Integral types
-************************************************************************/
-
-#if !defined(lzo_uintptr_t)
-#  if defined(__LZO_MMODEL_HUGE)
-#    define lzo_uintptr_t   unsigned long
-#  else
-#    define lzo_uintptr_t   acc_uintptr_t
-#    ifdef __ACC_INTPTR_T_IS_POINTER
-#      define __LZO_UINTPTR_T_IS_POINTER 1
-#    endif
-#  endif
-#endif
-
-
-/***********************************************************************
 //
 ************************************************************************/
 
-/* Always use the safe (=integral) version for pointer-comparisions.
+/* Always use the safe (=integral) version for pointer-comparisons.
  * The compiler should optimize away the additional casts anyway.
  *
  * Note that this only works if the representation and ordering
  * of the pointer and the integral is the same (at bit level).
- *
- * Most 16-bit compilers have their own view about pointers -
- * fortunately they don't care about comparing pointers
- * that are pointing to Nirvana.
  */
 
 #if (LZO_ARCH_I086)
-#define PTR(a)              ((lzo_bytep) (a))
-/* only need the low bits of the pointer -> offset is ok */
-#define PTR_ALIGNED_4(a)    ((ACC_PTR_FP_OFF(a) & 3) == 0)
-#define PTR_ALIGNED2_4(a,b) (((ACC_PTR_FP_OFF(a) | ACC_PTR_FP_OFF(b)) & 3) == 0)
+#error "LZO_ARCH_I086 is unsupported"
 #elif (LZO_MM_PVP)
-#define PTR(a)              ((lzo_bytep) (a))
-#define PTR_ALIGNED_8(a)    ((((lzo_uintptr_t)(a)) >> 61) == 0)
-#define PTR_ALIGNED2_8(a,b) ((((lzo_uintptr_t)(a)|(lzo_uintptr_t)(b)) >> 61) == 0)
+#error "LZO_MM_PVP is unsupported"
 #else
 #define PTR(a)              ((lzo_uintptr_t) (a))
 #define PTR_LINEAR(a)       PTR(a)
@@ -123,20 +86,28 @@ typedef union
     unsigned long   a_ulong;
     lzo_int         a_lzo_int;
     lzo_uint        a_lzo_uint;
-    lzo_int32       a_lzo_int32;
-    lzo_uint32      a_lzo_uint32;
+    lzo_xint        a_lzo_xint;
+    lzo_int16_t     a_lzo_int16_t;
+    lzo_uint16_t    a_lzo_uint16_t;
+    lzo_int32_t     a_lzo_int32_t;
+    lzo_uint32_t    a_lzo_uint32_t;
+#if defined(lzo_uint64_t)
+    lzo_int64_t     a_lzo_int64_t;
+    lzo_uint64_t    a_lzo_uint64_t;
+#endif
+    size_t          a_size_t;
     ptrdiff_t       a_ptrdiff_t;
     lzo_uintptr_t   a_lzo_uintptr_t;
-    lzo_voidp       a_lzo_voidp;
     void *          a_void_p;
-    lzo_bytep       a_lzo_bytep;
-    lzo_bytepp      a_lzo_bytepp;
-    lzo_uintp       a_lzo_uintp;
-    lzo_uint *      a_lzo_uint_p;
-    lzo_uint32p     a_lzo_uint32p;
-    lzo_uint32 *    a_lzo_uint32_p;
-    unsigned char * a_uchar_p;
     char *          a_char_p;
+    unsigned char * a_uchar_p;
+    const void *          a_c_void_p;
+    const char *          a_c_char_p;
+    const unsigned char * a_c_uchar_p;
+    lzo_voidp       a_lzo_voidp;
+    lzo_bytep       a_lzo_bytep;
+    const lzo_voidp a_c_lzo_voidp;
+    const lzo_bytep a_c_lzo_bytep;
 }
 lzo_full_align_t;
 
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo_str.c syslinux-4.07b/lzo/src/lzo_str.c
--- Syslinux-4.07a/lzo/src/lzo_str.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo_str.c	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -50,20 +38,20 @@
 // slow but portable <string.h> stuff, only used in assertions
 ************************************************************************/
 
-#if !defined(__LZO_MMODEL_HUGE)
-#  undef ACC_HAVE_MM_HUGE_PTR
+#define lzo_hsize_t             lzo_uint
+#define lzo_hvoid_p             lzo_voidp
+#define lzo_hbyte_p             lzo_bytep
+#define LZOLIB_PUBLIC(r,f)      LZO_PUBLIC(r) f
+#ifndef __LZOLIB_FUNCNAME
+#define __LZOLIB_FUNCNAME(f)    f
 #endif
-#define acc_hsize_t             lzo_uint
-#define acc_hvoid_p             lzo_voidp
-#define acc_hbyte_p             lzo_bytep
-#define ACCLIB_PUBLIC(r,f)      LZO_PUBLIC(r) f
-#define acc_hmemcmp             lzo_memcmp
-#define acc_hmemcpy             lzo_memcpy
-#define acc_hmemmove            lzo_memmove
-#define acc_hmemset             lzo_memset
-#define ACC_WANT_ACCLIB_HMEMCPY 1
-#include "miniacc.h"
-#undef ACCLIB_PUBLIC
+#define lzo_hmemcmp             __LZOLIB_FUNCNAME(lzo_memcmp)
+#define lzo_hmemcpy             __LZOLIB_FUNCNAME(lzo_memcpy)
+#define lzo_hmemmove            __LZOLIB_FUNCNAME(lzo_memmove)
+#define lzo_hmemset             __LZOLIB_FUNCNAME(lzo_memset)
+#define LZO_WANT_ACCLIB_HMEMCPY 1
+#include "lzo_supp.h"
+#undef LZOLIB_PUBLIC
 
 
 /*
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo_supp.h syslinux-4.07b/lzo/src/lzo_supp.h
--- Syslinux-4.07a/lzo/src/lzo_supp.h	1970-01-01 01:00:00.000000000 +0100
+++ syslinux-4.07b/lzo/src/lzo_supp.h	2023-02-08 12:45:19.367515476 +0100
@@ -0,0 +1,3685 @@
+/* lzo_supp.h -- architecture, OS and compiler specific defines
+
+   This file is part of the LZO real-time data compression library.
+
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
+   All Rights Reserved.
+
+   The LZO library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of
+   the License, or (at your option) any later version.
+
+   The LZO library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with the LZO library; see the file COPYING.
+   If not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+   Markus F.X.J. Oberhumer
+   <markus@oberhumer.com>
+   http://www.oberhumer.com/opensource/lzo/
+ */
+
+
+#ifndef __LZO_SUPP_H_INCLUDED
+#define __LZO_SUPP_H_INCLUDED 1
+#if (LZO_CFG_NO_CONFIG_HEADER)
+#elif defined(LZO_CFG_CONFIG_HEADER)
+#else
+#if !(LZO_CFG_AUTO_NO_HEADERS)
+#if (LZO_LIBC_NAKED)
+#elif (LZO_LIBC_FREESTANDING)
+#  define HAVE_LIMITS_H 1
+#  define HAVE_STDARG_H 1
+#  define HAVE_STDDEF_H 1
+#elif (LZO_LIBC_MOSTLY_FREESTANDING)
+#  define HAVE_LIMITS_H 1
+#  define HAVE_SETJMP_H 1
+#  define HAVE_STDARG_H 1
+#  define HAVE_STDDEF_H 1
+#  define HAVE_STDIO_H 1
+#  define HAVE_STRING_H 1
+#else
+#define STDC_HEADERS 1
+#define HAVE_ASSERT_H 1
+#define HAVE_CTYPE_H 1
+#define HAVE_DIRENT_H 1
+#define HAVE_ERRNO_H 1
+#define HAVE_FCNTL_H 1
+#define HAVE_FLOAT_H 1
+#define HAVE_LIMITS_H 1
+#define HAVE_MALLOC_H 1
+#define HAVE_MEMORY_H 1
+#define HAVE_SETJMP_H 1
+#define HAVE_SIGNAL_H 1
+#define HAVE_STDARG_H 1
+#define HAVE_STDDEF_H 1
+#define HAVE_STDIO_H 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STRING_H 1
+#define HAVE_TIME_H 1
+#define HAVE_UNISTD_H 1
+#define HAVE_UTIME_H 1
+#define HAVE_SYS_STAT_H 1
+#define HAVE_SYS_TIME_H 1
+#define HAVE_SYS_TYPES_H 1
+#if (LZO_OS_POSIX)
+#  if (LZO_OS_POSIX_AIX)
+#    define HAVE_SYS_RESOURCE_H 1
+#  elif (LZO_OS_POSIX_FREEBSD || LZO_OS_POSIX_MACOSX || LZO_OS_POSIX_NETBSD || LZO_OS_POSIX_OPENBSD)
+#    define HAVE_STRINGS_H 1
+#    undef HAVE_MALLOC_H
+#  elif (LZO_OS_POSIX_HPUX || LZO_OS_POSIX_INTERIX)
+#    define HAVE_ALLOCA_H 1
+#  elif (LZO_OS_POSIX_MACOSX && LZO_LIBC_MSL)
+#    undef HAVE_SYS_TIME_H
+#    undef HAVE_SYS_TYPES_H
+#  elif (LZO_OS_POSIX_SOLARIS || LZO_OS_POSIX_SUNOS)
+#    define HAVE_ALLOCA_H 1
+#  endif
+#  if (LZO_LIBC_DIETLIBC || LZO_LIBC_GLIBC || LZO_LIBC_UCLIBC)
+#    define HAVE_STRINGS_H 1
+#    define HAVE_SYS_MMAN_H 1
+#    define HAVE_SYS_RESOURCE_H 1
+#    define HAVE_SYS_WAIT_H 1
+#  endif
+#  if (LZO_LIBC_NEWLIB)
+#    undef HAVE_STRINGS_H
+#  endif
+#elif (LZO_OS_CYGWIN)
+#  define HAVE_IO_H 1
+#elif (LZO_OS_EMX)
+#  define HAVE_ALLOCA_H 1
+#  define HAVE_IO_H 1
+#elif (LZO_ARCH_M68K && LZO_OS_TOS && LZO_CC_GNUC)
+#  if !defined(__MINT__)
+#    undef HAVE_MALLOC_H
+#  endif
+#elif (LZO_ARCH_M68K && LZO_OS_TOS && (LZO_CC_PUREC || LZO_CC_TURBOC))
+#  undef HAVE_DIRENT_H
+#  undef HAVE_FCNTL_H
+#  undef HAVE_MALLOC_H
+#  undef HAVE_MEMORY_H
+#  undef HAVE_UNISTD_H
+#  undef HAVE_UTIME_H
+#  undef HAVE_SYS_STAT_H
+#  undef HAVE_SYS_TIME_H
+#  undef HAVE_SYS_TYPES_H
+#endif
+#if (LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_OS216 || LZO_OS_WIN16 || LZO_OS_WIN32 || LZO_OS_WIN64)
+#define HAVE_CONIO_H 1
+#define HAVE_DIRECT_H 1
+#define HAVE_DOS_H 1
+#define HAVE_IO_H 1
+#define HAVE_SHARE_H 1
+#if (LZO_CC_AZTECC)
+#  undef HAVE_CONIO_H
+#  undef HAVE_DIRECT_H
+#  undef HAVE_DIRENT_H
+#  undef HAVE_MALLOC_H
+#  undef HAVE_SHARE_H
+#  undef HAVE_UNISTD_H
+#  undef HAVE_UTIME_H
+#  undef HAVE_SYS_STAT_H
+#  undef HAVE_SYS_TIME_H
+#  undef HAVE_SYS_TYPES_H
+#elif (LZO_CC_BORLANDC)
+#  undef HAVE_UNISTD_H
+#  undef HAVE_SYS_TIME_H
+#  if (LZO_OS_WIN32 || LZO_OS_WIN64)
+#    undef HAVE_DIRENT_H
+#  endif
+#  if (__BORLANDC__ < 0x0400)
+#    undef HAVE_DIRENT_H
+#    undef HAVE_UTIME_H
+#  endif
+#elif (LZO_CC_DMC)
+#  undef HAVE_DIRENT_H
+#  undef HAVE_UNISTD_H
+#  define HAVE_SYS_DIRENT_H 1
+#elif (LZO_OS_DOS32 && LZO_CC_GNUC) && defined(__DJGPP__)
+#elif (LZO_OS_DOS32 && LZO_CC_HIGHC)
+#  define HAVE_ALLOCA_H 1
+#  undef HAVE_DIRENT_H
+#  undef HAVE_UNISTD_H
+#elif (LZO_CC_IBMC && LZO_OS_OS2)
+#  undef HAVE_DOS_H
+#  undef HAVE_DIRENT_H
+#  undef HAVE_UNISTD_H
+#  undef HAVE_UTIME_H
+#  undef HAVE_SYS_TIME_H
+#  define HAVE_SYS_UTIME_H 1
+#elif (LZO_CC_GHS || LZO_CC_INTELC || LZO_CC_MSC)
+#  undef HAVE_DIRENT_H
+#  undef HAVE_UNISTD_H
+#  undef HAVE_UTIME_H
+#  undef HAVE_SYS_TIME_H
+#  define HAVE_SYS_UTIME_H 1
+#elif (LZO_CC_LCCWIN32)
+#  undef HAVE_DIRENT_H
+#  undef HAVE_DOS_H
+#  undef HAVE_UNISTD_H
+#  undef HAVE_SYS_TIME_H
+#elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__MINGW32__)
+#  undef HAVE_UTIME_H
+#  define HAVE_SYS_UTIME_H 1
+#elif (LZO_OS_WIN32 && LZO_LIBC_MSL)
+#  define HAVE_ALLOCA_H 1
+#  undef HAVE_DOS_H
+#  undef HAVE_SHARE_H
+#  undef HAVE_SYS_TIME_H
+#elif (LZO_CC_NDPC)
+#  undef HAVE_DIRENT_H
+#  undef HAVE_DOS_H
+#  undef HAVE_UNISTD_H
+#  undef HAVE_UTIME_H
+#  undef HAVE_SYS_TIME_H
+#elif (LZO_CC_PACIFICC)
+#  undef HAVE_DIRECT_H
+#  undef HAVE_DIRENT_H
+#  undef HAVE_FCNTL_H
+#  undef HAVE_IO_H
+#  undef HAVE_MALLOC_H
+#  undef HAVE_MEMORY_H
+#  undef HAVE_SHARE_H
+#  undef HAVE_UNISTD_H
+#  undef HAVE_UTIME_H
+#  undef HAVE_SYS_STAT_H
+#  undef HAVE_SYS_TIME_H
+#  undef HAVE_SYS_TYPES_H
+#elif (LZO_OS_WIN32 && LZO_CC_PELLESC)
+#  undef HAVE_DIRENT_H
+#  undef HAVE_DOS_H
+#  undef HAVE_MALLOC_H
+#  undef HAVE_SHARE_H
+#  undef HAVE_UNISTD_H
+#  undef HAVE_UTIME_H
+#  undef HAVE_SYS_TIME_H
+#  if (__POCC__ < 280)
+#  else
+#    define HAVE_SYS_UTIME_H 1
+#  endif
+#elif (LZO_OS_WIN32 && LZO_CC_PGI) && defined(__MINGW32__)
+#  undef HAVE_UTIME_H
+#  define HAVE_SYS_UTIME_H 1
+#elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__PW32__)
+#elif (LZO_CC_SYMANTECC)
+#  undef HAVE_DIRENT_H
+#  undef HAVE_UNISTD_H
+#  if (__SC__ < 0x700)
+#    undef HAVE_UTIME_H
+#    undef HAVE_SYS_TIME_H
+#  endif
+#elif (LZO_CC_TOPSPEEDC)
+#  undef HAVE_DIRENT_H
+#  undef HAVE_UNISTD_H
+#  undef HAVE_UTIME_H
+#  undef HAVE_SYS_STAT_H
+#  undef HAVE_SYS_TIME_H
+#  undef HAVE_SYS_TYPES_H
+#elif (LZO_CC_TURBOC)
+#  undef HAVE_UNISTD_H
+#  undef HAVE_SYS_TIME_H
+#  undef HAVE_SYS_TYPES_H
+#  if (LZO_OS_WIN32 || LZO_OS_WIN64)
+#    undef HAVE_DIRENT_H
+#  endif
+#  if (__TURBOC__ < 0x0200)
+#    undef HAVE_SIGNAL_H
+#  endif
+#  if (__TURBOC__ < 0x0400)
+#    undef HAVE_DIRECT_H
+#    undef HAVE_DIRENT_H
+#    undef HAVE_MALLOC_H
+#    undef HAVE_MEMORY_H
+#    undef HAVE_UTIME_H
+#  endif
+#elif (LZO_CC_WATCOMC)
+#  undef HAVE_DIRENT_H
+#  undef HAVE_UTIME_H
+#  undef HAVE_SYS_TIME_H
+#  define HAVE_SYS_UTIME_H 1
+#  if (__WATCOMC__ < 950)
+#    undef HAVE_UNISTD_H
+#  endif
+#elif (LZO_CC_ZORTECHC)
+#  undef HAVE_DIRENT_H
+#  undef HAVE_MEMORY_H
+#  undef HAVE_UNISTD_H
+#  undef HAVE_UTIME_H
+#  undef HAVE_SYS_TIME_H
+#endif
+#endif
+#if (LZO_OS_CONSOLE)
+#  undef HAVE_DIRENT_H
+#endif
+#if (LZO_OS_EMBEDDED)
+#  undef HAVE_DIRENT_H
+#endif
+#if (LZO_LIBC_ISOC90 || LZO_LIBC_ISOC99)
+#  undef HAVE_DIRENT_H
+#  undef HAVE_FCNTL_H
+#  undef HAVE_MALLOC_H
+#  undef HAVE_UNISTD_H
+#  undef HAVE_UTIME_H
+#  undef HAVE_SYS_STAT_H
+#  undef HAVE_SYS_TIME_H
+#  undef HAVE_SYS_TYPES_H
+#endif
+#if (LZO_LIBC_GLIBC >= 0x020100ul)
+#  define HAVE_STDINT_H 1
+#elif (LZO_LIBC_DIETLIBC)
+#  undef HAVE_STDINT_H
+#elif (LZO_LIBC_UCLIBC)
+#  define HAVE_STDINT_H 1
+#elif (LZO_CC_BORLANDC) && (__BORLANDC__ >= 0x560)
+#  undef HAVE_STDINT_H
+#elif (LZO_CC_DMC) && (__DMC__ >= 0x825)
+#  define HAVE_STDINT_H 1
+#endif
+#if (HAVE_SYS_TIME_H && HAVE_TIME_H)
+#  define TIME_WITH_SYS_TIME 1
+#endif
+#endif
+#endif
+#if !(LZO_CFG_AUTO_NO_FUNCTIONS)
+#if (LZO_LIBC_NAKED)
+#elif (LZO_LIBC_FREESTANDING)
+#elif (LZO_LIBC_MOSTLY_FREESTANDING)
+#  define HAVE_LONGJMP 1
+#  define HAVE_MEMCMP 1
+#  define HAVE_MEMCPY 1
+#  define HAVE_MEMMOVE 1
+#  define HAVE_MEMSET 1
+#  define HAVE_SETJMP 1
+#else
+#define HAVE_ACCESS 1
+#define HAVE_ALLOCA 1
+#define HAVE_ATEXIT 1
+#define HAVE_ATOI 1
+#define HAVE_ATOL 1
+#define HAVE_CHMOD 1
+#define HAVE_CHOWN 1
+#define HAVE_CTIME 1
+#define HAVE_DIFFTIME 1
+#define HAVE_FILENO 1
+#define HAVE_FSTAT 1
+#define HAVE_GETENV 1
+#define HAVE_GETTIMEOFDAY 1
+#define HAVE_GMTIME 1
+#define HAVE_ISATTY 1
+#define HAVE_LOCALTIME 1
+#define HAVE_LONGJMP 1
+#define HAVE_LSTAT 1
+#define HAVE_MEMCMP 1
+#define HAVE_MEMCPY 1
+#define HAVE_MEMMOVE 1
+#define HAVE_MEMSET 1
+#define HAVE_MKDIR 1
+#define HAVE_MKTIME 1
+#define HAVE_QSORT 1
+#define HAVE_RAISE 1
+#define HAVE_RMDIR 1
+#define HAVE_SETJMP 1
+#define HAVE_SIGNAL 1
+#define HAVE_SNPRINTF 1
+#define HAVE_STAT 1
+#define HAVE_STRCHR 1
+#define HAVE_STRDUP 1
+#define HAVE_STRERROR 1
+#define HAVE_STRFTIME 1
+#define HAVE_STRRCHR 1
+#define HAVE_STRSTR 1
+#define HAVE_TIME 1
+#define HAVE_UMASK 1
+#define HAVE_UTIME 1
+#define HAVE_VSNPRINTF 1
+#if (LZO_OS_BEOS || LZO_OS_CYGWIN || LZO_OS_POSIX || LZO_OS_QNX || LZO_OS_VMS)
+#  define HAVE_STRCASECMP 1
+#  define HAVE_STRNCASECMP 1
+#elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__PW32__)
+#  define HAVE_STRCASECMP 1
+#  define HAVE_STRNCASECMP 1
+#else
+#  define HAVE_STRICMP 1
+#  define HAVE_STRNICMP 1
+#endif
+#if (LZO_OS_POSIX)
+#  if (LZO_OS_POSIX_AIX)
+#    define HAVE_GETRUSAGE 1
+#  elif (LZO_OS_POSIX_MACOSX && LZO_LIBC_MSL)
+#    undef HAVE_CHOWN
+#    undef HAVE_LSTAT
+#  elif (LZO_OS_POSIX_UNICOS)
+#    undef HAVE_ALLOCA
+#    undef HAVE_SNPRINTF
+#    undef HAVE_VSNPRINTF
+#  endif
+#  if (LZO_CC_TINYC)
+#    undef HAVE_ALLOCA
+#  endif
+#  if (LZO_LIBC_DIETLIBC || LZO_LIBC_GLIBC || LZO_LIBC_UCLIBC)
+#    define HAVE_GETRUSAGE 1
+#    define HAVE_GETPAGESIZE 1
+#    define HAVE_MMAP 1
+#    define HAVE_MPROTECT 1
+#    define HAVE_MUNMAP 1
+#  endif
+#elif (LZO_OS_CYGWIN)
+#  if (LZO_CC_GNUC < 0x025a00ul)
+#    undef HAVE_GETTIMEOFDAY
+#    undef HAVE_LSTAT
+#  endif
+#  if (LZO_CC_GNUC < 0x025f00ul)
+#    undef HAVE_SNPRINTF
+#    undef HAVE_VSNPRINTF
+#  endif
+#elif (LZO_OS_EMX)
+#  undef HAVE_CHOWN
+#  undef HAVE_LSTAT
+#elif (LZO_ARCH_M68K && LZO_OS_TOS && LZO_CC_GNUC)
+#  if !defined(__MINT__)
+#    undef HAVE_SNPRINTF
+#    undef HAVE_VSNPRINTF
+#  endif
+#elif (LZO_ARCH_M68K && LZO_OS_TOS && (LZO_CC_PUREC || LZO_CC_TURBOC))
+#  undef HAVE_ALLOCA
+#  undef HAVE_ACCESS
+#  undef HAVE_CHMOD
+#  undef HAVE_CHOWN
+#  undef HAVE_FSTAT
+#  undef HAVE_GETTIMEOFDAY
+#  undef HAVE_LSTAT
+#  undef HAVE_SNPRINTF
+#  undef HAVE_UMASK
+#  undef HAVE_UTIME
+#  undef HAVE_VSNPRINTF
+#endif
+#if (LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_OS216 || LZO_OS_WIN16 || LZO_OS_WIN32 || LZO_OS_WIN64)
+#undef HAVE_CHOWN
+#undef HAVE_GETTIMEOFDAY
+#undef HAVE_LSTAT
+#undef HAVE_UMASK
+#if (LZO_CC_AZTECC)
+#  undef HAVE_ALLOCA
+#  undef HAVE_DIFFTIME
+#  undef HAVE_FSTAT
+#  undef HAVE_STRDUP
+#  undef HAVE_SNPRINTF
+#  undef HAVE_UTIME
+#  undef HAVE_VSNPRINTF
+#elif (LZO_CC_BORLANDC)
+#  if (__BORLANDC__ < 0x0400)
+#    undef HAVE_ALLOCA
+#    undef HAVE_UTIME
+#  endif
+#  if ((__BORLANDC__ < 0x0410) && LZO_OS_WIN16)
+#    undef HAVE_ALLOCA
+#  endif
+#  if (__BORLANDC__ < 0x0550)
+#    undef HAVE_SNPRINTF
+#    undef HAVE_VSNPRINTF
+#  endif
+#elif (LZO_CC_DMC)
+#  if (LZO_OS_WIN16)
+#    undef HAVE_ALLOCA
+#  endif
+#  define snprintf _snprintf
+#  define vsnprintf _vsnprintf
+#elif (LZO_OS_DOS32 && LZO_CC_GNUC) && defined(__DJGPP__)
+#  undef HAVE_SNPRINTF
+#  undef HAVE_VSNPRINTF
+#elif (LZO_OS_DOS32 && LZO_CC_HIGHC)
+#  undef HAVE_SNPRINTF
+#  undef HAVE_VSNPRINTF
+#elif (LZO_CC_GHS)
+#  undef HAVE_ALLOCA
+#  ifndef snprintf
+#  define snprintf _snprintf
+#  endif
+#  ifndef vsnprintf
+#  define vsnprintf _vsnprintf
+#  endif
+#elif (LZO_CC_IBMC)
+#  undef HAVE_SNPRINTF
+#  undef HAVE_VSNPRINTF
+#elif (LZO_CC_INTELC)
+#  ifndef snprintf
+#  define snprintf _snprintf
+#  endif
+#  ifndef vsnprintf
+#  define vsnprintf _vsnprintf
+#  endif
+#elif (LZO_CC_LCCWIN32)
+#  define utime _utime
+#elif (LZO_CC_MSC)
+#  if (_MSC_VER < 600)
+#    undef HAVE_STRFTIME
+#  endif
+#  if (_MSC_VER < 700)
+#    undef HAVE_SNPRINTF
+#    undef HAVE_VSNPRINTF
+#  elif (_MSC_VER < 1500)
+#    ifndef snprintf
+#    define snprintf _snprintf
+#    endif
+#    ifndef vsnprintf
+#    define vsnprintf _vsnprintf
+#    endif
+#  else
+#    ifndef snprintf
+#    define snprintf _snprintf
+#    endif
+#  endif
+#  if ((_MSC_VER < 800) && LZO_OS_WIN16)
+#    undef HAVE_ALLOCA
+#  endif
+#  if (LZO_ARCH_I086) && defined(__cplusplus)
+#    undef HAVE_LONGJMP
+#    undef HAVE_SETJMP
+#  endif
+#elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__MINGW32__)
+#  if (LZO_CC_GNUC < 0x025f00ul)
+#    undef HAVE_SNPRINTF
+#    undef HAVE_VSNPRINTF
+#  else
+#    define snprintf _snprintf
+#    define vsnprintf _vsnprintf
+#  endif
+#elif (LZO_OS_WIN32 && LZO_LIBC_MSL)
+#  if (__MSL__ < 0x8000ul)
+#    undef HAVE_CHMOD
+#  endif
+#elif (LZO_CC_NDPC)
+#  undef HAVE_ALLOCA
+#  undef HAVE_SNPRINTF
+#  undef HAVE_STRNICMP
+#  undef HAVE_UTIME
+#  undef HAVE_VSNPRINTF
+#  if defined(__cplusplus)
+#    undef HAVE_STAT
+#  endif
+#elif (LZO_CC_PACIFICC)
+#  undef HAVE_ACCESS
+#  undef HAVE_ALLOCA
+#  undef HAVE_CHMOD
+#  undef HAVE_DIFFTIME
+#  undef HAVE_FSTAT
+#  undef HAVE_MKTIME
+#  undef HAVE_RAISE
+#  undef HAVE_SNPRINTF
+#  undef HAVE_STRFTIME
+#  undef HAVE_UTIME
+#  undef HAVE_VSNPRINTF
+#elif (LZO_OS_WIN32 && LZO_CC_PELLESC)
+#  if (__POCC__ < 280)
+#    define alloca _alloca
+#    undef HAVE_UTIME
+#  endif
+#elif (LZO_OS_WIN32 && LZO_CC_PGI) && defined(__MINGW32__)
+#  define snprintf _snprintf
+#  define vsnprintf _vsnprintf
+#elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__PW32__)
+#  undef HAVE_SNPRINTF
+#  undef HAVE_VSNPRINTF
+#elif (LZO_CC_SYMANTECC)
+#  if (LZO_OS_WIN16 && (LZO_MM_MEDIUM || LZO_MM_LARGE || LZO_MM_HUGE))
+#    undef HAVE_ALLOCA
+#  endif
+#  if (__SC__ < 0x600)
+#    undef HAVE_SNPRINTF
+#    undef HAVE_VSNPRINTF
+#  else
+#    define snprintf _snprintf
+#    define vsnprintf _vsnprintf
+#  endif
+#  if (__SC__ < 0x700)
+#    undef HAVE_DIFFTIME
+#    undef HAVE_UTIME
+#  endif
+#elif (LZO_CC_TOPSPEEDC)
+#  undef HAVE_SNPRINTF
+#  undef HAVE_VSNPRINTF
+#elif (LZO_CC_TURBOC)
+#  undef HAVE_ALLOCA
+#  undef HAVE_SNPRINTF
+#  undef HAVE_VSNPRINTF
+#  if (__TURBOC__ < 0x0200)
+#    undef HAVE_RAISE
+#    undef HAVE_SIGNAL
+#  endif
+#  if (__TURBOC__ < 0x0295)
+#    undef HAVE_MKTIME
+#    undef HAVE_STRFTIME
+#  endif
+#  if (__TURBOC__ < 0x0400)
+#    undef HAVE_UTIME
+#  endif
+#elif (LZO_CC_WATCOMC)
+#  if (__WATCOMC__ < 1100)
+#    undef HAVE_SNPRINTF
+#    undef HAVE_VSNPRINTF
+#  elif (__WATCOMC__ < 1200)
+#    define snprintf _snprintf
+#    define vsnprintf _vsnprintf
+#  endif
+#elif (LZO_CC_ZORTECHC)
+#  if (LZO_OS_WIN16 && (LZO_MM_MEDIUM || LZO_MM_LARGE || LZO_MM_HUGE))
+#    undef HAVE_ALLOCA
+#  endif
+#  undef HAVE_DIFFTIME
+#  undef HAVE_SNPRINTF
+#  undef HAVE_UTIME
+#  undef HAVE_VSNPRINTF
+#endif
+#endif
+#if (LZO_OS_CONSOLE)
+#  undef HAVE_ACCESS
+#  undef HAVE_CHMOD
+#  undef HAVE_CHOWN
+#  undef HAVE_GETTIMEOFDAY
+#  undef HAVE_LSTAT
+#  undef HAVE_TIME
+#  undef HAVE_UMASK
+#  undef HAVE_UTIME
+#endif
+#if (LZO_LIBC_ISOC90 || LZO_LIBC_ISOC99)
+#  undef HAVE_ACCESS
+#  undef HAVE_CHMOD
+#  undef HAVE_CHOWN
+#  undef HAVE_FILENO
+#  undef HAVE_FSTAT
+#  undef HAVE_GETTIMEOFDAY
+#  undef HAVE_LSTAT
+#  undef HAVE_STAT
+#  undef HAVE_UMASK
+#  undef HAVE_UTIME
+# if 1
+#  undef HAVE_ALLOCA
+#  undef HAVE_ISATTY
+#  undef HAVE_MKDIR
+#  undef HAVE_RMDIR
+#  undef HAVE_STRDUP
+#  undef HAVE_STRICMP
+#  undef HAVE_STRNICMP
+# endif
+#endif
+#endif
+#endif
+#if !(LZO_CFG_AUTO_NO_SIZES)
+#if !defined(SIZEOF_SHORT) && defined(LZO_SIZEOF_SHORT)
+#  define SIZEOF_SHORT          LZO_SIZEOF_SHORT
+#endif
+#if !defined(SIZEOF_INT) && defined(LZO_SIZEOF_INT)
+#  define SIZEOF_INT            LZO_SIZEOF_INT
+#endif
+#if !defined(SIZEOF_LONG) && defined(LZO_SIZEOF_LONG)
+#  define SIZEOF_LONG           LZO_SIZEOF_LONG
+#endif
+#if !defined(SIZEOF_LONG_LONG) && defined(LZO_SIZEOF_LONG_LONG)
+#  define SIZEOF_LONG_LONG      LZO_SIZEOF_LONG_LONG
+#endif
+#if !defined(SIZEOF___INT32) && defined(LZO_SIZEOF___INT32)
+#  define SIZEOF___INT32        LZO_SIZEOF___INT32
+#endif
+#if !defined(SIZEOF___INT64) && defined(LZO_SIZEOF___INT64)
+#  define SIZEOF___INT64        LZO_SIZEOF___INT64
+#endif
+#if !defined(SIZEOF_VOID_P) && defined(LZO_SIZEOF_VOID_P)
+#  define SIZEOF_VOID_P         LZO_SIZEOF_VOID_P
+#endif
+#if !defined(SIZEOF_SIZE_T) && defined(LZO_SIZEOF_SIZE_T)
+#  define SIZEOF_SIZE_T         LZO_SIZEOF_SIZE_T
+#endif
+#if !defined(SIZEOF_PTRDIFF_T) && defined(LZO_SIZEOF_PTRDIFF_T)
+#  define SIZEOF_PTRDIFF_T      LZO_SIZEOF_PTRDIFF_T
+#endif
+#endif
+#if (HAVE_SIGNAL) && !defined(RETSIGTYPE)
+#  define RETSIGTYPE void
+#endif
+#endif
+#if !(LZO_CFG_SKIP_LZO_TYPES)
+#if 1 && !defined(lzo_signo_t) && defined(__linux__) && defined(__dietlibc__) && (LZO_SIZEOF_INT != 4)
+#  define lzo_signo_t               lzo_int32e_t
+#endif
+#if !defined(lzo_signo_t)
+#  define lzo_signo_t               int
+#endif
+#if defined(__cplusplus)
+extern "C" {
+#endif
+#if (LZO_BROKEN_CDECL_ALT_SYNTAX)
+typedef void __lzo_cdecl_sighandler (*lzo_sighandler_t)(lzo_signo_t);
+#elif defined(RETSIGTYPE)
+typedef RETSIGTYPE (__lzo_cdecl_sighandler *lzo_sighandler_t)(lzo_signo_t);
+#else
+typedef void (__lzo_cdecl_sighandler *lzo_sighandler_t)(lzo_signo_t);
+#endif
+#if defined(__cplusplus)
+}
+#endif
+#endif
+#endif
+#if defined(LZO_WANT_ACC_INCD_H)
+#  undef LZO_WANT_ACC_INCD_H
+#ifndef __LZO_INCD_H_INCLUDED
+#define __LZO_INCD_H_INCLUDED 1
+#if (LZO_LIBC_NAKED)
+#ifndef __LZO_FALLBACK_STDDEF_H_INCLUDED
+#define __LZO_FALLBACK_STDDEF_H_INCLUDED 1
+#if defined(__PTRDIFF_TYPE__)
+typedef __PTRDIFF_TYPE__ lzo_fallback_ptrdiff_t;
+#elif defined(__MIPS_PSX2__)
+typedef int lzo_fallback_ptrdiff_t;
+#else
+typedef long lzo_fallback_ptrdiff_t;
+#endif
+#if defined(__SIZE_TYPE__)
+typedef __SIZE_TYPE__ lzo_fallback_size_t;
+#elif defined(__MIPS_PSX2__)
+typedef unsigned int lzo_fallback_size_t;
+#else
+typedef unsigned long lzo_fallback_size_t;
+#endif
+#if !defined(ptrdiff_t)
+typedef lzo_fallback_ptrdiff_t ptrdiff_t;
+#ifndef _PTRDIFF_T_DEFINED
+#define _PTRDIFF_T_DEFINED 1
+#endif
+#endif
+#if !defined(size_t)
+typedef lzo_fallback_size_t size_t;
+#ifndef _SIZE_T_DEFINED
+#define _SIZE_T_DEFINED 1
+#endif
+#endif
+#if !defined(__cplusplus) && !defined(wchar_t)
+typedef unsigned short wchar_t;
+#ifndef _WCHAR_T_DEFINED
+#define _WCHAR_T_DEFINED 1
+#endif
+#endif
+#ifndef NULL
+#if defined(__cplusplus) && defined(__GNUC__) && (__GNUC__ >= 4)
+#define NULL    __null
+#elif defined(__cplusplus)
+#define NULL    0
+#else
+#define NULL    ((void*)0)
+#endif
+#endif
+#ifndef offsetof
+#define offsetof(s,m)   ((size_t)((ptrdiff_t)&(((s*)0)->m)))
+#endif
+#endif
+#elif (LZO_LIBC_FREESTANDING)
+# if defined(HAVE_STDDEF_H) && (HAVE_STDDEF_H+0)
+#  include <stddef.h>
+# endif
+# if defined(HAVE_STDINT_H) && (HAVE_STDINT_H+0)
+#  include <stdint.h>
+# endif
+#elif (LZO_LIBC_MOSTLY_FREESTANDING)
+# if defined(HAVE_STDIO_H) && (HAVE_STDIO_H+0)
+#  include <stdio.h>
+# endif
+# if defined(HAVE_STDDEF_H) && (HAVE_STDDEF_H+0)
+#  include <stddef.h>
+# endif
+# if defined(HAVE_STDINT_H) && (HAVE_STDINT_H+0)
+#  include <stdint.h>
+# endif
+#else
+#include <stdio.h>
+#if defined(HAVE_TIME_H) && (HAVE_TIME_H+0) && defined(__MSL__) && defined(__cplusplus)
+# include <time.h>
+#endif
+#if defined(HAVE_SYS_TYPES_H) && (HAVE_SYS_TYPES_H+0)
+# include <sys/types.h>
+#endif
+#if defined(HAVE_SYS_STAT_H) && (HAVE_SYS_STAT_H+0)
+# include <sys/stat.h>
+#endif
+#if defined(STDC_HEADERS) && (STDC_HEADERS+0)
+# include <stdlib.h>
+#elif defined(HAVE_STDLIB_H) && (HAVE_STDLIB_H+0)
+# include <stdlib.h>
+#endif
+#include <stddef.h>
+#if defined(HAVE_STRING_H) && (HAVE_STRING_H+0)
+# if defined(STDC_HEADERS) && (STDC_HEADERS+0)
+# elif defined(HAVE_MEMORY_H) && (HAVE_MEMORY_H+0)
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#if defined(HAVE_STRINGS_H) && (HAVE_STRINGS_H+0)
+# include <strings.h>
+#endif
+#if defined(HAVE_INTTYPES_H) && (HAVE_INTTYPES_H+0)
+# include <inttypes.h>
+#endif
+#if defined(HAVE_STDINT_H) && (HAVE_STDINT_H+0)
+# include <stdint.h>
+#endif
+#if defined(HAVE_UNISTD_H) && (HAVE_UNISTD_H+0)
+# include <unistd.h>
+#endif
+#endif
+#endif
+#endif
+#if defined(LZO_WANT_ACC_INCE_H)
+#  undef LZO_WANT_ACC_INCE_H
+#ifndef __LZO_INCE_H_INCLUDED
+#define __LZO_INCE_H_INCLUDED 1
+#if (LZO_LIBC_NAKED)
+#elif (LZO_LIBC_FREESTANDING)
+#elif (LZO_LIBC_MOSTLY_FREESTANDING)
+#  if (HAVE_SETJMP_H)
+#    include <setjmp.h>
+#  endif
+#else
+#if (HAVE_STDARG_H)
+#  include <stdarg.h>
+#endif
+#if (HAVE_CTYPE_H)
+#  include <ctype.h>
+#endif
+#if (HAVE_ERRNO_H)
+#  include <errno.h>
+#endif
+#if (HAVE_MALLOC_H)
+#  include <malloc.h>
+#endif
+#if (HAVE_ALLOCA_H)
+#  include <alloca.h>
+#endif
+#if (HAVE_FCNTL_H)
+#  include <fcntl.h>
+#endif
+#if (HAVE_DIRENT_H)
+#  include <dirent.h>
+#endif
+#if (HAVE_SETJMP_H)
+#  include <setjmp.h>
+#endif
+#if (HAVE_SIGNAL_H)
+#  include <signal.h>
+#endif
+#if (TIME_WITH_SYS_TIME)
+#  include <sys/time.h>
+#  include <time.h>
+#elif (HAVE_TIME_H)
+#  include <time.h>
+#endif
+#if (HAVE_UTIME_H)
+#  include <utime.h>
+#elif (HAVE_SYS_UTIME_H)
+#  include <sys/utime.h>
+#endif
+#if (HAVE_IO_H)
+#  include <io.h>
+#endif
+#if (HAVE_DOS_H)
+#  include <dos.h>
+#endif
+#if (HAVE_DIRECT_H)
+#  include <direct.h>
+#endif
+#if (HAVE_SHARE_H)
+#  include <share.h>
+#endif
+#if (LZO_CC_NDPC)
+#  include <os.h>
+#endif
+#if defined(__TOS__) && (defined(__PUREC__) || defined(__TURBOC__))
+#  include <ext.h>
+#endif
+#endif
+#endif
+#endif
+#if defined(LZO_WANT_ACC_INCI_H)
+#  undef LZO_WANT_ACC_INCI_H
+#ifndef __LZO_INCI_H_INCLUDED
+#define __LZO_INCI_H_INCLUDED 1
+#if (LZO_LIBC_NAKED)
+#elif (LZO_LIBC_FREESTANDING)
+#elif (LZO_LIBC_MOSTLY_FREESTANDING)
+#else
+#if (LZO_OS_TOS && (LZO_CC_PUREC || LZO_CC_TURBOC))
+#  include <tos.h>
+#elif (LZO_HAVE_WINDOWS_H)
+#  if 1 && !defined(WIN32_LEAN_AND_MEAN)
+#    define WIN32_LEAN_AND_MEAN 1
+#  endif
+#  if 1 && !defined(_WIN32_WINNT)
+#    define _WIN32_WINNT 0x0400
+#  endif
+#  include <windows.h>
+#  if (LZO_CC_BORLANDC || LZO_CC_TURBOC)
+#    include <dir.h>
+#  endif
+#elif (LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_WIN16)
+#  if (LZO_CC_AZTECC)
+#    include <model.h>
+#    include <stat.h>
+#  elif (LZO_CC_BORLANDC || LZO_CC_TURBOC)
+#    include <alloc.h>
+#    include <dir.h>
+#  elif (LZO_OS_DOS32 && LZO_CC_GNUC) && defined(__DJGPP__)
+#    include <sys/exceptn.h>
+#  elif (LZO_CC_PACIFICC)
+#    include <unixio.h>
+#    include <stat.h>
+#    include <sys.h>
+#  elif (LZO_CC_WATCOMC)
+#    include <i86.h>
+#  endif
+#elif (LZO_OS_OS216)
+#  if (LZO_CC_WATCOMC)
+#    include <i86.h>
+#  endif
+#endif
+#if (HAVE_SYS_MMAN_H)
+#  include <sys/mman.h>
+#endif
+#if (HAVE_SYS_RESOURCE_H)
+#  include <sys/resource.h>
+#endif
+#if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
+#  if defined(FP_OFF)
+#    define LZO_PTR_FP_OFF(x)   FP_OFF(x)
+#  elif defined(_FP_OFF)
+#    define LZO_PTR_FP_OFF(x)   _FP_OFF(x)
+#  else
+#    define LZO_PTR_FP_OFF(x)   (((const unsigned __far*)&(x))[0])
+#  endif
+#  if defined(FP_SEG)
+#    define LZO_PTR_FP_SEG(x)   FP_SEG(x)
+#  elif defined(_FP_SEG)
+#    define LZO_PTR_FP_SEG(x)   _FP_SEG(x)
+#  else
+#    define LZO_PTR_FP_SEG(x)   (((const unsigned __far*)&(x))[1])
+#  endif
+#  if defined(MK_FP)
+#    define LZO_PTR_MK_FP(s,o)  MK_FP(s,o)
+#  elif defined(_MK_FP)
+#    define LZO_PTR_MK_FP(s,o)  _MK_FP(s,o)
+#  else
+#    define LZO_PTR_MK_FP(s,o)  ((void __far*)(((unsigned long)(s)<<16)+(unsigned)(o)))
+#  endif
+#  if 0
+#    undef LZO_PTR_FP_OFF
+#    undef LZO_PTR_FP_SEG
+#    undef LZO_PTR_MK_FP
+#    define LZO_PTR_FP_OFF(x)   (((const unsigned __far*)&(x))[0])
+#    define LZO_PTR_FP_SEG(x)   (((const unsigned __far*)&(x))[1])
+#    define LZO_PTR_MK_FP(s,o)  ((void __far*)(((unsigned long)(s)<<16)+(unsigned)(o)))
+#  endif
+#endif
+#endif
+#endif
+#endif
+#if defined(LZO_WANT_ACC_LIB_H)
+#  undef LZO_WANT_ACC_LIB_H
+#ifndef __LZO_LIB_H_INCLUDED
+#define __LZO_LIB_H_INCLUDED 1
+#if !defined(__LZOLIB_FUNCNAME)
+#  define __LZOLIB_FUNCNAME(f)  f
+#endif
+#if !defined(LZOLIB_EXTERN)
+#  define LZOLIB_EXTERN(r,f)                extern r __LZOLIB_FUNCNAME(f)
+#endif
+#if !defined(LZOLIB_EXTERN_NOINLINE)
+#  if defined(__lzo_noinline)
+#    define LZOLIB_EXTERN_NOINLINE(r,f)     extern __lzo_noinline r __LZOLIB_FUNCNAME(f)
+#  else
+#    define LZOLIB_EXTERN_NOINLINE(r,f)     extern r __LZOLIB_FUNCNAME(f)
+#  endif
+#endif
+#if (LZO_SIZEOF_LONG > LZO_SIZEOF_VOID_P)
+#  define lzolib_handle_t       long
+#else
+#  define lzolib_handle_t       lzo_intptr_t
+#endif
+#if 0
+LZOLIB_EXTERN(int, lzo_ascii_digit)   (int);
+LZOLIB_EXTERN(int, lzo_ascii_islower) (int);
+LZOLIB_EXTERN(int, lzo_ascii_isupper) (int);
+LZOLIB_EXTERN(int, lzo_ascii_tolower) (int);
+LZOLIB_EXTERN(int, lzo_ascii_toupper) (int);
+LZOLIB_EXTERN(int, lzo_ascii_utolower) (int);
+LZOLIB_EXTERN(int, lzo_ascii_utoupper) (int);
+#endif
+#define lzo_ascii_isdigit(c)    ((LZO_ICAST(unsigned, c) - 48) < 10)
+#define lzo_ascii_islower(c)    ((LZO_ICAST(unsigned, c) - 97) < 26)
+#define lzo_ascii_isupper(c)    ((LZO_ICAST(unsigned, c) - 65) < 26)
+#define lzo_ascii_tolower(c)    (LZO_ICAST(int, c) + (lzo_ascii_isupper(c) << 5))
+#define lzo_ascii_toupper(c)    (LZO_ICAST(int, c) - (lzo_ascii_islower(c) << 5))
+#define lzo_ascii_utolower(c)   lzo_ascii_tolower(LZO_ITRUNC(unsigned char, c))
+#define lzo_ascii_utoupper(c)   lzo_ascii_toupper(LZO_ITRUNC(unsigned char, c))
+#ifndef lzo_hsize_t
+#if (LZO_HAVE_MM_HUGE_PTR)
+#  define lzo_hsize_t   unsigned long
+#  define lzo_hvoid_p   void __huge *
+#  define lzo_hchar_p   char __huge *
+#  define lzo_hchar_pp  char __huge * __huge *
+#  define lzo_hbyte_p   unsigned char __huge *
+#else
+#  define lzo_hsize_t   size_t
+#  define lzo_hvoid_p   void *
+#  define lzo_hchar_p   char *
+#  define lzo_hchar_pp  char **
+#  define lzo_hbyte_p   unsigned char *
+#endif
+#endif
+LZOLIB_EXTERN(lzo_hvoid_p, lzo_halloc) (lzo_hsize_t);
+LZOLIB_EXTERN(void, lzo_hfree) (lzo_hvoid_p);
+#if (LZO_OS_DOS16 || LZO_OS_OS216)
+LZOLIB_EXTERN(void __far*, lzo_dos_alloc) (unsigned long);
+LZOLIB_EXTERN(int, lzo_dos_free) (void __far*);
+#endif
+LZOLIB_EXTERN(int, lzo_hmemcmp) (const lzo_hvoid_p, const lzo_hvoid_p, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hvoid_p, lzo_hmemcpy) (lzo_hvoid_p, const lzo_hvoid_p, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hvoid_p, lzo_hmemmove) (lzo_hvoid_p, const lzo_hvoid_p, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hvoid_p, lzo_hmemset) (lzo_hvoid_p, int, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hsize_t, lzo_hstrlen) (const lzo_hchar_p);
+LZOLIB_EXTERN(int, lzo_hstrcmp) (const lzo_hchar_p, const lzo_hchar_p);
+LZOLIB_EXTERN(int, lzo_hstrncmp)(const lzo_hchar_p, const lzo_hchar_p, lzo_hsize_t);
+LZOLIB_EXTERN(int, lzo_ascii_hstricmp) (const lzo_hchar_p, const lzo_hchar_p);
+LZOLIB_EXTERN(int, lzo_ascii_hstrnicmp)(const lzo_hchar_p, const lzo_hchar_p, lzo_hsize_t);
+LZOLIB_EXTERN(int, lzo_ascii_hmemicmp) (const lzo_hvoid_p, const lzo_hvoid_p, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hchar_p, lzo_hstrstr) (const lzo_hchar_p, const lzo_hchar_p);
+LZOLIB_EXTERN(lzo_hchar_p, lzo_ascii_hstristr) (const lzo_hchar_p, const lzo_hchar_p);
+LZOLIB_EXTERN(lzo_hvoid_p, lzo_hmemmem) (const lzo_hvoid_p, lzo_hsize_t, const lzo_hvoid_p, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hvoid_p, lzo_ascii_hmemimem) (const lzo_hvoid_p, lzo_hsize_t, const lzo_hvoid_p, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hchar_p, lzo_hstrcpy) (lzo_hchar_p, const lzo_hchar_p);
+LZOLIB_EXTERN(lzo_hchar_p, lzo_hstrcat) (lzo_hchar_p, const lzo_hchar_p);
+LZOLIB_EXTERN(lzo_hsize_t, lzo_hstrlcpy) (lzo_hchar_p, const lzo_hchar_p, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hsize_t, lzo_hstrlcat) (lzo_hchar_p, const lzo_hchar_p, lzo_hsize_t);
+LZOLIB_EXTERN(int, lzo_hstrscpy) (lzo_hchar_p, const lzo_hchar_p, lzo_hsize_t);
+LZOLIB_EXTERN(int, lzo_hstrscat) (lzo_hchar_p, const lzo_hchar_p, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hchar_p, lzo_hstrccpy) (lzo_hchar_p, const lzo_hchar_p, int);
+LZOLIB_EXTERN(lzo_hvoid_p, lzo_hmemccpy) (lzo_hvoid_p, const lzo_hvoid_p, int, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hchar_p, lzo_hstrchr)  (const lzo_hchar_p, int);
+LZOLIB_EXTERN(lzo_hchar_p, lzo_hstrrchr) (const lzo_hchar_p, int);
+LZOLIB_EXTERN(lzo_hchar_p, lzo_ascii_hstrichr) (const lzo_hchar_p, int);
+LZOLIB_EXTERN(lzo_hchar_p, lzo_ascii_hstrrichr) (const lzo_hchar_p, int);
+LZOLIB_EXTERN(lzo_hvoid_p, lzo_hmemchr)  (const lzo_hvoid_p, int, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hvoid_p, lzo_hmemrchr) (const lzo_hvoid_p, int, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hvoid_p, lzo_ascii_hmemichr) (const lzo_hvoid_p, int, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hvoid_p, lzo_ascii_hmemrichr) (const lzo_hvoid_p, int, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hsize_t, lzo_hstrspn)  (const lzo_hchar_p, const lzo_hchar_p);
+LZOLIB_EXTERN(lzo_hsize_t, lzo_hstrrspn) (const lzo_hchar_p, const lzo_hchar_p);
+LZOLIB_EXTERN(lzo_hsize_t, lzo_hstrcspn)  (const lzo_hchar_p, const lzo_hchar_p);
+LZOLIB_EXTERN(lzo_hsize_t, lzo_hstrrcspn) (const lzo_hchar_p, const lzo_hchar_p);
+LZOLIB_EXTERN(lzo_hchar_p, lzo_hstrpbrk)  (const lzo_hchar_p, const lzo_hchar_p);
+LZOLIB_EXTERN(lzo_hchar_p, lzo_hstrrpbrk) (const lzo_hchar_p, const lzo_hchar_p);
+LZOLIB_EXTERN(lzo_hchar_p, lzo_hstrsep)  (lzo_hchar_pp, const lzo_hchar_p);
+LZOLIB_EXTERN(lzo_hchar_p, lzo_hstrrsep) (lzo_hchar_pp, const lzo_hchar_p);
+LZOLIB_EXTERN(lzo_hchar_p, lzo_ascii_hstrlwr) (lzo_hchar_p);
+LZOLIB_EXTERN(lzo_hchar_p, lzo_ascii_hstrupr) (lzo_hchar_p);
+LZOLIB_EXTERN(lzo_hvoid_p, lzo_ascii_hmemlwr) (lzo_hvoid_p, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hvoid_p, lzo_ascii_hmemupr) (lzo_hvoid_p, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hsize_t, lzo_hfread) (void *, lzo_hvoid_p, lzo_hsize_t);
+LZOLIB_EXTERN(lzo_hsize_t, lzo_hfwrite) (void *, const lzo_hvoid_p, lzo_hsize_t);
+#if (LZO_HAVE_MM_HUGE_PTR)
+LZOLIB_EXTERN(long, lzo_hread) (int, lzo_hvoid_p, long);
+LZOLIB_EXTERN(long, lzo_hwrite) (int, const lzo_hvoid_p, long);
+#endif
+LZOLIB_EXTERN(long, lzo_safe_hread) (int, lzo_hvoid_p, long);
+LZOLIB_EXTERN(long, lzo_safe_hwrite) (int, const lzo_hvoid_p, long);
+LZOLIB_EXTERN(unsigned, lzo_ua_get_be16) (const lzo_hvoid_p);
+LZOLIB_EXTERN(lzo_uint32l_t, lzo_ua_get_be24) (const lzo_hvoid_p);
+LZOLIB_EXTERN(lzo_uint32l_t, lzo_ua_get_be32) (const lzo_hvoid_p);
+LZOLIB_EXTERN(void, lzo_ua_set_be16) (lzo_hvoid_p, unsigned);
+LZOLIB_EXTERN(void, lzo_ua_set_be24) (lzo_hvoid_p, lzo_uint32l_t);
+LZOLIB_EXTERN(void, lzo_ua_set_be32) (lzo_hvoid_p, lzo_uint32l_t);
+LZOLIB_EXTERN(unsigned, lzo_ua_get_le16) (const lzo_hvoid_p);
+LZOLIB_EXTERN(lzo_uint32l_t, lzo_ua_get_le24) (const lzo_hvoid_p);
+LZOLIB_EXTERN(lzo_uint32l_t, lzo_ua_get_le32) (const lzo_hvoid_p);
+LZOLIB_EXTERN(void, lzo_ua_set_le16) (lzo_hvoid_p, unsigned);
+LZOLIB_EXTERN(void, lzo_ua_set_le24) (lzo_hvoid_p, lzo_uint32l_t);
+LZOLIB_EXTERN(void, lzo_ua_set_le32) (lzo_hvoid_p, lzo_uint32l_t);
+#if defined(lzo_int64l_t)
+LZOLIB_EXTERN(lzo_uint64l_t, lzo_ua_get_be64) (const lzo_hvoid_p);
+LZOLIB_EXTERN(void, lzo_ua_set_be64) (lzo_hvoid_p, lzo_uint64l_t);
+LZOLIB_EXTERN(lzo_uint64l_t, lzo_ua_get_le64) (const lzo_hvoid_p);
+LZOLIB_EXTERN(void, lzo_ua_set_le64) (lzo_hvoid_p, lzo_uint64l_t);
+#endif
+LZOLIB_EXTERN_NOINLINE(short, lzo_vget_short) (short, int);
+LZOLIB_EXTERN_NOINLINE(int, lzo_vget_int) (int, int);
+LZOLIB_EXTERN_NOINLINE(long, lzo_vget_long) (long, int);
+#if defined(lzo_int64l_t)
+LZOLIB_EXTERN_NOINLINE(lzo_int64l_t, lzo_vget_lzo_int64l_t) (lzo_int64l_t, int);
+#endif
+LZOLIB_EXTERN_NOINLINE(lzo_hsize_t, lzo_vget_lzo_hsize_t) (lzo_hsize_t, int);
+#if !(LZO_CFG_NO_FLOAT)
+LZOLIB_EXTERN_NOINLINE(float, lzo_vget_float) (float, int);
+#endif
+#if !(LZO_CFG_NO_DOUBLE)
+LZOLIB_EXTERN_NOINLINE(double, lzo_vget_double) (double, int);
+#endif
+LZOLIB_EXTERN_NOINLINE(lzo_hvoid_p, lzo_vget_lzo_hvoid_p) (lzo_hvoid_p, int);
+LZOLIB_EXTERN_NOINLINE(const lzo_hvoid_p, lzo_vget_lzo_hvoid_cp) (const lzo_hvoid_p, int);
+#if !defined(LZO_FN_PATH_MAX)
+#if (LZO_OS_DOS16 || LZO_OS_WIN16)
+#  define LZO_FN_PATH_MAX   143
+#elif (LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_OS216 || LZO_OS_WIN32 || LZO_OS_WIN64)
+#  define LZO_FN_PATH_MAX   259
+#elif (LZO_OS_TOS)
+#  define LZO_FN_PATH_MAX   259
+#endif
+#endif
+#if !defined(LZO_FN_PATH_MAX)
+#  define LZO_FN_PATH_MAX   1023
+#endif
+#if !defined(LZO_FN_NAME_MAX)
+#if (LZO_OS_DOS16 || LZO_OS_WIN16)
+#  define LZO_FN_NAME_MAX   12
+#elif (LZO_ARCH_M68K && LZO_OS_TOS && (LZO_CC_PUREC || LZO_CC_TURBOC))
+#  define LZO_FN_NAME_MAX   12
+#elif (LZO_OS_DOS32 && LZO_CC_GNUC) && defined(__DJGPP__)
+#elif (LZO_OS_DOS32)
+#  define LZO_FN_NAME_MAX   12
+#endif
+#endif
+#if !defined(LZO_FN_NAME_MAX)
+#  define LZO_FN_NAME_MAX   LZO_FN_PATH_MAX
+#endif
+#define LZO_FNMATCH_NOESCAPE        1
+#define LZO_FNMATCH_PATHNAME        2
+#define LZO_FNMATCH_PATHSTAR        4
+#define LZO_FNMATCH_PERIOD          8
+#define LZO_FNMATCH_ASCII_CASEFOLD  16
+LZOLIB_EXTERN(int, lzo_fnmatch) (const lzo_hchar_p, const lzo_hchar_p, int);
+#undef __LZOLIB_USE_OPENDIR
+#if (HAVE_DIRENT_H || LZO_CC_WATCOMC)
+#  define __LZOLIB_USE_OPENDIR 1
+#  if (LZO_OS_DOS32 && defined(__BORLANDC__))
+#  elif (LZO_OS_DOS32 && LZO_CC_GNUC) && defined(__DJGPP__)
+#  elif (LZO_OS_OS2 || LZO_OS_OS216)
+#  elif (LZO_ARCH_M68K && LZO_OS_TOS && LZO_CC_GNUC)
+#  elif (LZO_OS_WIN32 && !(LZO_HAVE_WINDOWS_H))
+#  elif (LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_OS216 || LZO_OS_TOS || LZO_OS_WIN16 || LZO_OS_WIN32 || LZO_OS_WIN64)
+#    undef __LZOLIB_USE_OPENDIR
+#  endif
+#endif
+typedef struct
+{
+#if defined(__LZOLIB_USE_OPENDIR)
+    void* u_dirp;
+# if (LZO_CC_WATCOMC)
+    unsigned short f_time;
+    unsigned short f_date;
+    unsigned long f_size;
+# endif
+    char f_name[LZO_FN_NAME_MAX+1];
+#elif (LZO_OS_WIN32 || LZO_OS_WIN64)
+    lzolib_handle_t u_handle;
+    unsigned f_attr;
+    unsigned f_size_low;
+    unsigned f_size_high;
+    char f_name[LZO_FN_NAME_MAX+1];
+#elif (LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_TOS || LZO_OS_WIN16)
+    char u_dta[21];
+    unsigned char f_attr;
+    unsigned short f_time;
+    unsigned short f_date;
+    unsigned short f_size_low;
+    unsigned short f_size_high;
+    char f_name[LZO_FN_NAME_MAX+1];
+    char u_dirp;
+#else
+    void* u_dirp;
+    char f_name[LZO_FN_NAME_MAX+1];
+#endif
+} lzo_dir_t;
+#ifndef lzo_dir_p
+#define lzo_dir_p lzo_dir_t *
+#endif
+LZOLIB_EXTERN(int, lzo_opendir)  (lzo_dir_p, const char*);
+LZOLIB_EXTERN(int, lzo_readdir)  (lzo_dir_p);
+LZOLIB_EXTERN(int, lzo_closedir) (lzo_dir_p);
+#if (LZO_CC_GNUC) && (defined(__CYGWIN__) || defined(__MINGW32__))
+#  define lzo_alloca(x)     __builtin_alloca((x))
+#elif (LZO_CC_GNUC) && (LZO_OS_CONSOLE_PS2)
+#  define lzo_alloca(x)     __builtin_alloca((x))
+#elif (LZO_CC_BORLANDC || LZO_CC_LCC) && defined(__linux__)
+#elif (HAVE_ALLOCA)
+#  define lzo_alloca(x)     LZO_STATIC_CAST(void *, alloca((x)))
+#endif
+#if (LZO_OS_DOS32 && LZO_CC_GNUC) && defined(__DJGPP__)
+#  define lzo_stackavail()  stackavail()
+#elif (LZO_ARCH_I086 && LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0410))
+#  define lzo_stackavail()  stackavail()
+#elif (LZO_ARCH_I086 && LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0400))
+#  if (LZO_OS_WIN16) && (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM)
+#  else
+#    define lzo_stackavail()  stackavail()
+#  endif
+#elif ((LZO_ARCH_I086 || LZO_ARCH_I386) && (LZO_CC_DMC || LZO_CC_SYMANTECC))
+#  define lzo_stackavail()  stackavail()
+#elif ((LZO_ARCH_I086) && LZO_CC_MSC && (_MSC_VER >= 700))
+#  define lzo_stackavail()  _stackavail()
+#elif ((LZO_ARCH_I086) && LZO_CC_MSC)
+#  define lzo_stackavail()  stackavail()
+#elif ((LZO_ARCH_I086 || LZO_ARCH_I386) && LZO_CC_TURBOC && (__TURBOC__ >= 0x0450))
+#  define lzo_stackavail()  stackavail()
+#elif (LZO_ARCH_I086 && LZO_CC_TURBOC && (__TURBOC__ >= 0x0400))
+   LZO_EXTERN_C size_t __cdecl stackavail(void);
+#  define lzo_stackavail()  stackavail()
+#elif ((LZO_ARCH_I086 || LZO_ARCH_I386) && (LZO_CC_WATCOMC))
+#  define lzo_stackavail()  stackavail()
+#elif (LZO_ARCH_I086 && LZO_CC_ZORTECHC)
+#  define lzo_stackavail()  _chkstack()
+#endif
+LZOLIB_EXTERN(lzo_intptr_t, lzo_get_osfhandle) (int);
+LZOLIB_EXTERN(const char *, lzo_getenv) (const char *);
+LZOLIB_EXTERN(int, lzo_isatty) (int);
+LZOLIB_EXTERN(int, lzo_mkdir) (const char*, unsigned);
+LZOLIB_EXTERN(int, lzo_rmdir) (const char*);
+LZOLIB_EXTERN(int, lzo_response) (int*, char***);
+LZOLIB_EXTERN(int, lzo_set_binmode) (int, int);
+#if defined(lzo_int32e_t)
+LZOLIB_EXTERN(lzo_int32e_t, lzo_muldiv32s) (lzo_int32e_t, lzo_int32e_t, lzo_int32e_t);
+LZOLIB_EXTERN(lzo_uint32e_t, lzo_muldiv32u) (lzo_uint32e_t, lzo_uint32e_t, lzo_uint32e_t);
+#endif
+LZOLIB_EXTERN(void, lzo_wildargv) (int*, char***);
+LZOLIB_EXTERN_NOINLINE(void, lzo_debug_break) (void);
+LZOLIB_EXTERN_NOINLINE(void, lzo_debug_nop) (void);
+LZOLIB_EXTERN_NOINLINE(int, lzo_debug_align_check_query) (void);
+LZOLIB_EXTERN_NOINLINE(int, lzo_debug_align_check_enable) (int);
+LZOLIB_EXTERN_NOINLINE(unsigned, lzo_debug_running_on_qemu) (void);
+LZOLIB_EXTERN_NOINLINE(unsigned, lzo_debug_running_on_valgrind) (void);
+#if defined(lzo_int32e_t)
+LZOLIB_EXTERN(int, lzo_tsc_read) (lzo_uint32e_t*);
+#endif
+struct lzo_pclock_handle_t;
+struct lzo_pclock_t;
+typedef struct lzo_pclock_handle_t lzo_pclock_handle_t;
+typedef struct lzo_pclock_t lzo_pclock_t;
+#ifndef lzo_pclock_handle_p
+#define lzo_pclock_handle_p lzo_pclock_handle_t *
+#endif
+#ifndef lzo_pclock_p
+#define lzo_pclock_p lzo_pclock_t *
+#endif
+#define LZO_PCLOCK_REALTIME             0
+#define LZO_PCLOCK_MONOTONIC            1
+#define LZO_PCLOCK_PROCESS_CPUTIME_ID   2
+#define LZO_PCLOCK_THREAD_CPUTIME_ID    3
+typedef int (*lzo_pclock_gettime_t) (lzo_pclock_handle_p, lzo_pclock_p);
+struct lzo_pclock_handle_t {
+    lzolib_handle_t h;
+    int mode;
+    int read_error;
+    const char* name;
+    lzo_pclock_gettime_t gettime;
+#if defined(lzo_int64l_t)
+    lzo_uint64l_t ticks_base;
+#endif
+};
+struct lzo_pclock_t {
+#if defined(lzo_int64l_t)
+    lzo_int64l_t tv_sec;
+#else
+    lzo_int32l_t tv_sec_high;
+    lzo_uint32l_t tv_sec_low;
+#endif
+    lzo_uint32l_t tv_nsec;
+};
+LZOLIB_EXTERN(int, lzo_pclock_open)  (lzo_pclock_handle_p, int);
+LZOLIB_EXTERN(int, lzo_pclock_open_default) (lzo_pclock_handle_p);
+LZOLIB_EXTERN(int, lzo_pclock_close) (lzo_pclock_handle_p);
+LZOLIB_EXTERN(void, lzo_pclock_read) (lzo_pclock_handle_p, lzo_pclock_p);
+#if !(LZO_CFG_NO_DOUBLE)
+LZOLIB_EXTERN(double, lzo_pclock_get_elapsed) (lzo_pclock_handle_p, const lzo_pclock_p, const lzo_pclock_p);
+#endif
+LZOLIB_EXTERN(int, lzo_pclock_flush_cpu_cache) (lzo_pclock_handle_p, unsigned);
+struct lzo_getopt_t;
+typedef struct lzo_getopt_t lzo_getopt_t;
+#ifndef lzo_getopt_p
+#define lzo_getopt_p lzo_getopt_t *
+#endif
+struct lzo_getopt_longopt_t;
+typedef struct lzo_getopt_longopt_t lzo_getopt_longopt_t;
+#ifndef lzo_getopt_longopt_p
+#define lzo_getopt_longopt_p lzo_getopt_longopt_t *
+#endif
+struct lzo_getopt_longopt_t {
+    const char* name;
+    int has_arg;
+    int* flag;
+    int val;
+};
+typedef void (*lzo_getopt_opterr_t)(lzo_getopt_p, const char*, void *);
+struct lzo_getopt_t {
+    void *user;
+    const char *progname;
+    int bad_option;
+    char *optarg;
+    lzo_getopt_opterr_t opterr;
+    int optind;
+    int optopt;
+    int errcount;
+    int argc; char** argv;
+    int eof; int shortpos;
+    int pending_rotate_first, pending_rotate_middle;
+};
+enum { LZO_GETOPT_NO_ARG, LZO_GETOPT_REQUIRED_ARG, LZO_GETOPT_OPTIONAL_ARG, LZO_GETOPT_EXACT_ARG = 0x10 };
+enum { LZO_GETOPT_PERMUTE, LZO_GETOPT_RETURN_IN_ORDER, LZO_GETOPT_REQUIRE_ORDER };
+LZOLIB_EXTERN(void, lzo_getopt_init) (lzo_getopt_p g,
+                                      int start_argc, int argc, char** argv);
+LZOLIB_EXTERN(int, lzo_getopt) (lzo_getopt_p g,
+                                const char* shortopts,
+                                const lzo_getopt_longopt_p longopts,
+                                int* longind);
+typedef struct {
+    lzo_uint32l_t seed;
+} lzo_rand31_t;
+#ifndef lzo_rand31_p
+#define lzo_rand31_p lzo_rand31_t *
+#endif
+LZOLIB_EXTERN(void, lzo_srand31) (lzo_rand31_p, lzo_uint32l_t);
+LZOLIB_EXTERN(lzo_uint32l_t, lzo_rand31) (lzo_rand31_p);
+#if defined(lzo_int64l_t)
+typedef struct {
+    lzo_uint64l_t seed;
+} lzo_rand48_t;
+#ifndef lzo_rand48_p
+#define lzo_rand48_p lzo_rand48_t *
+#endif
+LZOLIB_EXTERN(void, lzo_srand48) (lzo_rand48_p, lzo_uint32l_t);
+LZOLIB_EXTERN(lzo_uint32l_t, lzo_rand48) (lzo_rand48_p);
+LZOLIB_EXTERN(lzo_uint32l_t, lzo_rand48_r32) (lzo_rand48_p);
+#endif
+#if defined(lzo_int64l_t)
+typedef struct {
+    lzo_uint64l_t seed;
+} lzo_rand64_t;
+#ifndef lzo_rand64_p
+#define lzo_rand64_p lzo_rand64_t *
+#endif
+LZOLIB_EXTERN(void, lzo_srand64) (lzo_rand64_p, lzo_uint64l_t);
+LZOLIB_EXTERN(lzo_uint32l_t, lzo_rand64) (lzo_rand64_p);
+LZOLIB_EXTERN(lzo_uint32l_t, lzo_rand64_r32) (lzo_rand64_p);
+#endif
+typedef struct {
+    unsigned n;
+    lzo_uint32l_t s[624];
+} lzo_randmt_t;
+#ifndef lzo_randmt_p
+#define lzo_randmt_p lzo_randmt_t *
+#endif
+LZOLIB_EXTERN(void, lzo_srandmt) (lzo_randmt_p, lzo_uint32l_t);
+LZOLIB_EXTERN(lzo_uint32l_t, lzo_randmt) (lzo_randmt_p);
+LZOLIB_EXTERN(lzo_uint32l_t, lzo_randmt_r32) (lzo_randmt_p);
+#if defined(lzo_int64l_t)
+typedef struct {
+    unsigned n;
+    lzo_uint64l_t s[312];
+} lzo_randmt64_t;
+#ifndef lzo_randmt64_p
+#define lzo_randmt64_p lzo_randmt64_t *
+#endif
+LZOLIB_EXTERN(void, lzo_srandmt64) (lzo_randmt64_p, lzo_uint64l_t);
+LZOLIB_EXTERN(lzo_uint64l_t, lzo_randmt64_r64) (lzo_randmt64_p);
+#endif
+#define LZO_SPAWN_P_WAIT    0
+#define LZO_SPAWN_P_NOWAIT  1
+LZOLIB_EXTERN(int, lzo_spawnv)  (int mode, const char* fn, const char* const * argv);
+LZOLIB_EXTERN(int, lzo_spawnvp) (int mode, const char* fn, const char* const * argv);
+LZOLIB_EXTERN(int, lzo_spawnve) (int mode, const char* fn, const char* const * argv, const char * const envp);
+#endif
+#endif
+#if defined(LZO_WANT_ACC_CXX_H)
+#  undef LZO_WANT_ACC_CXX_H
+#ifndef __LZO_CXX_H_INCLUDED
+#define __LZO_CXX_H_INCLUDED 1
+#if defined(__cplusplus)
+#if defined(LZO_CXX_NOTHROW)
+#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020800ul))
+#elif (LZO_CC_BORLANDC && (__BORLANDC__ < 0x0450))
+#elif (LZO_CC_GHS && !defined(__EXCEPTIONS))
+#elif (LZO_CC_HIGHC)
+#elif (LZO_CC_MSC && (_MSC_VER < 1100))
+#elif (LZO_CC_NDPC)
+#elif (LZO_CC_TURBOC)
+#elif (LZO_CC_WATCOMC && !defined(_CPPUNWIND))
+#elif (LZO_CC_ZORTECHC)
+#else
+#  define LZO_CXX_NOTHROW           throw()
+#endif
+#if !defined(LZO_CXX_NOTHROW)
+#  define LZO_CXX_NOTHROW           /*empty*/
+#endif
+#if defined(__LZO_CXX_DO_NEW)
+#elif (LZO_CC_GHS || LZO_CC_NDPC || LZO_CC_PGI)
+#  define __LZO_CXX_DO_NEW          { return 0; }
+#elif ((LZO_CC_BORLANDC || LZO_CC_TURBOC) && LZO_ARCH_I086)
+#  define __LZO_CXX_DO_NEW          { return 0; }
+#else
+#  define __LZO_CXX_DO_NEW          ;
+#endif
+#if defined(__LZO_CXX_DO_DELETE)
+#elif (LZO_CC_BORLANDC || LZO_CC_TURBOC)
+#  define __LZO_CXX_DO_DELETE       { }
+#else
+#  define __LZO_CXX_DO_DELETE       LZO_CXX_NOTHROW { }
+#endif
+#if (LZO_CC_BORLANDC && (__BORLANDC__ < 0x0450))
+#elif (LZO_CC_MSC && LZO_MM_HUGE)
+#  define LZO_CXX_DISABLE_NEW_DELETE private:
+#elif (LZO_CC_MSC && (_MSC_VER < 1100))
+#elif (LZO_CC_NDPC)
+#elif (LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
+#elif (LZO_CC_TURBOC)
+#elif (LZO_CC_WATCOMC && (__WATCOMC__ < 1100))
+#else
+#  define __LZO_CXX_HAVE_ARRAY_NEW 1
+#endif
+#if (__LZO_CXX_HAVE_ARRAY_NEW)
+#  define __LZO_CXX_HAVE_PLACEMENT_NEW 1
+#endif
+#if (__LZO_CXX_HAVE_PLACEMENT_NEW)
+#  if (LZO_CC_GNUC >= 0x030000ul)
+#    define __LZO_CXX_HAVE_PLACEMENT_DELETE 1
+#  elif (LZO_CC_INTELC)
+#    define __LZO_CXX_HAVE_PLACEMENT_DELETE 1
+#  elif (LZO_CC_MSC && (_MSC_VER >= 1200))
+#    define __LZO_CXX_HAVE_PLACEMENT_DELETE 1
+#  elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
+#    define __LZO_CXX_HAVE_PLACEMENT_DELETE 1
+#  elif (LZO_CC_PGI)
+#    define __LZO_CXX_HAVE_PLACEMENT_DELETE 1
+#  endif
+#endif
+#if defined(LZO_CXX_DISABLE_NEW_DELETE)
+#elif defined(new) || defined(delete)
+#  define LZO_CXX_DISABLE_NEW_DELETE private:
+#elif (LZO_CC_GNUC && (LZO_CC_GNUC < 0x025b00ul))
+#  define LZO_CXX_DISABLE_NEW_DELETE private:
+#elif  (LZO_CC_HIGHC)
+#  define LZO_CXX_DISABLE_NEW_DELETE private:
+#elif !(__LZO_CXX_HAVE_ARRAY_NEW)
+#  define LZO_CXX_DISABLE_NEW_DELETE \
+        protected: static void operator delete(void*) __LZO_CXX_DO_DELETE \
+        protected: static void* operator new(size_t) __LZO_CXX_DO_NEW \
+        private:
+#else
+#  define LZO_CXX_DISABLE_NEW_DELETE \
+        protected: static void operator delete(void*) __LZO_CXX_DO_DELETE \
+                   static void operator delete[](void*) __LZO_CXX_DO_DELETE \
+        private:   static void* operator new(size_t)  __LZO_CXX_DO_NEW \
+                   static void* operator new[](size_t) __LZO_CXX_DO_NEW
+#endif
+#if defined(LZO_CXX_TRIGGER_FUNCTION)
+#else
+#  define LZO_CXX_TRIGGER_FUNCTION \
+        protected: virtual const void* lzo_cxx_trigger_function() const; \
+        private:
+#endif
+#if defined(LZO_CXX_TRIGGER_FUNCTION_IMPL)
+#else
+#  define LZO_CXX_TRIGGER_FUNCTION_IMPL(klass) \
+        const void* klass::lzo_cxx_trigger_function() const { return LZO_STATIC_CAST(const void *, 0); }
+#endif
+#endif
+#endif
+#endif
+#if defined(LZO_WANT_ACC_CHK_CH)
+#  undef LZO_WANT_ACC_CHK_CH
+#if !defined(LZOCHK_ASSERT)
+#  define LZOCHK_ASSERT(expr)   LZO_COMPILE_TIME_ASSERT_HEADER(expr)
+#endif
+#if !defined(LZOCHK_ASSERT_SIGN_T)
+#  define LZOCHK_ASSERT_SIGN_T(type,relop) \
+        LZOCHK_ASSERT( LZO_STATIC_CAST(type, -1)  relop  LZO_STATIC_CAST(type, 0)) \
+        LZOCHK_ASSERT( LZO_STATIC_CAST(type, ~LZO_STATIC_CAST(type, 0)) relop  LZO_STATIC_CAST(type, 0)) \
+        LZOCHK_ASSERT( LZO_STATIC_CAST(type, ~LZO_STATIC_CAST(type, 0)) ==     LZO_STATIC_CAST(type, -1))
+#endif
+#if !defined(LZOCHK_ASSERT_IS_SIGNED_T)
+#  define LZOCHK_ASSERT_IS_SIGNED_T(type)       LZOCHK_ASSERT_SIGN_T(type,<)
+#endif
+#if !defined(LZOCHK_ASSERT_IS_UNSIGNED_T)
+#  if (LZO_BROKEN_INTEGRAL_PROMOTION)
+#    define LZOCHK_ASSERT_IS_UNSIGNED_T(type) \
+        LZOCHK_ASSERT( LZO_STATIC_CAST(type, -1) > LZO_STATIC_CAST(type, 0) )
+#  else
+#    define LZOCHK_ASSERT_IS_UNSIGNED_T(type)   LZOCHK_ASSERT_SIGN_T(type,>)
+#  endif
+#endif
+#if defined(LZOCHK_CFG_PEDANTIC)
+#if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0550) && (__BORLANDC__ < 0x0560))
+#  pragma option push -w-8055
+#elif (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0530) && (__BORLANDC__ < 0x0550))
+#  pragma option push -w-osh
+#endif
+#endif
+#if (LZO_0xffffffffL - LZO_UINT32_C(4294967294) != 1)
+#  error "preprocessor error"
+#endif
+#if (LZO_0xffffffffL - LZO_UINT32_C(0xfffffffd) != 2)
+#  error "preprocessor error"
+#endif
+#if +0
+#  error "preprocessor error"
+#endif
+#if -0
+#  error "preprocessor error"
+#endif
+#if +0 != 0
+#  error "preprocessor error"
+#endif
+#if -0 != 0
+#  error "preprocessor error"
+#endif
+#define LZOCHK_VAL  1
+#define LZOCHK_TMP1 LZOCHK_VAL
+#undef LZOCHK_VAL
+#define LZOCHK_VAL  2
+#define LZOCHK_TMP2 LZOCHK_VAL
+#if (LZOCHK_TMP1 != 2)
+#  error "preprocessor error 3a"
+#endif
+#if (LZOCHK_TMP2 != 2)
+#  error "preprocessor error 3b"
+#endif
+#undef LZOCHK_VAL
+#if (LZOCHK_TMP2)
+#  error "preprocessor error 3c"
+#endif
+#if (LZOCHK_TMP2 + 0 != 0)
+#  error "preprocessor error 3d"
+#endif
+#undef LZOCHK_TMP1
+#undef LZOCHK_TMP2
+#if 0 || defined(LZOCHK_CFG_PEDANTIC)
+#  if (LZO_ARCH_MIPS) && defined(_MIPS_SZINT)
+    LZOCHK_ASSERT((_MIPS_SZINT) == 8 * sizeof(int))
+#  endif
+#  if (LZO_ARCH_MIPS) && defined(_MIPS_SZLONG)
+    LZOCHK_ASSERT((_MIPS_SZLONG) == 8 * sizeof(long))
+#  endif
+#  if (LZO_ARCH_MIPS) && defined(_MIPS_SZPTR)
+    LZOCHK_ASSERT((_MIPS_SZPTR) == 8 * sizeof(void *))
+#  endif
+#endif
+    LZOCHK_ASSERT(1 == 1)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(1u,1) == 1)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(1u,2) == 3)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(1u,3) == 7)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(1u,8) == 255)
+#if (SIZEOF_INT >= 2)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(1,15) == 32767)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(1u,16) == 0xffffU)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(0u,16) == 0u)
+#else
+    LZOCHK_ASSERT(__LZO_MASK_GEN(1ul,16) == 0xffffUL)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(0ul,16) == 0ul)
+#endif
+#if (SIZEOF_INT >= 4)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(1,31) == 2147483647)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(1u,32) == 0xffffffffU)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(0u,32) == 0u)
+#endif
+#if (SIZEOF_LONG >= 4)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(1ul,32) == 0xffffffffUL)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(0ul,32) == 0ul)
+#endif
+#if (SIZEOF_LONG >= 8)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(1ul,64) == 0xffffffffffffffffUL)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(0ul,64) == 0ul)
+#endif
+#if !(LZO_BROKEN_INTEGRAL_PROMOTION)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(1u,SIZEOF_INT*8) == ~0u)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(1ul,SIZEOF_LONG*8) == ~0ul)
+#endif
+#if 1
+    LZOCHK_ASSERT(__LZO_MASK_GEN(0,0) == 0)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(1,0) == 0)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(2,0) == 0)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(4,0) == 0)
+#endif
+#if 1
+    LZOCHK_ASSERT(__LZO_MASK_GEN(2,1) == 2)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(4,1) == 4)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(8,1) == 8)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(2,2) == 2+4)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(4,2) == 4+8)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(8,2) == 8+16)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(2,3) == 2+4+8)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(4,3) == 4+8+16)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(8,3) == 8+16+32)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(7,1) == 7)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(7,2) == 7+14)
+    LZOCHK_ASSERT(__LZO_MASK_GEN(7,3) == 7+14+28)
+#endif
+#if !(LZO_BROKEN_SIGNED_RIGHT_SHIFT)
+    LZOCHK_ASSERT(((-1) >> 7) == -1)
+#endif
+    LZOCHK_ASSERT(((1)  >> 7) == 0)
+#if (LZO_CC_INTELC && (__INTEL_COMPILER >= 900))
+#  pragma warning(push)
+#  pragma warning(disable: 1025)
+#endif
+    LZOCHK_ASSERT((~0l  & ~0)  == ~0l)
+    LZOCHK_ASSERT((~0l  & ~0u) == ~0u)
+    LZOCHK_ASSERT((~0ul & ~0)  == ~0ul)
+    LZOCHK_ASSERT((~0ul & ~0u) == ~0u)
+#if defined(__MSDOS__) && defined(__TURBOC__) && (__TURBOC__ < 0x0150)
+#elif (SIZEOF_INT == 2)
+    LZOCHK_ASSERT((~0l  & ~0u) == 0xffffU)
+    LZOCHK_ASSERT((~0ul & ~0u) == 0xffffU)
+#elif (SIZEOF_INT == 4)
+    LZOCHK_ASSERT((~0l  & ~0u) == 0xffffffffU)
+    LZOCHK_ASSERT((~0ul & ~0u) == 0xffffffffU)
+#endif
+#if (LZO_CC_INTELC && (__INTEL_COMPILER >= 900))
+#  pragma warning(pop)
+#endif
+    LZOCHK_ASSERT_IS_SIGNED_T(signed char)
+    LZOCHK_ASSERT_IS_UNSIGNED_T(unsigned char)
+    LZOCHK_ASSERT(sizeof(signed char) == sizeof(char))
+    LZOCHK_ASSERT(sizeof(unsigned char) == sizeof(char))
+    LZOCHK_ASSERT(sizeof(char) == 1)
+#if (LZO_CC_CILLY) && (!defined(__CILLY__) || (__CILLY__ < 0x010302L))
+#else
+    LZOCHK_ASSERT(sizeof(char) == sizeof(LZO_STATIC_CAST(char, 0)))
+#endif
+#if defined(__cplusplus)
+    LZOCHK_ASSERT(sizeof('\0') == sizeof(char))
+#else
+#  if (LZO_CC_DMC)
+#  else
+    LZOCHK_ASSERT(sizeof('\0') == sizeof(int))
+#  endif
+#endif
+#if defined(__lzo_alignof)
+    LZOCHK_ASSERT(__lzo_alignof(char) == 1)
+    LZOCHK_ASSERT(__lzo_alignof(signed char) == 1)
+    LZOCHK_ASSERT(__lzo_alignof(unsigned char) == 1)
+#if defined(lzo_int16e_t)
+    LZOCHK_ASSERT(__lzo_alignof(lzo_int16e_t) >= 1)
+    LZOCHK_ASSERT(__lzo_alignof(lzo_int16e_t) <= 2)
+#endif
+#if defined(lzo_int32e_t)
+    LZOCHK_ASSERT(__lzo_alignof(lzo_int32e_t) >= 1)
+    LZOCHK_ASSERT(__lzo_alignof(lzo_int32e_t) <= 4)
+#endif
+#endif
+    LZOCHK_ASSERT_IS_SIGNED_T(short)
+    LZOCHK_ASSERT_IS_UNSIGNED_T(unsigned short)
+    LZOCHK_ASSERT(sizeof(short) == sizeof(unsigned short))
+#if !(LZO_ABI_I8LP16)
+    LZOCHK_ASSERT(sizeof(short) >= 2)
+#endif
+    LZOCHK_ASSERT(sizeof(short) >= sizeof(char))
+#if (LZO_CC_CILLY) && (!defined(__CILLY__) || (__CILLY__ < 0x010302L))
+#else
+    LZOCHK_ASSERT(sizeof(short) == sizeof(LZO_STATIC_CAST(short, 0)))
+#endif
+#if (SIZEOF_SHORT > 0)
+    LZOCHK_ASSERT(sizeof(short) == SIZEOF_SHORT)
+#endif
+    LZOCHK_ASSERT_IS_SIGNED_T(int)
+    LZOCHK_ASSERT_IS_UNSIGNED_T(unsigned int)
+    LZOCHK_ASSERT(sizeof(int) == sizeof(unsigned int))
+#if !(LZO_ABI_I8LP16)
+    LZOCHK_ASSERT(sizeof(int) >= 2)
+#endif
+    LZOCHK_ASSERT(sizeof(int) >= sizeof(short))
+    LZOCHK_ASSERT(sizeof(int) == sizeof(0))
+    LZOCHK_ASSERT(sizeof(int) == sizeof(LZO_STATIC_CAST(int, 0)))
+#if (SIZEOF_INT > 0)
+    LZOCHK_ASSERT(sizeof(int) == SIZEOF_INT)
+#endif
+    LZOCHK_ASSERT(sizeof(0) == sizeof(int))
+    LZOCHK_ASSERT_IS_SIGNED_T(long)
+    LZOCHK_ASSERT_IS_UNSIGNED_T(unsigned long)
+    LZOCHK_ASSERT(sizeof(long) == sizeof(unsigned long))
+#if !(LZO_ABI_I8LP16)
+    LZOCHK_ASSERT(sizeof(long) >= 4)
+#endif
+    LZOCHK_ASSERT(sizeof(long) >= sizeof(int))
+    LZOCHK_ASSERT(sizeof(long) == sizeof(0L))
+    LZOCHK_ASSERT(sizeof(long) == sizeof(LZO_STATIC_CAST(long, 0)))
+#if (SIZEOF_LONG > 0)
+    LZOCHK_ASSERT(sizeof(long) == SIZEOF_LONG)
+#endif
+    LZOCHK_ASSERT(sizeof(0L) == sizeof(long))
+    LZOCHK_ASSERT_IS_UNSIGNED_T(size_t)
+    LZOCHK_ASSERT(sizeof(size_t) >= sizeof(int))
+    LZOCHK_ASSERT(sizeof(size_t) == sizeof(sizeof(0)))
+#if (SIZEOF_SIZE_T > 0)
+    LZOCHK_ASSERT(sizeof(size_t) == SIZEOF_SIZE_T)
+#endif
+    LZOCHK_ASSERT_IS_SIGNED_T(ptrdiff_t)
+    LZOCHK_ASSERT(sizeof(ptrdiff_t) >= sizeof(int))
+    LZOCHK_ASSERT(sizeof(ptrdiff_t) >= sizeof(size_t))
+#if !(LZO_BROKEN_SIZEOF)
+    LZOCHK_ASSERT(sizeof(ptrdiff_t) == sizeof(LZO_STATIC_CAST(char*, 0) - LZO_STATIC_CAST(char*, 0)))
+# if (LZO_HAVE_MM_HUGE_PTR)
+    LZOCHK_ASSERT(4 == sizeof(LZO_STATIC_CAST(char __huge*, 0) - LZO_STATIC_CAST(char __huge*, 0)))
+# endif
+#endif
+#if (SIZEOF_PTRDIFF_T > 0)
+    LZOCHK_ASSERT(sizeof(ptrdiff_t) == SIZEOF_PTRDIFF_T)
+#endif
+    LZOCHK_ASSERT(sizeof(void*) >= sizeof(char*))
+#if (SIZEOF_VOID_P > 0)
+    LZOCHK_ASSERT(sizeof(void*) == SIZEOF_VOID_P)
+    LZOCHK_ASSERT(sizeof(char*) == SIZEOF_VOID_P)
+#endif
+#if (LZO_HAVE_MM_HUGE_PTR)
+    LZOCHK_ASSERT(4 == sizeof(void __huge*))
+    LZOCHK_ASSERT(4 == sizeof(char __huge*))
+#endif
+#if (LZO_ABI_I8LP16)
+    LZOCHK_ASSERT((((1u  <<  7) + 1) >>  7) == 1)
+    LZOCHK_ASSERT((((1ul << 15) + 1) >> 15) == 1)
+#else
+    LZOCHK_ASSERT((((1u  << 15) + 1) >> 15) == 1)
+    LZOCHK_ASSERT((((1ul << 31) + 1) >> 31) == 1)
+#endif
+#if defined(LZOCHK_CFG_PEDANTIC)
+#if defined(__MSDOS__) && defined(__TURBOC__) && (__TURBOC__ < 0x0150)
+#else
+    LZOCHK_ASSERT((1   << (8*SIZEOF_INT-1)) < 0)
+#endif
+#endif
+    LZOCHK_ASSERT((1u  << (8*SIZEOF_INT-1)) > 0)
+#if defined(LZOCHK_CFG_PEDANTIC)
+    LZOCHK_ASSERT((1l  << (8*SIZEOF_LONG-1)) < 0)
+#endif
+    LZOCHK_ASSERT((1ul << (8*SIZEOF_LONG-1)) > 0)
+#if defined(lzo_int16e_t)
+    LZOCHK_ASSERT(sizeof(lzo_int16e_t) == 2)
+    LZOCHK_ASSERT(sizeof(lzo_int16e_t) == LZO_SIZEOF_LZO_INT16E_T)
+    LZOCHK_ASSERT(sizeof(lzo_uint16e_t) == 2)
+    LZOCHK_ASSERT(sizeof(lzo_int16e_t) == sizeof(lzo_uint16e_t))
+    LZOCHK_ASSERT_IS_SIGNED_T(lzo_int16e_t)
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_uint16e_t)
+#if defined(__MSDOS__) && defined(__TURBOC__) && (__TURBOC__ < 0x0150)
+#else
+    LZOCHK_ASSERT((LZO_STATIC_CAST(lzo_uint16e_t, (~LZO_STATIC_CAST(lzo_uint16e_t,0ul))) >> 15) == 1)
+#endif
+    LZOCHK_ASSERT( LZO_STATIC_CAST(lzo_int16e_t, (1 + ~LZO_STATIC_CAST(lzo_int16e_t, 0))) == 0)
+#if defined(LZOCHK_CFG_PEDANTIC)
+    LZOCHK_ASSERT( LZO_STATIC_CAST(lzo_uint16e_t, (1 + ~LZO_STATIC_CAST(lzo_uint16e_t, 0))) == 0)
+#endif
+#endif
+#if defined(lzo_int32e_t)
+    LZOCHK_ASSERT(sizeof(lzo_int32e_t) == 4)
+    LZOCHK_ASSERT(sizeof(lzo_int32e_t) == LZO_SIZEOF_LZO_INT32E_T)
+    LZOCHK_ASSERT(sizeof(lzo_uint32e_t) == 4)
+    LZOCHK_ASSERT(sizeof(lzo_int32e_t) == sizeof(lzo_uint32e_t))
+    LZOCHK_ASSERT_IS_SIGNED_T(lzo_int32e_t)
+    LZOCHK_ASSERT(((( LZO_STATIC_CAST(lzo_int32e_t, 1) << 30) + 1) >> 30) == 1)
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_uint32e_t)
+    LZOCHK_ASSERT(((( LZO_STATIC_CAST(lzo_uint32e_t, 1) << 31) + 1) >> 31) == 1)
+    LZOCHK_ASSERT((LZO_STATIC_CAST(lzo_uint32e_t, (~LZO_STATIC_CAST(lzo_uint32e_t, 0ul))) >> 31) == 1)
+    LZOCHK_ASSERT( LZO_STATIC_CAST(lzo_int32e_t, (1 + ~LZO_STATIC_CAST(lzo_int32e_t, 0))) == 0)
+#if defined(LZOCHK_CFG_PEDANTIC)
+    LZOCHK_ASSERT( LZO_STATIC_CAST(lzo_uint32e_t, (1 + ~LZO_STATIC_CAST(lzo_uint32e_t, 0))) == 0)
+#endif
+#endif
+#if defined(lzo_int32e_t)
+    LZOCHK_ASSERT(sizeof(lzo_int32l_t) >= sizeof(lzo_int32e_t))
+#endif
+    LZOCHK_ASSERT(sizeof(lzo_int32l_t) >= 4)
+    LZOCHK_ASSERT(sizeof(lzo_int32l_t) == LZO_SIZEOF_LZO_INT32L_T)
+    LZOCHK_ASSERT(sizeof(lzo_uint32l_t) >= 4)
+    LZOCHK_ASSERT(sizeof(lzo_int32l_t) == sizeof(lzo_uint32l_t))
+    LZOCHK_ASSERT_IS_SIGNED_T(lzo_int32l_t)
+    LZOCHK_ASSERT(((( LZO_STATIC_CAST(lzo_int32l_t, 1) << 30) + 1) >> 30) == 1)
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_uint32l_t)
+    LZOCHK_ASSERT(((( LZO_STATIC_CAST(lzo_uint32l_t, 1) << 31) + 1) >> 31) == 1)
+    LZOCHK_ASSERT(sizeof(lzo_int32f_t) >= sizeof(int))
+#if defined(lzo_int32e_t)
+    LZOCHK_ASSERT(sizeof(lzo_int32f_t) >= sizeof(lzo_int32e_t))
+#endif
+    LZOCHK_ASSERT(sizeof(lzo_int32f_t) >= sizeof(lzo_int32l_t))
+    LZOCHK_ASSERT(sizeof(lzo_int32f_t) >= 4)
+    LZOCHK_ASSERT(sizeof(lzo_int32f_t) >= sizeof(lzo_int32l_t))
+    LZOCHK_ASSERT(sizeof(lzo_int32f_t) == LZO_SIZEOF_LZO_INT32F_T)
+    LZOCHK_ASSERT(sizeof(lzo_uint32f_t) >= 4)
+    LZOCHK_ASSERT(sizeof(lzo_uint32f_t) >= sizeof(lzo_uint32l_t))
+    LZOCHK_ASSERT(sizeof(lzo_int32f_t) == sizeof(lzo_uint32f_t))
+    LZOCHK_ASSERT_IS_SIGNED_T(lzo_int32f_t)
+    LZOCHK_ASSERT(((( LZO_STATIC_CAST(lzo_int32f_t, 1) << 30) + 1) >> 30) == 1)
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_uint32f_t)
+    LZOCHK_ASSERT(((( LZO_STATIC_CAST(lzo_uint32f_t, 1) << 31) + 1) >> 31) == 1)
+#if defined(lzo_int64e_t)
+    LZOCHK_ASSERT(sizeof(lzo_int64e_t) == 8)
+    LZOCHK_ASSERT(sizeof(lzo_int64e_t) == LZO_SIZEOF_LZO_INT64E_T)
+    LZOCHK_ASSERT(sizeof(lzo_uint64e_t) == 8)
+    LZOCHK_ASSERT(sizeof(lzo_int64e_t) == sizeof(lzo_uint64e_t))
+    LZOCHK_ASSERT_IS_SIGNED_T(lzo_int64e_t)
+#if (LZO_CC_BORLANDC && (__BORLANDC__ < 0x0530))
+#else
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_uint64e_t)
+#endif
+#endif
+#if defined(lzo_int64l_t)
+#if defined(lzo_int64e_t)
+    LZOCHK_ASSERT(sizeof(lzo_int64l_t) >= sizeof(lzo_int64e_t))
+#endif
+    LZOCHK_ASSERT(sizeof(lzo_int64l_t) >= 8)
+    LZOCHK_ASSERT(sizeof(lzo_int64l_t) == LZO_SIZEOF_LZO_INT64L_T)
+    LZOCHK_ASSERT(sizeof(lzo_uint64l_t) >= 8)
+    LZOCHK_ASSERT(sizeof(lzo_int64l_t) == sizeof(lzo_uint64l_t))
+    LZOCHK_ASSERT_IS_SIGNED_T(lzo_int64l_t)
+    LZOCHK_ASSERT(((( LZO_STATIC_CAST(lzo_int64l_t, 1) << 62) + 1) >> 62) == 1)
+    LZOCHK_ASSERT(((( LZO_INT64_C(1) << 62) + 1) >> 62) == 1)
+#if (LZO_CC_BORLANDC && (__BORLANDC__ < 0x0530))
+#else
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_uint64l_t)
+    LZOCHK_ASSERT(LZO_UINT64_C(18446744073709551615)     > 0)
+#endif
+    LZOCHK_ASSERT(((( LZO_STATIC_CAST(lzo_uint64l_t, 1) << 63) + 1) >> 63) == 1)
+    LZOCHK_ASSERT(((( LZO_UINT64_C(1) << 63) + 1) >> 63) == 1)
+#if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020600ul))
+    LZOCHK_ASSERT(LZO_INT64_C(9223372036854775807)       > LZO_INT64_C(0))
+#else
+    LZOCHK_ASSERT(LZO_INT64_C(9223372036854775807)       > 0)
+#endif
+    LZOCHK_ASSERT(LZO_INT64_C(-9223372036854775807) - 1  < 0)
+    LZOCHK_ASSERT( LZO_INT64_C(9223372036854775807) % LZO_INT32_C(2147483629)  == 721)
+    LZOCHK_ASSERT( LZO_INT64_C(9223372036854775807) % LZO_INT32_C(2147483647)  == 1)
+    LZOCHK_ASSERT(LZO_UINT64_C(9223372036854775807) % LZO_UINT32_C(2147483629) == 721)
+    LZOCHK_ASSERT(LZO_UINT64_C(9223372036854775807) % LZO_UINT32_C(2147483647) == 1)
+#endif
+#if defined(lzo_int64f_t)
+#if defined(lzo_int64e_t)
+    LZOCHK_ASSERT(sizeof(lzo_int64f_t) >= sizeof(lzo_int64e_t))
+#endif
+    LZOCHK_ASSERT(sizeof(lzo_int64f_t) >= sizeof(lzo_int64l_t))
+    LZOCHK_ASSERT(sizeof(lzo_int64f_t) >= 8)
+    LZOCHK_ASSERT(sizeof(lzo_int64f_t) >= sizeof(lzo_int64l_t))
+    LZOCHK_ASSERT(sizeof(lzo_int64f_t) == LZO_SIZEOF_LZO_INT64F_T)
+    LZOCHK_ASSERT(sizeof(lzo_uint64f_t) >= 8)
+    LZOCHK_ASSERT(sizeof(lzo_uint64f_t) >= sizeof(lzo_uint64l_t))
+    LZOCHK_ASSERT(sizeof(lzo_int64f_t) == sizeof(lzo_uint64f_t))
+    LZOCHK_ASSERT_IS_SIGNED_T(lzo_int64f_t)
+#if (LZO_CC_BORLANDC && (__BORLANDC__ < 0x0530))
+#else
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_uint64f_t)
+#endif
+#endif
+#if !defined(__LZO_INTPTR_T_IS_POINTER)
+    LZOCHK_ASSERT_IS_SIGNED_T(lzo_intptr_t)
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_uintptr_t)
+#endif
+    LZOCHK_ASSERT(sizeof(lzo_intptr_t) >= sizeof(void *))
+    LZOCHK_ASSERT(sizeof(lzo_intptr_t) == LZO_SIZEOF_LZO_INTPTR_T)
+    LZOCHK_ASSERT(sizeof(lzo_intptr_t) == sizeof(lzo_uintptr_t))
+#if defined(lzo_word_t)
+    LZOCHK_ASSERT(LZO_WORDSIZE == LZO_SIZEOF_LZO_WORD_T)
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_word_t)
+    LZOCHK_ASSERT_IS_SIGNED_T(lzo_sword_t)
+    LZOCHK_ASSERT(sizeof(lzo_word_t) == LZO_SIZEOF_LZO_WORD_T)
+    LZOCHK_ASSERT(sizeof(lzo_word_t) == sizeof(lzo_sword_t))
+#endif
+    LZOCHK_ASSERT(sizeof(lzo_int8_t) == 1)
+    LZOCHK_ASSERT(sizeof(lzo_uint8_t) == 1)
+    LZOCHK_ASSERT(sizeof(lzo_int8_t) == sizeof(lzo_uint8_t))
+    LZOCHK_ASSERT_IS_SIGNED_T(lzo_int8_t)
+    LZOCHK_ASSERT_IS_UNSIGNED_T(lzo_uint8_t)
+#if defined(LZO_INT16_C)
+    LZOCHK_ASSERT(sizeof(LZO_INT16_C(0)) >= 2)
+    LZOCHK_ASSERT(sizeof(LZO_UINT16_C(0)) >= 2)
+    LZOCHK_ASSERT((LZO_UINT16_C(0xffff) >> 15) == 1)
+#endif
+#if defined(LZO_INT32_C)
+    LZOCHK_ASSERT(sizeof(LZO_INT32_C(0)) >= 4)
+    LZOCHK_ASSERT(sizeof(LZO_UINT32_C(0)) >= 4)
+    LZOCHK_ASSERT((LZO_UINT32_C(0xffffffff) >> 31) == 1)
+#endif
+#if defined(LZO_INT64_C)
+#if (LZO_CC_BORLANDC && (__BORLANDC__ < 0x0560))
+#else
+    LZOCHK_ASSERT(sizeof(LZO_INT64_C(0)) >= 8)
+    LZOCHK_ASSERT(sizeof(LZO_UINT64_C(0)) >= 8)
+#endif
+    LZOCHK_ASSERT((LZO_UINT64_C(0xffffffffffffffff) >> 63) == 1)
+    LZOCHK_ASSERT((LZO_UINT64_C(0xffffffffffffffff) & ~0)  == LZO_UINT64_C(0xffffffffffffffff))
+    LZOCHK_ASSERT((LZO_UINT64_C(0xffffffffffffffff) & ~0l) == LZO_UINT64_C(0xffffffffffffffff))
+#if (SIZEOF_INT == 4)
+# if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020000ul))
+# else
+    LZOCHK_ASSERT((LZO_UINT64_C(0xffffffffffffffff) & (~0u+0u)) == 0xffffffffu)
+# endif
+#endif
+#if (SIZEOF_LONG == 4)
+# if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x020000ul))
+# else
+    LZOCHK_ASSERT((LZO_UINT64_C(0xffffffffffffffff) & (~0ul+0ul)) == 0xfffffffful)
+# endif
+#endif
+#endif
+#if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM)
+    LZOCHK_ASSERT(sizeof(void*) == 2)
+    LZOCHK_ASSERT(sizeof(ptrdiff_t) == 2)
+#elif (LZO_MM_COMPACT || LZO_MM_LARGE || LZO_MM_HUGE)
+    LZOCHK_ASSERT(sizeof(void*) == 4)
+#endif
+#if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_COMPACT)
+    LZOCHK_ASSERT(sizeof(void (*)(void)) == 2)
+#elif (LZO_MM_MEDIUM || LZO_MM_LARGE || LZO_MM_HUGE)
+    LZOCHK_ASSERT(sizeof(void (*)(void)) == 4)
+#endif
+#if (LZO_ABI_ILP32)
+    LZOCHK_ASSERT(sizeof(int) == 4)
+    LZOCHK_ASSERT(sizeof(long) == 4)
+    LZOCHK_ASSERT(sizeof(void*) == 4)
+    LZOCHK_ASSERT(sizeof(ptrdiff_t) == sizeof(void*))
+    LZOCHK_ASSERT(sizeof(size_t) == sizeof(void*))
+    LZOCHK_ASSERT(sizeof(lzo_intptr_t) == sizeof(void *))
+#endif
+#if (LZO_ABI_ILP64)
+    LZOCHK_ASSERT(sizeof(int) == 8)
+    LZOCHK_ASSERT(sizeof(long) == 8)
+    LZOCHK_ASSERT(sizeof(void*) == 8)
+    LZOCHK_ASSERT(sizeof(ptrdiff_t) == sizeof(void*))
+    LZOCHK_ASSERT(sizeof(size_t) == sizeof(void*))
+    LZOCHK_ASSERT(sizeof(lzo_intptr_t) == sizeof(void *))
+#endif
+#if (LZO_ABI_IP32L64)
+    LZOCHK_ASSERT(sizeof(int) == 4)
+    LZOCHK_ASSERT(sizeof(long) == 8)
+    LZOCHK_ASSERT(sizeof(void*) == 4)
+    LZOCHK_ASSERT(sizeof(ptrdiff_t) == sizeof(void*))
+    LZOCHK_ASSERT(sizeof(size_t) == sizeof(void*))
+    LZOCHK_ASSERT(sizeof(lzo_intptr_t) == sizeof(void *))
+#endif
+#if (LZO_ABI_LLP64)
+    LZOCHK_ASSERT(sizeof(int) == 4)
+    LZOCHK_ASSERT(sizeof(long) == 4)
+    LZOCHK_ASSERT(sizeof(void*) == 8)
+    LZOCHK_ASSERT(sizeof(ptrdiff_t) == sizeof(void*))
+    LZOCHK_ASSERT(sizeof(size_t) == sizeof(void*))
+    LZOCHK_ASSERT(sizeof(lzo_intptr_t) == sizeof(void *))
+#endif
+#if (LZO_ABI_LP32)
+    LZOCHK_ASSERT(sizeof(int) == 2)
+    LZOCHK_ASSERT(sizeof(long) == 4)
+    LZOCHK_ASSERT(sizeof(void*) == 4)
+    LZOCHK_ASSERT(sizeof(lzo_intptr_t) == sizeof(void *))
+#endif
+#if (LZO_ABI_LP64)
+    LZOCHK_ASSERT(sizeof(int) == 4)
+    LZOCHK_ASSERT(sizeof(long) == 8)
+    LZOCHK_ASSERT(sizeof(void*) == 8)
+    LZOCHK_ASSERT(sizeof(ptrdiff_t) == sizeof(void*))
+    LZOCHK_ASSERT(sizeof(size_t) == sizeof(void*))
+    LZOCHK_ASSERT(sizeof(lzo_intptr_t) == sizeof(void *))
+#endif
+#if (LZO_ARCH_I086)
+    LZOCHK_ASSERT(sizeof(size_t) == 2)
+    LZOCHK_ASSERT(sizeof(lzo_intptr_t) == sizeof(void *))
+#elif (LZO_ARCH_I386 || LZO_ARCH_M68K)
+    LZOCHK_ASSERT(sizeof(size_t) == 4)
+    LZOCHK_ASSERT(sizeof(ptrdiff_t) == 4)
+    LZOCHK_ASSERT(sizeof(lzo_intptr_t) == sizeof(void *))
+#endif
+#if (LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_WIN32)
+    LZOCHK_ASSERT(sizeof(size_t) == 4)
+    LZOCHK_ASSERT(sizeof(ptrdiff_t) == 4)
+    LZOCHK_ASSERT(sizeof(void (*)(void)) == 4)
+#elif (LZO_OS_WIN64)
+    LZOCHK_ASSERT(sizeof(size_t) == 8)
+    LZOCHK_ASSERT(sizeof(ptrdiff_t) == 8)
+    LZOCHK_ASSERT(sizeof(void (*)(void)) == 8)
+#endif
+#if (LZO_CC_NDPC)
+#elif (SIZEOF_INT > 1)
+    LZOCHK_ASSERT( LZO_STATIC_CAST(int, LZO_STATIC_CAST(unsigned char, LZO_STATIC_CAST(signed char, -1))) == 255)
+#endif
+#if defined(LZOCHK_CFG_PEDANTIC)
+#if (LZO_CC_KEILC)
+#elif (LZO_CC_NDPC)
+#elif !(LZO_BROKEN_INTEGRAL_PROMOTION) && (SIZEOF_INT > 1)
+    LZOCHK_ASSERT( ((LZO_STATIC_CAST(unsigned char, 128)) << LZO_STATIC_CAST(int, (8*sizeof(int)-8))) < 0)
+#endif
+#endif
+#if defined(LZOCHK_CFG_PEDANTIC)
+#if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0530) && (__BORLANDC__ < 0x0560))
+#  pragma option pop
+#endif
+#endif
+#endif
+#if defined(LZO_WANT_ACCLIB_VGET)
+#  undef LZO_WANT_ACCLIB_VGET
+#define __LZOLIB_VGET_CH_INCLUDED 1
+#if !defined(LZOLIB_PUBLIC)
+#  define LZOLIB_PUBLIC(r,f)                r __LZOLIB_FUNCNAME(f)
+#endif
+#if !defined(LZOLIB_PUBLIC_NOINLINE)
+#  if !defined(__lzo_noinline)
+#    define LZOLIB_PUBLIC_NOINLINE(r,f)     r __LZOLIB_FUNCNAME(f)
+#  elif (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x030400ul) || LZO_CC_LLVM)
+#    define LZOLIB_PUBLIC_NOINLINE(r,f)     __lzo_noinline __attribute__((__used__)) r __LZOLIB_FUNCNAME(f)
+#  else
+#    define LZOLIB_PUBLIC_NOINLINE(r,f)     __lzo_noinline r __LZOLIB_FUNCNAME(f)
+#  endif
+#endif
+extern void* volatile lzo_vget_ptr__;
+#if (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x030400ul) || LZO_CC_LLVM)
+void* volatile __attribute__((__used__)) lzo_vget_ptr__ = LZO_STATIC_CAST(void *, 0);
+#else
+void* volatile lzo_vget_ptr__ = LZO_STATIC_CAST(void *, 0);
+#endif
+#ifndef __LZOLIB_VGET_BODY
+#define __LZOLIB_VGET_BODY(T) \
+    if __lzo_unlikely(lzo_vget_ptr__) { \
+        typedef T __lzo_may_alias TT; \
+        unsigned char e; expr &= 255; e = LZO_STATIC_CAST(unsigned char, expr); \
+        * LZO_STATIC_CAST(TT *, lzo_vget_ptr__) = v; \
+        * LZO_STATIC_CAST(unsigned char *, lzo_vget_ptr__) = e; \
+        v = * LZO_STATIC_CAST(TT *, lzo_vget_ptr__); \
+    } \
+    return v;
+#endif
+LZOLIB_PUBLIC_NOINLINE(short, lzo_vget_short) (short v, int expr)
+{
+    __LZOLIB_VGET_BODY(short)
+}
+LZOLIB_PUBLIC_NOINLINE(int, lzo_vget_int) (int v, int expr)
+{
+    __LZOLIB_VGET_BODY(int)
+}
+LZOLIB_PUBLIC_NOINLINE(long, lzo_vget_long) (long v, int expr)
+{
+    __LZOLIB_VGET_BODY(long)
+}
+#if defined(lzo_int64l_t)
+LZOLIB_PUBLIC_NOINLINE(lzo_int64l_t, lzo_vget_lzo_int64l_t) (lzo_int64l_t v, int expr)
+{
+    __LZOLIB_VGET_BODY(lzo_int64l_t)
+}
+#endif
+LZOLIB_PUBLIC_NOINLINE(lzo_hsize_t, lzo_vget_lzo_hsize_t) (lzo_hsize_t v, int expr)
+{
+    __LZOLIB_VGET_BODY(lzo_hsize_t)
+}
+#if !(LZO_CFG_NO_DOUBLE)
+LZOLIB_PUBLIC_NOINLINE(double, lzo_vget_double) (double v, int expr)
+{
+    __LZOLIB_VGET_BODY(double)
+}
+#endif
+LZOLIB_PUBLIC_NOINLINE(lzo_hvoid_p, lzo_vget_lzo_hvoid_p) (lzo_hvoid_p v, int expr)
+{
+    __LZOLIB_VGET_BODY(lzo_hvoid_p)
+}
+#if (LZO_ARCH_I086 && LZO_CC_TURBOC && (__TURBOC__ == 0x0295)) && !defined(__cplusplus)
+LZOLIB_PUBLIC_NOINLINE(lzo_hvoid_p, lzo_vget_lzo_hvoid_cp) (const lzo_hvoid_p vv, int expr)
+{
+    lzo_hvoid_p v = (lzo_hvoid_p) vv;
+    __LZOLIB_VGET_BODY(lzo_hvoid_p)
+}
+#else
+LZOLIB_PUBLIC_NOINLINE(const lzo_hvoid_p, lzo_vget_lzo_hvoid_cp) (const lzo_hvoid_p v, int expr)
+{
+    __LZOLIB_VGET_BODY(const lzo_hvoid_p)
+}
+#endif
+#endif
+#if defined(LZO_WANT_ACCLIB_HMEMCPY)
+#  undef LZO_WANT_ACCLIB_HMEMCPY
+#define __LZOLIB_HMEMCPY_CH_INCLUDED 1
+#if !defined(LZOLIB_PUBLIC)
+#  define LZOLIB_PUBLIC(r,f)    r __LZOLIB_FUNCNAME(f)
+#endif
+LZOLIB_PUBLIC(int, lzo_hmemcmp) (const lzo_hvoid_p s1, const lzo_hvoid_p s2, lzo_hsize_t len)
+{
+#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMCMP)
+    const lzo_hbyte_p p1 = LZO_STATIC_CAST(const lzo_hbyte_p, s1);
+    const lzo_hbyte_p p2 = LZO_STATIC_CAST(const lzo_hbyte_p, s2);
+    if __lzo_likely(len > 0) do
+    {
+        int d = *p1 - *p2;
+        if (d != 0)
+            return d;
+        p1++; p2++;
+    } while __lzo_likely(--len > 0);
+    return 0;
+#else
+    return memcmp(s1, s2, len);
+#endif
+}
+LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemcpy) (lzo_hvoid_p dest, const lzo_hvoid_p src, lzo_hsize_t len)
+{
+#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMCPY)
+    lzo_hbyte_p p1 = LZO_STATIC_CAST(lzo_hbyte_p, dest);
+    const lzo_hbyte_p p2 = LZO_STATIC_CAST(const lzo_hbyte_p, src);
+    if (!(len > 0) || p1 == p2)
+        return dest;
+    do
+        *p1++ = *p2++;
+    while __lzo_likely(--len > 0);
+    return dest;
+#else
+    return memcpy(dest, src, len);
+#endif
+}
+LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemmove) (lzo_hvoid_p dest, const lzo_hvoid_p src, lzo_hsize_t len)
+{
+#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMMOVE)
+    lzo_hbyte_p p1 = LZO_STATIC_CAST(lzo_hbyte_p, dest);
+    const lzo_hbyte_p p2 = LZO_STATIC_CAST(const lzo_hbyte_p, src);
+    if (!(len > 0) || p1 == p2)
+        return dest;
+    if (p1 < p2)
+    {
+        do
+            *p1++ = *p2++;
+        while __lzo_likely(--len > 0);
+    }
+    else
+    {
+        p1 += len;
+        p2 += len;
+        do
+            *--p1 = *--p2;
+        while __lzo_likely(--len > 0);
+    }
+    return dest;
+#else
+    return memmove(dest, src, len);
+#endif
+}
+LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemset) (lzo_hvoid_p s, int cc, lzo_hsize_t len)
+{
+#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMSET)
+    lzo_hbyte_p p = LZO_STATIC_CAST(lzo_hbyte_p, s);
+    unsigned char c = LZO_ITRUNC(unsigned char, cc);
+    if __lzo_likely(len > 0) do
+        *p++ = c;
+    while __lzo_likely(--len > 0);
+    return s;
+#else
+    return memset(s, cc, len);
+#endif
+}
+#endif
+#if defined(LZO_WANT_ACCLIB_RAND)
+#  undef LZO_WANT_ACCLIB_RAND
+#define __LZOLIB_RAND_CH_INCLUDED 1
+#if !defined(LZOLIB_PUBLIC)
+#  define LZOLIB_PUBLIC(r,f)    r __LZOLIB_FUNCNAME(f)
+#endif
+LZOLIB_PUBLIC(void, lzo_srand31) (lzo_rand31_p r, lzo_uint32l_t seed)
+{
+    r->seed = seed & LZO_UINT32_C(0xffffffff);
+}
+LZOLIB_PUBLIC(lzo_uint32l_t, lzo_rand31) (lzo_rand31_p r)
+{
+    r->seed = r->seed * LZO_UINT32_C(1103515245) + 12345;
+    r->seed &= LZO_UINT32_C(0x7fffffff);
+    return r->seed;
+}
+#if defined(lzo_int64l_t)
+LZOLIB_PUBLIC(void, lzo_srand48) (lzo_rand48_p r, lzo_uint32l_t seed)
+{
+    r->seed = seed & LZO_UINT32_C(0xffffffff);
+    r->seed <<= 16; r->seed |= 0x330e;
+}
+LZOLIB_PUBLIC(lzo_uint32l_t, lzo_rand48) (lzo_rand48_p r)
+{
+    lzo_uint64l_t a;
+    r->seed = r->seed * LZO_UINT64_C(25214903917) + 11;
+    r->seed &= LZO_UINT64_C(0xffffffffffff);
+    a = r->seed >> 17;
+    return LZO_STATIC_CAST(lzo_uint32l_t, a);
+}
+LZOLIB_PUBLIC(lzo_uint32l_t, lzo_rand48_r32) (lzo_rand48_p r)
+{
+    lzo_uint64l_t a;
+    r->seed = r->seed * LZO_UINT64_C(25214903917) + 11;
+    r->seed &= LZO_UINT64_C(0xffffffffffff);
+    a = r->seed >> 16;
+    return LZO_STATIC_CAST(lzo_uint32l_t, a);
+}
+#endif
+#if defined(lzo_int64l_t)
+LZOLIB_PUBLIC(void, lzo_srand64) (lzo_rand64_p r, lzo_uint64l_t seed)
+{
+    r->seed = seed & LZO_UINT64_C(0xffffffffffffffff);
+}
+LZOLIB_PUBLIC(lzo_uint32l_t, lzo_rand64) (lzo_rand64_p r)
+{
+    lzo_uint64l_t a;
+    r->seed = r->seed * LZO_UINT64_C(6364136223846793005) + 1;
+#if (LZO_SIZEOF_LZO_INT64L_T > 8)
+    r->seed &= LZO_UINT64_C(0xffffffffffffffff);
+#endif
+    a = r->seed >> 33;
+    return LZO_STATIC_CAST(lzo_uint32l_t, a);
+}
+LZOLIB_PUBLIC(lzo_uint32l_t, lzo_rand64_r32) (lzo_rand64_p r)
+{
+    lzo_uint64l_t a;
+    r->seed = r->seed * LZO_UINT64_C(6364136223846793005) + 1;
+#if (LZO_SIZEOF_LZO_INT64L_T > 8)
+    r->seed &= LZO_UINT64_C(0xffffffffffffffff);
+#endif
+    a = r->seed >> 32;
+    return LZO_STATIC_CAST(lzo_uint32l_t, a);
+}
+#endif
+LZOLIB_PUBLIC(void, lzo_srandmt) (lzo_randmt_p r, lzo_uint32l_t seed)
+{
+    unsigned i = 0;
+    do {
+        r->s[i++] = (seed &= LZO_UINT32_C(0xffffffff));
+        seed ^= seed >> 30;
+        seed = seed * LZO_UINT32_C(0x6c078965) + i;
+    } while (i != 624);
+    r->n = i;
+}
+LZOLIB_PUBLIC(lzo_uint32l_t, lzo_randmt) (lzo_randmt_p r)
+{
+    return (__LZOLIB_FUNCNAME(lzo_randmt_r32)(r)) >> 1;
+}
+LZOLIB_PUBLIC(lzo_uint32l_t, lzo_randmt_r32) (lzo_randmt_p r)
+{
+    lzo_uint32l_t v;
+    if __lzo_unlikely(r->n == 624) {
+        unsigned i = 0, j;
+        r->n = 0;
+        do {
+            j = i - 623; if (LZO_STATIC_CAST(int, j) < 0) j += 624;
+            v = (r->s[i] & LZO_UINT32_C(0x80000000)) ^ (r->s[j] & LZO_UINT32_C(0x7fffffff));
+            j = i - 227; if (LZO_STATIC_CAST(int, j) < 0) j += 624;
+            r->s[i] = r->s[j] ^ (v >> 1);
+            if (v & 1) r->s[i] ^= LZO_UINT32_C(0x9908b0df);
+        } while (++i != 624);
+    }
+    { unsigned i = r->n++; v = r->s[i]; }
+    v ^= v >> 11; v ^= (v & LZO_UINT32_C(0x013a58ad)) << 7;
+    v ^= (v & LZO_UINT32_C(0x0001df8c)) << 15; v ^= v >> 18;
+    return v;
+}
+#if defined(lzo_int64l_t)
+LZOLIB_PUBLIC(void, lzo_srandmt64) (lzo_randmt64_p r, lzo_uint64l_t seed)
+{
+    unsigned i = 0;
+    do {
+        r->s[i++] = (seed &= LZO_UINT64_C(0xffffffffffffffff));
+        seed ^= seed >> 62;
+        seed = seed * LZO_UINT64_C(0x5851f42d4c957f2d) + i;
+    } while (i != 312);
+    r->n = i;
+}
+#if 0
+LZOLIB_PUBLIC(lzo_uint32l_t, lzo_randmt64) (lzo_randmt64_p r)
+{
+    lzo_uint64l_t v;
+    v = (__LZOLIB_FUNCNAME(lzo_randmt64_r64)(r)) >> 33;
+    return LZO_STATIC_CAST(lzo_uint32l_t, v);
+}
+#endif
+LZOLIB_PUBLIC(lzo_uint64l_t, lzo_randmt64_r64) (lzo_randmt64_p r)
+{
+    lzo_uint64l_t v;
+    if __lzo_unlikely(r->n == 312) {
+        unsigned i = 0, j;
+        r->n = 0;
+        do {
+            j = i - 311; if (LZO_STATIC_CAST(int, j) < 0) j += 312;
+            v = (r->s[i] & LZO_UINT64_C(0xffffffff80000000)) ^ (r->s[j] & LZO_UINT64_C(0x7fffffff));
+            j = i - 156; if (LZO_STATIC_CAST(int, j) < 0) j += 312;
+            r->s[i] = r->s[j] ^ (v >> 1);
+            if (v & 1) r->s[i] ^= LZO_UINT64_C(0xb5026f5aa96619e9);
+        } while (++i != 312);
+    }
+    { unsigned i = r->n++; v = r->s[i]; }
+    v ^= (v & LZO_UINT64_C(0xaaaaaaaaa0000000)) >> 29;
+    v ^= (v & LZO_UINT64_C(0x38eb3ffff6d3)) << 17;
+    v ^= (v & LZO_UINT64_C(0x7ffbf77)) << 37;
+    return v ^ (v >> 43);
+}
+#endif
+#endif
+#if defined(LZO_WANT_ACCLIB_RDTSC)
+#  undef LZO_WANT_ACCLIB_RDTSC
+#define __LZOLIB_RDTSC_CH_INCLUDED 1
+#if !defined(LZOLIB_PUBLIC)
+#  define LZOLIB_PUBLIC(r,f)    r __LZOLIB_FUNCNAME(f)
+#endif
+#if defined(lzo_int32e_t)
+#if (LZO_OS_WIN32 && LZO_CC_PELLESC && (__POCC__ >= 290))
+#  pragma warn(push)
+#  pragma warn(disable:2007)
+#endif
+#if (LZO_ARCH_AMD64 || LZO_ARCH_I386) && (LZO_ASM_SYNTAX_GNUC)
+#if (LZO_ARCH_AMD64 && LZO_CC_INTELC)
+#  define __LZOLIB_RDTSC_REGS   : : "c" (t) : "memory", "rax", "rdx"
+#elif (LZO_ARCH_AMD64)
+#  define __LZOLIB_RDTSC_REGS   : : "c" (t) : "cc", "memory", "rax", "rdx"
+#elif (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC < 0x020000ul))
+#  define __LZOLIB_RDTSC_REGS   : : "c" (t) : "ax", "dx"
+#elif (LZO_ARCH_I386 && LZO_CC_INTELC)
+#  define __LZOLIB_RDTSC_REGS   : : "c" (t) : "memory", "eax", "edx"
+#else
+#  define __LZOLIB_RDTSC_REGS   : : "c" (t) : "cc", "memory", "eax", "edx"
+#endif
+#endif
+LZOLIB_PUBLIC(int, lzo_tsc_read) (lzo_uint32e_t* t)
+{
+#if (LZO_ARCH_AMD64 || LZO_ARCH_I386) && (LZO_ASM_SYNTAX_GNUC)
+    __asm__ __volatile__(
+        "clc \n" ".byte 0x0f,0x31\n"
+        "movl %%eax,(%0)\n" "movl %%edx,4(%0)\n"
+        __LZOLIB_RDTSC_REGS
+    );
+    return 0;
+#elif (LZO_ARCH_I386) && (LZO_ASM_SYNTAX_MSC)
+    LZO_UNUSED(t);
+    __asm {
+        mov ecx, t
+        clc
+#  if (LZO_CC_MSC && (_MSC_VER < 1200))
+        _emit 0x0f
+        _emit 0x31
+#  else
+        rdtsc
+#  endif
+        mov [ecx], eax
+        mov [ecx+4], edx
+    }
+    return 0;
+#else
+    t[0] = t[1] = 0; return -1;
+#endif
+}
+#if (LZO_OS_WIN32 && LZO_CC_PELLESC && (__POCC__ >= 290))
+#  pragma warn(pop)
+#endif
+#endif
+#endif
+#if defined(LZO_WANT_ACCLIB_DOSALLOC)
+#  undef LZO_WANT_ACCLIB_DOSALLOC
+#define __LZOLIB_DOSALLOC_CH_INCLUDED 1
+#if !defined(LZOLIB_PUBLIC)
+#  define LZOLIB_PUBLIC(r,f)    r __LZOLIB_FUNCNAME(f)
+#endif
+#if (LZO_OS_OS216)
+LZO_EXTERN_C unsigned short __far __pascal DosAllocHuge(unsigned short, unsigned short, unsigned short __far *, unsigned short, unsigned short);
+LZO_EXTERN_C unsigned short __far __pascal DosFreeSeg(unsigned short);
+#endif
+#if (LZO_OS_DOS16 || LZO_OS_WIN16)
+#if !(LZO_CC_AZTECC)
+LZOLIB_PUBLIC(void __far*, lzo_dos_alloc) (unsigned long size)
+{
+    void __far* p = 0;
+    union REGS ri, ro;
+    if ((long)size <= 0)
+        return p;
+    size = (size + 15) >> 4;
+    if (size > 0xffffu)
+        return p;
+    ri.x.ax = 0x4800;
+    ri.x.bx = (unsigned short) size;
+    int86(0x21, &ri, &ro);
+    if ((ro.x.cflag & 1) == 0)
+        p = (void __far*) LZO_PTR_MK_FP(ro.x.ax, 0);
+    return p;
+}
+LZOLIB_PUBLIC(int, lzo_dos_free) (void __far* p)
+{
+    union REGS ri, ro;
+    struct SREGS rs;
+    if (!p)
+        return 0;
+    if (LZO_PTR_FP_OFF(p) != 0)
+        return -1;
+    segread(&rs);
+    ri.x.ax = 0x4900;
+    rs.es = LZO_PTR_FP_SEG(p);
+    int86x(0x21, &ri, &ro, &rs);
+    if (ro.x.cflag & 1)
+        return -1;
+    return 0;
+}
+#endif
+#endif
+#if (LZO_OS_OS216)
+LZOLIB_PUBLIC(void __far*, lzo_dos_alloc) (unsigned long size)
+{
+    void __far* p = 0;
+    unsigned short sel = 0;
+    if ((long)size <= 0)
+        return p;
+    if (DosAllocHuge((unsigned short)(size >> 16), (unsigned short)size, &sel, 0, 0) == 0)
+        p = (void __far*) LZO_PTR_MK_FP(sel, 0);
+    return p;
+}
+LZOLIB_PUBLIC(int, lzo_dos_free) (void __far* p)
+{
+    if (!p)
+        return 0;
+    if (LZO_PTR_FP_OFF(p) != 0)
+        return -1;
+    if (DosFreeSeg(LZO_PTR_FP_SEG(p)) != 0)
+        return -1;
+    return 0;
+}
+#endif
+#endif
+#if defined(LZO_WANT_ACCLIB_GETOPT)
+#  undef LZO_WANT_ACCLIB_GETOPT
+#define __LZOLIB_GETOPT_CH_INCLUDED 1
+#if !defined(LZOLIB_PUBLIC)
+#  define LZOLIB_PUBLIC(r,f)    r __LZOLIB_FUNCNAME(f)
+#endif
+LZOLIB_PUBLIC(void, lzo_getopt_init) (lzo_getopt_p g,
+                                      int start_argc, int argc, char** argv)
+{
+    memset(g, 0, sizeof(*g));
+    g->optind = start_argc;
+    g->argc = argc; g->argv = argv;
+    g->optopt = -1;
+}
+static int __LZOLIB_FUNCNAME(lzo_getopt_rotate) (char** p, int first, int middle, int last)
+{
+    int i = middle, n = middle - first;
+    if (first >= middle || middle >= last) return 0;
+    for (;;)
+    {
+        char* t = p[first]; p[first] = p[i]; p[i] = t;
+        if (++first == middle)
+        {
+            if (++i == last) break;
+            middle = i;
+        }
+        else if (++i == last)
+            i = middle;
+    }
+    return n;
+}
+static int __LZOLIB_FUNCNAME(lzo_getopt_perror) (lzo_getopt_p g, int ret, const char* f, ...)
+{
+    if (g->opterr)
+    {
+#if (HAVE_STDARG_H)
+        struct { va_list ap; } s;
+        va_start(s.ap, f);
+        g->opterr(g, f, &s);
+        va_end(s.ap);
+#else
+        g->opterr(g, f, NULL);
+#endif
+    }
+    ++g->errcount;
+    return ret;
+}
+LZOLIB_PUBLIC(int, lzo_getopt) (lzo_getopt_p g,
+                                const char* shortopts,
+                                const lzo_getopt_longopt_p longopts,
+                                int* longind)
+{
+#define pe  __LZOLIB_FUNCNAME(lzo_getopt_perror)
+    int ordering = LZO_GETOPT_PERMUTE;
+    int missing_arg_ret = g->bad_option;
+    char* a;
+    if (shortopts)
+    {
+        if (*shortopts == '-' || *shortopts == '+')
+            ordering = *shortopts++ == '-' ? LZO_GETOPT_RETURN_IN_ORDER : LZO_GETOPT_REQUIRE_ORDER;
+        if (*shortopts == ':')
+            missing_arg_ret = *shortopts++;
+    }
+    g->optarg = NULL;
+    if (g->optopt == -1)
+        g->optopt = g->bad_option;
+    if (longind)
+        *longind = -1;
+    if (g->eof)
+        return -1;
+    if (g->shortpos)
+        goto lzo_label_next_shortopt;
+    g->optind -= __LZOLIB_FUNCNAME(lzo_getopt_rotate)(g->argv, g->pending_rotate_first, g->pending_rotate_middle, g->optind);
+    g->pending_rotate_first = g->pending_rotate_middle = g->optind;
+    if (ordering == LZO_GETOPT_PERMUTE)
+    {
+        while (g->optind < g->argc && !(g->argv[g->optind][0] == '-' && g->argv[g->optind][1]))
+            ++g->optind;
+        g->pending_rotate_middle = g->optind;
+    }
+    if (g->optind >= g->argc)
+    {
+        g->optind = g->pending_rotate_first;
+        goto lzo_label_eof;
+    }
+    a = g->argv[g->optind];
+    if (a[0] == '-' && a[1] == '-')
+    {
+        size_t l = 0;
+        const lzo_getopt_longopt_p o;
+        const lzo_getopt_longopt_p o1 = NULL;
+        const lzo_getopt_longopt_p o2 = NULL;
+        int need_exact = 0;
+        ++g->optind;
+        if (!a[2])
+            goto lzo_label_eof;
+        for (a += 2; a[l] && a[l] != '=' && a[l] != '#'; )
+            ++l;
+        for (o = longopts; l && o && o->name; ++o)
+        {
+            if (strncmp(a, o->name, l) != 0)
+                continue;
+            if (!o->name[l])
+                goto lzo_label_found_o;
+            need_exact |= o->has_arg & LZO_GETOPT_EXACT_ARG;
+            if (o1) o2 = o;
+            else    o1 = o;
+        }
+        if (!o1 || need_exact)
+            return pe(g, g->bad_option, "unrecognized option '--%s'", a);
+        if (o2)
+            return pe(g, g->bad_option, "option '--%s' is ambiguous (could be '--%s' or '--%s')", a, o1->name, o2->name);
+        o = o1;
+    lzo_label_found_o:
+        a += l;
+        switch (o->has_arg & 0x2f)
+        {
+        case LZO_GETOPT_OPTIONAL_ARG:
+            if (a[0])
+                g->optarg = a + 1;
+            break;
+        case LZO_GETOPT_REQUIRED_ARG:
+            if (a[0])
+                g->optarg = a + 1;
+            else if (g->optind < g->argc)
+                g->optarg = g->argv[g->optind++];
+            if (!g->optarg)
+                return pe(g, missing_arg_ret, "option '--%s' requires an argument", o->name);
+            break;
+        case LZO_GETOPT_REQUIRED_ARG | 0x20:
+            if (a[0] && a[1])
+                g->optarg = a + 1;
+            if (!g->optarg)
+                return pe(g, missing_arg_ret, "option '--%s=' requires an argument", o->name);
+            break;
+        default:
+            if (a[0])
+                return pe(g, g->bad_option, "option '--%s' doesn't allow an argument", o->name);
+            break;
+        }
+        if (longind)
+            *longind = (int) (o - longopts);
+        if (o->flag)
+        {
+            *o->flag = o->val;
+            return 0;
+        }
+        return o->val;
+    }
+    if (a[0] == '-' && a[1])
+    {
+        unsigned char c;
+        const char* s;
+    lzo_label_next_shortopt:
+        a = g->argv[g->optind] + ++g->shortpos;
+        c = (unsigned char) *a++; s = NULL;
+        if (c != ':' && shortopts)
+            s = strchr(shortopts, c);
+        if (!s || s[1] != ':')
+        {
+            if (!a[0])
+                ++g->optind, g->shortpos = 0;
+            if (!s)
+            {
+                g->optopt = c;
+                return pe(g, g->bad_option, "invalid option '-%c'", c);
+            }
+        }
+        else
+        {
+            ++g->optind, g->shortpos = 0;
+            if (a[0])
+                g->optarg = a;
+            else if (s[2] != ':')
+            {
+                if (g->optind < g->argc)
+                    g->optarg = g->argv[g->optind++];
+                else
+                {
+                    g->optopt = c;
+                    return pe(g, missing_arg_ret, "option '-%c' requires an argument", c);
+                }
+            }
+        }
+        return c;
+    }
+    if (ordering == LZO_GETOPT_RETURN_IN_ORDER)
+    {
+        ++g->optind;
+        g->optarg = a;
+        return 1;
+    }
+lzo_label_eof:
+    g->optind -= __LZOLIB_FUNCNAME(lzo_getopt_rotate)(g->argv, g->pending_rotate_first, g->pending_rotate_middle, g->optind);
+    g->pending_rotate_first = g->pending_rotate_middle = g->optind;
+    g->eof = 1;
+    return -1;
+#undef pe
+}
+#endif
+#if defined(LZO_WANT_ACCLIB_HALLOC)
+#  undef LZO_WANT_ACCLIB_HALLOC
+#define __LZOLIB_HALLOC_CH_INCLUDED 1
+#if !defined(LZOLIB_PUBLIC)
+#  define LZOLIB_PUBLIC(r,f)    r __LZOLIB_FUNCNAME(f)
+#endif
+#if (LZO_HAVE_MM_HUGE_PTR)
+#if 1 && (LZO_OS_DOS16 && defined(BLX286))
+#  define __LZOLIB_HALLOC_USE_DAH 1
+#elif 1 && (LZO_OS_DOS16 && defined(DOSX286))
+#  define __LZOLIB_HALLOC_USE_DAH 1
+#elif 1 && (LZO_OS_OS216)
+#  define __LZOLIB_HALLOC_USE_DAH 1
+#elif 1 && (LZO_OS_WIN16)
+#  define __LZOLIB_HALLOC_USE_GA 1
+#elif 1 && (LZO_OS_DOS16) && (LZO_CC_BORLANDC) && defined(__DPMI16__)
+#  define __LZOLIB_HALLOC_USE_GA 1
+#endif
+#endif
+#if (__LZOLIB_HALLOC_USE_DAH)
+#if 0 && (LZO_OS_OS216)
+#include <os2.h>
+#else
+LZO_EXTERN_C unsigned short __far __pascal DosAllocHuge(unsigned short, unsigned short, unsigned short __far *, unsigned short, unsigned short);
+LZO_EXTERN_C unsigned short __far __pascal DosFreeSeg(unsigned short);
+#endif
+#endif
+#if (__LZOLIB_HALLOC_USE_GA)
+#if 0
+#define STRICT 1
+#include <windows.h>
+#else
+LZO_EXTERN_C const void __near* __far __pascal GlobalAlloc(unsigned, unsigned long);
+LZO_EXTERN_C const void __near* __far __pascal GlobalFree(const void __near*);
+LZO_EXTERN_C unsigned long __far __pascal GlobalHandle(unsigned);
+LZO_EXTERN_C void __far* __far __pascal GlobalLock(const void __near*);
+LZO_EXTERN_C int __far __pascal GlobalUnlock(const void __near*);
+#endif
+#endif
+LZOLIB_PUBLIC(lzo_hvoid_p, lzo_halloc) (lzo_hsize_t size)
+{
+    lzo_hvoid_p p = LZO_STATIC_CAST(lzo_hvoid_p, 0);
+    if (!(size > 0))
+        return p;
+#if 0 && defined(__palmos__)
+    p = MemPtrNew(size);
+#elif !(LZO_HAVE_MM_HUGE_PTR)
+    if (size < LZO_STATIC_CAST(size_t, -1))
+        p = malloc(LZO_STATIC_CAST(size_t, size));
+#else
+    if (LZO_STATIC_CAST(long, size) <= 0)
+        return p;
+{
+#if (__LZOLIB_HALLOC_USE_DAH)
+    unsigned short sel = 0;
+    if (DosAllocHuge((unsigned short)(size >> 16), (unsigned short)size, &sel, 0, 0) == 0)
+        p = (lzo_hvoid_p) LZO_PTR_MK_FP(sel, 0);
+#elif (__LZOLIB_HALLOC_USE_GA)
+    const void __near* h = GlobalAlloc(2, size);
+    if (h) {
+        p = GlobalLock(h);
+        if (p && LZO_PTR_FP_OFF(p) != 0) {
+            GlobalUnlock(h);
+            p = 0;
+        }
+        if (!p)
+            GlobalFree(h);
+    }
+#elif (LZO_CC_MSC && (_MSC_VER >= 700))
+    p = _halloc(size, 1);
+#elif (LZO_CC_MSC || LZO_CC_WATCOMC)
+    p = halloc(size, 1);
+#elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
+    p = farmalloc(size);
+#elif (LZO_CC_BORLANDC || LZO_CC_TURBOC)
+    p = farmalloc(size);
+#elif (LZO_CC_AZTECC)
+    p = lmalloc(size);
+#else
+    if (size < LZO_STATIC_CAST(size_t, -1))
+        p = malloc((size_t) size);
+#endif
+}
+#endif
+    return p;
+}
+LZOLIB_PUBLIC(void, lzo_hfree) (lzo_hvoid_p p)
+{
+    if (!p)
+        return;
+#if 0 && defined(__palmos__)
+    MemPtrFree(p);
+#elif !(LZO_HAVE_MM_HUGE_PTR)
+    free(p);
+#else
+#if (__LZOLIB_HALLOC_USE_DAH)
+    if (LZO_PTR_FP_OFF(p) == 0)
+        DosFreeSeg((unsigned short) LZO_PTR_FP_SEG(p));
+#elif (__LZOLIB_HALLOC_USE_GA)
+    if (LZO_PTR_FP_OFF(p) == 0) {
+        const void __near* h = (const void __near*) (unsigned) GlobalHandle(LZO_PTR_FP_SEG(p));
+        if (h) {
+            GlobalUnlock(h);
+            GlobalFree(h);
+        }
+    }
+#elif (LZO_CC_MSC && (_MSC_VER >= 700))
+    _hfree(p);
+#elif (LZO_CC_MSC || LZO_CC_WATCOMC)
+    hfree(p);
+#elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
+    farfree((void __far*) p);
+#elif (LZO_CC_BORLANDC || LZO_CC_TURBOC)
+    farfree((void __far*) p);
+#elif (LZO_CC_AZTECC)
+    lfree(p);
+#else
+    free(p);
+#endif
+#endif
+}
+#endif
+#if defined(LZO_WANT_ACCLIB_HFREAD)
+#  undef LZO_WANT_ACCLIB_HFREAD
+#define __LZOLIB_HFREAD_CH_INCLUDED 1
+#if !defined(LZOLIB_PUBLIC)
+#  define LZOLIB_PUBLIC(r,f)    r __LZOLIB_FUNCNAME(f)
+#endif
+LZOLIB_PUBLIC(lzo_hsize_t, lzo_hfread) (void* vfp, lzo_hvoid_p buf, lzo_hsize_t size)
+{
+    FILE* fp = LZO_STATIC_CAST(FILE *, vfp);
+#if (LZO_HAVE_MM_HUGE_PTR)
+#if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM)
+#define __LZOLIB_REQUIRE_HMEMCPY_CH 1
+    unsigned char tmp[512];
+    lzo_hsize_t l = 0;
+    while (l < size)
+    {
+        size_t n = size - l > sizeof(tmp) ? sizeof(tmp) : (size_t) (size - l);
+        n = fread(tmp, 1, n, fp);
+        if (n == 0)
+            break;
+        __LZOLIB_FUNCNAME(lzo_hmemcpy)((lzo_hbyte_p)buf + l, tmp, (lzo_hsize_t)n);
+        l += n;
+    }
+    return l;
+#elif (LZO_MM_COMPACT || LZO_MM_LARGE || LZO_MM_HUGE)
+    lzo_hbyte_p b = (lzo_hbyte_p) buf;
+    lzo_hsize_t l = 0;
+    while (l < size)
+    {
+        size_t n;
+        n = LZO_PTR_FP_OFF(b); n = (n <= 1) ? 0x8000u : (0u - n);
+        if ((lzo_hsize_t) n > size - l)
+            n = (size_t) (size - l);
+        n = fread((void __far*)b, 1, n, fp);
+        if (n == 0)
+            break;
+        b += n; l += n;
+    }
+    return l;
+#else
+#  error "unknown memory model"
+#endif
+#else
+    return fread(buf, 1, size, fp);
+#endif
+}
+LZOLIB_PUBLIC(lzo_hsize_t, lzo_hfwrite) (void* vfp, const lzo_hvoid_p buf, lzo_hsize_t size)
+{
+    FILE* fp = LZO_STATIC_CAST(FILE *, vfp);
+#if (LZO_HAVE_MM_HUGE_PTR)
+#if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM)
+#define __LZOLIB_REQUIRE_HMEMCPY_CH 1
+    unsigned char tmp[512];
+    lzo_hsize_t l = 0;
+    while (l < size)
+    {
+        size_t n = size - l > sizeof(tmp) ? sizeof(tmp) : (size_t) (size - l);
+        __LZOLIB_FUNCNAME(lzo_hmemcpy)(tmp, (const lzo_hbyte_p)buf + l, (lzo_hsize_t)n);
+        n = fwrite(tmp, 1, n, fp);
+        if (n == 0)
+            break;
+        l += n;
+    }
+    return l;
+#elif (LZO_MM_COMPACT || LZO_MM_LARGE || LZO_MM_HUGE)
+    const lzo_hbyte_p b = (const lzo_hbyte_p) buf;
+    lzo_hsize_t l = 0;
+    while (l < size)
+    {
+        size_t n;
+        n = LZO_PTR_FP_OFF(b); n = (n <= 1) ? 0x8000u : (0u - n);
+        if ((lzo_hsize_t) n > size - l)
+            n = (size_t) (size - l);
+        n = fwrite((void __far*)b, 1, n, fp);
+        if (n == 0)
+            break;
+        b += n; l += n;
+    }
+    return l;
+#else
+#  error "unknown memory model"
+#endif
+#else
+    return fwrite(buf, 1, size, fp);
+#endif
+}
+#endif
+#if defined(LZO_WANT_ACCLIB_HSREAD)
+#  undef LZO_WANT_ACCLIB_HSREAD
+#define __LZOLIB_HSREAD_CH_INCLUDED 1
+#if !defined(LZOLIB_PUBLIC)
+#  define LZOLIB_PUBLIC(r,f)    r __LZOLIB_FUNCNAME(f)
+#endif
+LZOLIB_PUBLIC(long, lzo_safe_hread) (int fd, lzo_hvoid_p buf, long size)
+{
+    lzo_hbyte_p b = (lzo_hbyte_p) buf;
+    long l = 0;
+    int saved_errno;
+    saved_errno = errno;
+    while (l < size)
+    {
+        long n = size - l;
+#if (LZO_HAVE_MM_HUGE_PTR)
+#  define __LZOLIB_REQUIRE_HREAD_CH 1
+        errno = 0; n = lzo_hread(fd, b, n);
+#elif (LZO_OS_DOS32) && defined(__DJGPP__)
+        errno = 0; n = _read(fd, b, n);
+#else
+        errno = 0; n = read(fd, b, n);
+#endif
+        if (n == 0)
+            break;
+        if (n < 0) {
+#if defined(EAGAIN)
+            if (errno == (EAGAIN)) continue;
+#endif
+#if defined(EINTR)
+            if (errno == (EINTR)) continue;
+#endif
+            if (errno == 0) errno = 1;
+            return l;
+        }
+        b += n; l += n;
+    }
+    errno = saved_errno;
+    return l;
+}
+LZOLIB_PUBLIC(long, lzo_safe_hwrite) (int fd, const lzo_hvoid_p buf, long size)
+{
+    const lzo_hbyte_p b = (const lzo_hbyte_p) buf;
+    long l = 0;
+    int saved_errno;
+    saved_errno = errno;
+    while (l < size)
+    {
+        long n = size - l;
+#if (LZO_HAVE_MM_HUGE_PTR)
+#  define __LZOLIB_REQUIRE_HREAD_CH 1
+        errno = 0; n = lzo_hwrite(fd, b, n);
+#elif (LZO_OS_DOS32) && defined(__DJGPP__)
+        errno = 0; n = _write(fd, b, n);
+#else
+        errno = 0; n = write(fd, b, n);
+#endif
+        if (n == 0)
+            break;
+        if (n < 0) {
+#if defined(EAGAIN)
+            if (errno == (EAGAIN)) continue;
+#endif
+#if defined(EINTR)
+            if (errno == (EINTR)) continue;
+#endif
+            if (errno == 0) errno = 1;
+            return l;
+        }
+        b += n; l += n;
+    }
+    errno = saved_errno;
+    return l;
+}
+#endif
+#if defined(LZO_WANT_ACCLIB_PCLOCK)
+#  undef LZO_WANT_ACCLIB_PCLOCK
+#define __LZOLIB_PCLOCK_CH_INCLUDED 1
+#if !defined(LZOLIB_PUBLIC)
+#  define LZOLIB_PUBLIC(r,f)    r __LZOLIB_FUNCNAME(f)
+#endif
+#if 1 && (LZO_OS_POSIX_LINUX && LZO_ARCH_AMD64 && LZO_ASM_SYNTAX_GNUC)
+#ifndef lzo_pclock_syscall_clock_gettime
+#define lzo_pclock_syscall_clock_gettime lzo_pclock_syscall_clock_gettime
+#endif
+__lzo_static_noinline long lzo_pclock_syscall_clock_gettime(long clockid, struct timespec *ts)
+{
+    unsigned long r = 228;
+    __asm__ __volatile__("syscall\n" : "=a" (r) : "0" (r), "D" (clockid), "S" (ts) __LZO_ASM_CLOBBER_LIST_CC_MEMORY);
+    return LZO_ICAST(long, r);
+}
+#endif
+#if 1 && (LZO_OS_POSIX_LINUX && LZO_ARCH_I386 && LZO_ASM_SYNTAX_GNUC) && defined(lzo_int64l_t)
+#ifndef lzo_pclock_syscall_clock_gettime
+#define lzo_pclock_syscall_clock_gettime lzo_pclock_syscall_clock_gettime
+#endif
+__lzo_static_noinline long lzo_pclock_syscall_clock_gettime(long clockid, struct timespec *ts)
+{
+    unsigned long r = 265;
+    __asm__ __volatile__("pushl %%ebx\n pushl %%edx\n popl %%ebx\n int $0x80\n popl %%ebx\n" : "=a" (r) : "0" (r), "d" (clockid), "c" (ts) __LZO_ASM_CLOBBER_LIST_CC_MEMORY);
+    return LZO_ICAST(long, r);
+}
+#endif
+#if 0 && defined(lzo_pclock_syscall_clock_gettime)
+#ifndef lzo_pclock_read_clock_gettime_r_syscall
+#define lzo_pclock_read_clock_gettime_r_syscall lzo_pclock_read_clock_gettime_r_syscall
+#endif
+static int lzo_pclock_read_clock_gettime_r_syscall(lzo_pclock_handle_p h, lzo_pclock_p c)
+{
+     struct timespec ts;
+    if (lzo_pclock_syscall_clock_gettime(0, &ts) != 0)
+        return -1;
+    c->tv_sec = ts.tv_sec;
+    c->tv_nsec = LZO_STATIC_CAST(lzo_uint32l_t, ts.tv_nsec);
+    LZO_UNUSED(h); return 0;
+}
+#endif
+#if (HAVE_GETTIMEOFDAY)
+#ifndef lzo_pclock_read_gettimeofday
+#define lzo_pclock_read_gettimeofday lzo_pclock_read_gettimeofday
+#endif
+static int lzo_pclock_read_gettimeofday(lzo_pclock_handle_p h, lzo_pclock_p c)
+{
+    struct timeval tv;
+    if (gettimeofday(&tv, NULL) != 0)
+        return -1;
+#if defined(lzo_int64l_t)
+    c->tv_sec = tv.tv_sec;
+#else
+    c->tv_sec_high = 0;
+    c->tv_sec_low = tv.tv_sec;
+#endif
+    c->tv_nsec = LZO_STATIC_CAST(lzo_uint32l_t, (tv.tv_usec * 1000u));
+    LZO_UNUSED(h); return 0;
+}
+#endif
+#if defined(CLOCKS_PER_SEC) && !(LZO_CFG_NO_DOUBLE)
+#ifndef lzo_pclock_read_clock
+#define lzo_pclock_read_clock lzo_pclock_read_clock
+#endif
+static int lzo_pclock_read_clock(lzo_pclock_handle_p h, lzo_pclock_p c)
+{
+    clock_t ticks;
+    double secs;
+#if defined(lzo_int64l_t)
+    lzo_uint64l_t nsecs;
+    ticks = clock();
+    secs = LZO_STATIC_CAST(double, ticks) / (CLOCKS_PER_SEC);
+    nsecs = LZO_STATIC_CAST(lzo_uint64l_t, (secs * 1000000000.0));
+    c->tv_sec = LZO_STATIC_CAST(lzo_int64l_t, (nsecs / 1000000000ul));
+    nsecs = (nsecs % 1000000000ul);
+    c->tv_nsec = LZO_STATIC_CAST(lzo_uint32l_t, nsecs);
+#else
+    ticks = clock();
+    secs = LZO_STATIC_CAST(double, ticks) / (CLOCKS_PER_SEC);
+    c->tv_sec_high = 0;
+    c->tv_sec_low = LZO_STATIC_CAST(lzo_uint32l_t, (secs + 0.5));
+    c->tv_nsec = 0;
+#endif
+    LZO_UNUSED(h); return 0;
+}
+#endif
+#if 1 && defined(lzo_pclock_syscall_clock_gettime)
+#ifndef lzo_pclock_read_clock_gettime_m_syscall
+#define lzo_pclock_read_clock_gettime_m_syscall lzo_pclock_read_clock_gettime_m_syscall
+#endif
+static int lzo_pclock_read_clock_gettime_m_syscall(lzo_pclock_handle_p h, lzo_pclock_p c)
+{
+     struct timespec ts;
+    if (lzo_pclock_syscall_clock_gettime(1, &ts) != 0)
+        return -1;
+    c->tv_sec = ts.tv_sec;
+    c->tv_nsec = LZO_STATIC_CAST(lzo_uint32l_t, ts.tv_nsec);
+    LZO_UNUSED(h); return 0;
+}
+#endif
+#if (LZO_OS_DOS32 && LZO_CC_GNUC) && defined(__DJGPP__) && defined(UCLOCKS_PER_SEC) && !(LZO_CFG_NO_DOUBLE)
+#ifndef lzo_pclock_read_uclock
+#define lzo_pclock_read_uclock lzo_pclock_read_uclock
+#endif
+static int lzo_pclock_read_uclock(lzo_pclock_handle_p h, lzo_pclock_p c)
+{
+    lzo_uint64l_t ticks;
+    double secs;
+    lzo_uint64l_t nsecs;
+    ticks = uclock();
+    secs = LZO_STATIC_CAST(double, ticks) / (UCLOCKS_PER_SEC);
+    nsecs = LZO_STATIC_CAST(lzo_uint64l_t, (secs * 1000000000.0));
+    c->tv_sec = nsecs / 1000000000ul;
+    c->tv_nsec = LZO_STATIC_CAST(lzo_uint32l_t, (nsecs % 1000000000ul));
+    LZO_UNUSED(h); return 0;
+}
+#endif
+#if 1 && (HAVE_CLOCK_GETTIME) && defined(CLOCK_PROCESS_CPUTIME_ID) && defined(lzo_int64l_t)
+#ifndef lzo_pclock_read_clock_gettime_p_libc
+#define lzo_pclock_read_clock_gettime_p_libc lzo_pclock_read_clock_gettime_p_libc
+#endif
+static int lzo_pclock_read_clock_gettime_p_libc(lzo_pclock_handle_p h, lzo_pclock_p c)
+{
+    struct timespec ts;
+    if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts) != 0)
+        return -1;
+    c->tv_sec = ts.tv_sec;
+    c->tv_nsec = LZO_STATIC_CAST(lzo_uint32l_t, ts.tv_nsec);
+    LZO_UNUSED(h); return 0;
+}
+#endif
+#if 1 && defined(lzo_pclock_syscall_clock_gettime)
+#ifndef lzo_pclock_read_clock_gettime_p_syscall
+#define lzo_pclock_read_clock_gettime_p_syscall lzo_pclock_read_clock_gettime_p_syscall
+#endif
+static int lzo_pclock_read_clock_gettime_p_syscall(lzo_pclock_handle_p h, lzo_pclock_p c)
+{
+     struct timespec ts;
+    if (lzo_pclock_syscall_clock_gettime(2, &ts) != 0)
+        return -1;
+    c->tv_sec = ts.tv_sec;
+    c->tv_nsec = LZO_STATIC_CAST(lzo_uint32l_t, ts.tv_nsec);
+    LZO_UNUSED(h); return 0;
+}
+#endif
+#if (LZO_OS_CYGWIN || LZO_OS_WIN32 || LZO_OS_WIN64) && (LZO_HAVE_WINDOWS_H) && defined(lzo_int64l_t)
+#ifndef lzo_pclock_read_getprocesstimes
+#define lzo_pclock_read_getprocesstimes lzo_pclock_read_getprocesstimes
+#endif
+static int lzo_pclock_read_getprocesstimes(lzo_pclock_handle_p h, lzo_pclock_p c)
+{
+    FILETIME ct, et, kt, ut;
+    lzo_uint64l_t ticks;
+    if (GetProcessTimes(GetCurrentProcess(), &ct, &et, &kt, &ut) == 0)
+        return -1;
+    ticks = (LZO_STATIC_CAST(lzo_uint64l_t, ut.dwHighDateTime) << 32) | ut.dwLowDateTime;
+    if __lzo_unlikely(h->ticks_base == 0)
+        h->ticks_base = ticks;
+    else
+        ticks -= h->ticks_base;
+    c->tv_sec = LZO_STATIC_CAST(lzo_int64l_t, (ticks / 10000000ul));
+    ticks = (ticks % 10000000ul) * 100u;
+    c->tv_nsec = LZO_STATIC_CAST(lzo_uint32l_t, ticks);
+    LZO_UNUSED(h); return 0;
+}
+#endif
+#if (HAVE_GETRUSAGE) && defined(RUSAGE_SELF)
+#ifndef lzo_pclock_read_getrusage
+#define lzo_pclock_read_getrusage lzo_pclock_read_getrusage
+#endif
+static int lzo_pclock_read_getrusage(lzo_pclock_handle_p h, lzo_pclock_p c)
+{
+    struct rusage ru;
+    if (getrusage(RUSAGE_SELF, &ru) != 0)
+        return -1;
+#if defined(lzo_int64l_t)
+    c->tv_sec = ru.ru_utime.tv_sec;
+#else
+    c->tv_sec_high = 0;
+    c->tv_sec_low = ru.ru_utime.tv_sec;
+#endif
+    c->tv_nsec = LZO_STATIC_CAST(lzo_uint32l_t, (ru.ru_utime.tv_usec * 1000u));
+    LZO_UNUSED(h); return 0;
+}
+#endif
+#if 1 && (HAVE_CLOCK_GETTIME) && defined(CLOCK_THREAD_CPUTIME_ID) && defined(lzo_int64l_t)
+#ifndef lzo_pclock_read_clock_gettime_t_libc
+#define lzo_pclock_read_clock_gettime_t_libc lzo_pclock_read_clock_gettime_t_libc
+#endif
+static int lzo_pclock_read_clock_gettime_t_libc(lzo_pclock_handle_p h, lzo_pclock_p c)
+{
+    struct timespec ts;
+    if (clock_gettime(CLOCK_THREAD_CPUTIME_ID, &ts) != 0)
+        return -1;
+    c->tv_sec = ts.tv_sec;
+    c->tv_nsec = (lzo_uint32l_t) ts.tv_nsec;
+    LZO_UNUSED(h); return 0;
+}
+#endif
+#if 1 && defined(lzo_pclock_syscall_clock_gettime)
+#ifndef lzo_pclock_read_clock_gettime_t_syscall
+#define lzo_pclock_read_clock_gettime_t_syscall lzo_pclock_read_clock_gettime_t_syscall
+#endif
+static int lzo_pclock_read_clock_gettime_t_syscall(lzo_pclock_handle_p h, lzo_pclock_p c)
+{
+     struct timespec ts;
+    if (lzo_pclock_syscall_clock_gettime(3, &ts) != 0)
+        return -1;
+    c->tv_sec = ts.tv_sec;
+    c->tv_nsec = LZO_STATIC_CAST(lzo_uint32l_t, ts.tv_nsec);
+    LZO_UNUSED(h); return 0;
+}
+#endif
+#if (LZO_OS_CYGWIN || LZO_OS_WIN32 || LZO_OS_WIN64) && (LZO_HAVE_WINDOWS_H) && defined(lzo_int64l_t)
+#ifndef lzo_pclock_read_getthreadtimes
+#define lzo_pclock_read_getthreadtimes lzo_pclock_read_getthreadtimes
+#endif
+static int lzo_pclock_read_getthreadtimes(lzo_pclock_handle_p h, lzo_pclock_p c)
+{
+    FILETIME ct, et, kt, ut;
+    lzo_uint64l_t ticks;
+    if (GetThreadTimes(GetCurrentThread(), &ct, &et, &kt, &ut) == 0)
+        return -1;
+    ticks = (LZO_STATIC_CAST(lzo_uint64l_t, ut.dwHighDateTime) << 32) | ut.dwLowDateTime;
+    if __lzo_unlikely(h->ticks_base == 0)
+        h->ticks_base = ticks;
+    else
+        ticks -= h->ticks_base;
+    c->tv_sec = LZO_STATIC_CAST(lzo_int64l_t, (ticks / 10000000ul));
+    ticks = (ticks % 10000000ul) * 100u;
+    c->tv_nsec = LZO_STATIC_CAST(lzo_uint32l_t, ticks);
+    LZO_UNUSED(h); return 0;
+}
+#endif
+LZOLIB_PUBLIC(int, lzo_pclock_open) (lzo_pclock_handle_p h, int mode)
+{
+    lzo_pclock_t c;
+    int i;
+    h->h = LZO_STATIC_CAST(lzolib_handle_t, 0);
+    h->mode = -1;
+    h->read_error = 2;
+    h->name = NULL;
+    h->gettime = LZO_STATIC_CAST(lzo_pclock_gettime_t, 0);
+#if defined(lzo_int64l_t)
+    h->ticks_base = 0;
+#endif
+    switch (mode)
+    {
+    case LZO_PCLOCK_REALTIME:
+#     if defined(lzo_pclock_read_clock_gettime_r_syscall)
+        if (lzo_pclock_read_clock_gettime_r_syscall(h, &c) == 0) {
+            h->gettime = lzo_pclock_read_clock_gettime_r_syscall;
+            h->name = "CLOCK_REALTIME/syscall";
+            break;
+        }
+#     endif
+#     if defined(lzo_pclock_read_gettimeofday)
+        if (lzo_pclock_read_gettimeofday(h, &c) == 0) {
+            h->gettime = lzo_pclock_read_gettimeofday;
+            h->name = "gettimeofday";
+            break;
+        }
+#     endif
+        break;
+    case LZO_PCLOCK_MONOTONIC:
+#     if defined(lzo_pclock_read_clock_gettime_m_syscall)
+        if (lzo_pclock_read_clock_gettime_m_syscall(h, &c) == 0) {
+            h->gettime = lzo_pclock_read_clock_gettime_m_syscall;
+            h->name = "CLOCK_MONOTONIC/syscall";
+            break;
+        }
+#     endif
+#     if defined(lzo_pclock_read_uclock)
+        if (lzo_pclock_read_uclock(h, &c) == 0) {
+            h->gettime = lzo_pclock_read_uclock;
+            h->name = "uclock";
+            break;
+        }
+#     endif
+#     if defined(lzo_pclock_read_clock)
+        if (lzo_pclock_read_clock(h, &c) == 0) {
+            h->gettime = lzo_pclock_read_clock;
+            h->name = "clock";
+            break;
+        }
+#     endif
+        break;
+    case LZO_PCLOCK_PROCESS_CPUTIME_ID:
+#     if defined(lzo_pclock_read_getprocesstimes)
+        if (lzo_pclock_read_getprocesstimes(h, &c) == 0) {
+            h->gettime = lzo_pclock_read_getprocesstimes;
+            h->name = "GetProcessTimes";
+            break;
+        }
+#     endif
+#     if defined(lzo_pclock_read_clock_gettime_p_syscall)
+        if (lzo_pclock_read_clock_gettime_p_syscall(h, &c) == 0) {
+            h->gettime = lzo_pclock_read_clock_gettime_p_syscall;
+            h->name = "CLOCK_PROCESS_CPUTIME_ID/syscall";
+            break;
+        }
+#     endif
+#     if defined(lzo_pclock_read_clock_gettime_p_libc)
+        if (lzo_pclock_read_clock_gettime_p_libc(h, &c) == 0) {
+            h->gettime = lzo_pclock_read_clock_gettime_p_libc;
+            h->name = "CLOCK_PROCESS_CPUTIME_ID/libc";
+            break;
+        }
+#     endif
+#     if defined(lzo_pclock_read_getrusage)
+        if (lzo_pclock_read_getrusage(h, &c) == 0) {
+            h->gettime = lzo_pclock_read_getrusage;
+            h->name = "getrusage";
+            break;
+        }
+#     endif
+        break;
+    case LZO_PCLOCK_THREAD_CPUTIME_ID:
+#     if defined(lzo_pclock_read_getthreadtimes)
+        if (lzo_pclock_read_getthreadtimes(h, &c) == 0) {
+            h->gettime = lzo_pclock_read_getthreadtimes;
+            h->name = "GetThreadTimes";
+        }
+#     endif
+#     if defined(lzo_pclock_read_clock_gettime_t_syscall)
+        if (lzo_pclock_read_clock_gettime_t_syscall(h, &c) == 0) {
+            h->gettime = lzo_pclock_read_clock_gettime_t_syscall;
+            h->name = "CLOCK_THREAD_CPUTIME_ID/syscall";
+            break;
+        }
+#     endif
+#     if defined(lzo_pclock_read_clock_gettime_t_libc)
+        if (lzo_pclock_read_clock_gettime_t_libc(h, &c) == 0) {
+            h->gettime = lzo_pclock_read_clock_gettime_t_libc;
+            h->name = "CLOCK_THREAD_CPUTIME_ID/libc";
+            break;
+        }
+#     endif
+        break;
+    }
+    if (!h->gettime)
+        return -1;
+    if (!h->h)
+        h->h = LZO_STATIC_CAST(lzolib_handle_t, 1);
+    h->mode = mode;
+    h->read_error = 0;
+    if (!h->name)
+        h->name = "unknown";
+    for (i = 0; i < 10; i++) {
+        __LZOLIB_FUNCNAME(lzo_pclock_read)(h, &c);
+    }
+    return 0;
+}
+LZOLIB_PUBLIC(int, lzo_pclock_open_default) (lzo_pclock_handle_p h)
+{
+    if (__LZOLIB_FUNCNAME(lzo_pclock_open)(h, LZO_PCLOCK_PROCESS_CPUTIME_ID) == 0)
+        return 0;
+    if (__LZOLIB_FUNCNAME(lzo_pclock_open)(h, LZO_PCLOCK_MONOTONIC) == 0)
+        return 0;
+    if (__LZOLIB_FUNCNAME(lzo_pclock_open)(h, LZO_PCLOCK_REALTIME) == 0)
+        return 0;
+    if (__LZOLIB_FUNCNAME(lzo_pclock_open)(h, LZO_PCLOCK_THREAD_CPUTIME_ID) == 0)
+        return 0;
+    return -1;
+}
+LZOLIB_PUBLIC(int, lzo_pclock_close) (lzo_pclock_handle_p h)
+{
+    h->h = LZO_STATIC_CAST(lzolib_handle_t, 0);
+    h->mode = -1;
+    h->name = NULL;
+    h->gettime = LZO_STATIC_CAST(lzo_pclock_gettime_t, 0);
+    return 0;
+}
+LZOLIB_PUBLIC(void, lzo_pclock_read) (lzo_pclock_handle_p h, lzo_pclock_p c)
+{
+    if (h->gettime) {
+        if (h->gettime(h, c) == 0)
+            return;
+    }
+    h->read_error = 1;
+#if defined(lzo_int64l_t)
+    c->tv_sec = 0;
+#else
+    c->tv_sec_high = 0;
+    c->tv_sec_low = 0;
+#endif
+    c->tv_nsec = 0;
+}
+#if !(LZO_CFG_NO_DOUBLE)
+LZOLIB_PUBLIC(double, lzo_pclock_get_elapsed) (lzo_pclock_handle_p h, const lzo_pclock_p start, const lzo_pclock_p stop)
+{
+    if (!h->h) { h->mode = -1; return 0.0; }
+    {
+#if 1 && (LZO_ARCH_I386 && LZO_CC_GNUC) && defined(__STRICT_ALIGNMENT__)
+    float tstop, tstart;
+    tstop  = LZO_STATIC_CAST(float, (stop->tv_sec  + stop->tv_nsec  / 1000000000.0));
+    tstart = LZO_STATIC_CAST(float, (start->tv_sec + start->tv_nsec / 1000000000.0));
+#elif defined(lzo_int64l_t)
+    double tstop, tstart;
+#if 1 && (LZO_CC_INTELC)
+    { lzo_int64l_t a = stop->tv_sec; lzo_uint32l_t b = stop->tv_nsec;
+    tstop = a + b / 1000000000.0; }
+    { lzo_int64l_t a = start->tv_sec; lzo_uint32l_t b = start->tv_nsec;
+    tstart = a + b / 1000000000.0; }
+#else
+    tstop  = stop->tv_sec  + stop->tv_nsec  / 1000000000.0;
+    tstart = start->tv_sec + start->tv_nsec / 1000000000.0;
+#endif
+#else
+    double tstop, tstart;
+    tstop  = stop->tv_sec_low  + stop->tv_nsec  / 1000000000.0;
+    tstart = start->tv_sec_low + start->tv_nsec / 1000000000.0;
+#endif
+    return tstop - tstart;
+    }
+}
+#endif
+LZOLIB_PUBLIC(int, lzo_pclock_flush_cpu_cache) (lzo_pclock_handle_p h, unsigned flags)
+{
+    LZO_UNUSED(h); LZO_UNUSED(flags);
+    return -1;
+}
+#if defined(__LZOLIB_PCLOCK_NEED_WARN_POP)
+#  if (LZO_CC_MSC && (_MSC_VER >= 1200))
+#    pragma warning(pop)
+#  else
+#    error "__LZOLIB_PCLOCK_NEED_WARN_POP"
+#  endif
+#  undef __LZOLIB_PCLOCK_NEED_WARN_POP
+#endif
+#endif
+#if defined(LZO_WANT_ACCLIB_MISC)
+#  undef LZO_WANT_ACCLIB_MISC
+#define __LZOLIB_MISC_CH_INCLUDED 1
+#if !defined(LZOLIB_PUBLIC)
+#  define LZOLIB_PUBLIC(r,f)                r __LZOLIB_FUNCNAME(f)
+#endif
+#if !defined(LZOLIB_PUBLIC_NOINLINE)
+#  if !defined(__lzo_noinline)
+#    define LZOLIB_PUBLIC_NOINLINE(r,f)     r __LZOLIB_FUNCNAME(f)
+#  elif (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x030400ul) || LZO_CC_LLVM)
+#    define LZOLIB_PUBLIC_NOINLINE(r,f)     __lzo_noinline __attribute__((__used__)) r __LZOLIB_FUNCNAME(f)
+#  else
+#    define LZOLIB_PUBLIC_NOINLINE(r,f)     __lzo_noinline r __LZOLIB_FUNCNAME(f)
+#  endif
+#endif
+#if (LZO_OS_WIN32 && LZO_CC_PELLESC && (__POCC__ >= 290))
+#  pragma warn(push)
+#  pragma warn(disable:2007)
+#endif
+LZOLIB_PUBLIC(const char *, lzo_getenv) (const char *s)
+{
+#if (HAVE_GETENV)
+    return getenv(s);
+#else
+    LZO_UNUSED(s); return LZO_STATIC_CAST(const char *, 0);
+#endif
+}
+LZOLIB_PUBLIC(lzo_intptr_t, lzo_get_osfhandle) (int fd)
+{
+    if (fd < 0)
+        return -1;
+#if (LZO_OS_CYGWIN)
+    return get_osfhandle(fd);
+#elif (LZO_OS_EMX && defined(__RSXNT__))
+    return -1;
+#elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__PW32__)
+    return -1;
+#elif (LZO_OS_WIN32 || LZO_OS_WIN64)
+# if (LZO_CC_PELLESC && (__POCC__ < 280))
+    return -1;
+# elif (LZO_CC_WATCOMC && (__WATCOMC__ < 1000))
+    return -1;
+# elif (LZO_CC_WATCOMC && (__WATCOMC__ < 1100))
+    return _os_handle(fd);
+# else
+    return _get_osfhandle(fd);
+# endif
+#else
+    return fd;
+#endif
+}
+LZOLIB_PUBLIC(int, lzo_set_binmode) (int fd, int binary)
+{
+#if (LZO_ARCH_M68K && LZO_OS_TOS && LZO_CC_GNUC) && defined(__MINT__)
+    FILE* fp; int old_binary;
+    if (fd == STDIN_FILENO) fp = stdin;
+    else if (fd == STDOUT_FILENO) fp = stdout;
+    else if (fd == STDERR_FILENO) fp = stderr;
+    else return -1;
+    old_binary = fp->__mode.__binary;
+    __set_binmode(fp, binary ? 1 : 0);
+    return old_binary ? 1 : 0;
+#elif (LZO_ARCH_M68K && LZO_OS_TOS)
+    LZO_UNUSED(fd); LZO_UNUSED(binary);
+    return -1;
+#elif (LZO_OS_DOS16 && (LZO_CC_AZTECC || LZO_CC_PACIFICC))
+    LZO_UNUSED(fd); LZO_UNUSED(binary);
+    return -1;
+#elif (LZO_OS_DOS32 && LZO_CC_GNUC) && defined(__DJGPP__)
+    int r; unsigned old_flags = __djgpp_hwint_flags;
+    LZO_COMPILE_TIME_ASSERT(O_BINARY > 0)
+    LZO_COMPILE_TIME_ASSERT(O_TEXT > 0)
+    if (fd < 0) return -1;
+    r = setmode(fd, binary ? O_BINARY : O_TEXT);
+    if ((old_flags & 1u) != (__djgpp_hwint_flags & 1u))
+        __djgpp_set_ctrl_c(!(old_flags & 1));
+    if (r == -1) return -1;
+    return (r & O_TEXT) ? 0 : 1;
+#elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__PW32__)
+    if (fd < 0) return -1;
+    LZO_UNUSED(binary);
+    return 1;
+#elif (LZO_OS_DOS32 && LZO_CC_HIGHC)
+    FILE* fp; int r;
+    if (fd == fileno(stdin)) fp = stdin;
+    else if (fd == fileno(stdout)) fp = stdout;
+    else if (fd == fileno(stderr)) fp = stderr;
+    else return -1;
+    r = _setmode(fp, binary ? _BINARY : _TEXT);
+    if (r == -1) return -1;
+    return (r & _BINARY) ? 1 : 0;
+#elif (LZO_OS_WIN32 && LZO_CC_MWERKS) && defined(__MSL__)
+    LZO_UNUSED(fd); LZO_UNUSED(binary);
+    return -1;
+#elif (LZO_OS_CYGWIN && (LZO_CC_GNUC < 0x025a00ul))
+    LZO_UNUSED(fd); LZO_UNUSED(binary);
+    return -1;
+#elif (LZO_OS_CYGWIN || LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_EMX || LZO_OS_OS2 || LZO_OS_OS216 || LZO_OS_WIN16 || LZO_OS_WIN32 || LZO_OS_WIN64)
+    int r;
+#if !(LZO_CC_ZORTECHC)
+    LZO_COMPILE_TIME_ASSERT(O_BINARY > 0)
+#endif
+    LZO_COMPILE_TIME_ASSERT(O_TEXT > 0)
+    if (fd < 0) return -1;
+    r = setmode(fd, binary ? O_BINARY : O_TEXT);
+    if (r == -1) return -1;
+    return (r & O_TEXT) ? 0 : 1;
+#else
+    if (fd < 0) return -1;
+    LZO_UNUSED(binary);
+    return 1;
+#endif
+}
+LZOLIB_PUBLIC(int, lzo_isatty) (int fd)
+{
+    if (fd < 0)
+        return 0;
+#if (LZO_OS_DOS16 && !(LZO_CC_AZTECC))
+    {
+        union REGS ri, ro;
+        ri.x.ax = 0x4400; ri.x.bx = fd;
+        int86(0x21, &ri, &ro);
+        if ((ro.x.cflag & 1) == 0)
+            if ((ro.x.ax & 0x83) != 0x83)
+                return 0;
+    }
+#elif (LZO_OS_DOS32 && LZO_CC_WATCOMC)
+    {
+        union REGS ri, ro;
+        ri.w.ax = 0x4400; ri.w.bx = LZO_STATIC_CAST(unsigned short, fd);
+        int386(0x21, &ri, &ro);
+        if ((ro.w.cflag & 1) == 0)
+            if ((ro.w.ax & 0x83) != 0x83)
+                return 0;
+    }
+#elif (LZO_HAVE_WINDOWS_H)
+    {
+        lzo_intptr_t h = __LZOLIB_FUNCNAME(lzo_get_osfhandle)(fd);
+        LZO_COMPILE_TIME_ASSERT(sizeof(h) == sizeof(HANDLE))
+        if (h != -1)
+        {
+            DWORD d = 0;
+            if (GetConsoleMode(LZO_REINTERPRET_CAST(HANDLE, h), &d) == 0)
+                return 0;
+        }
+    }
+#endif
+#if (HAVE_ISATTY)
+    return (isatty(fd)) ? 1 : 0;
+#else
+    return 0;
+#endif
+}
+LZOLIB_PUBLIC(int, lzo_mkdir) (const char* name, unsigned mode)
+{
+#if !(HAVE_MKDIR)
+    LZO_UNUSED(name); LZO_UNUSED(mode);
+    return -1;
+#elif (LZO_ARCH_M68K && LZO_OS_TOS && (LZO_CC_PUREC || LZO_CC_TURBOC))
+    LZO_UNUSED(mode);
+    return Dcreate(name);
+#elif (LZO_OS_DOS32 && LZO_CC_GNUC) && defined(__DJGPP__)
+    return mkdir(name, mode);
+#elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__PW32__)
+    return mkdir(name, mode);
+#elif ((LZO_OS_DOS16 || LZO_OS_DOS32) && (LZO_CC_HIGHC || LZO_CC_PACIFICC))
+    LZO_UNUSED(mode);
+    return mkdir(LZO_UNCONST_CAST(char *, name));
+#elif (LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_OS216 || LZO_OS_WIN16 || LZO_OS_WIN32 || LZO_OS_WIN64)
+    LZO_UNUSED(mode);
+    return mkdir(name);
+#elif (LZO_CC_WATCOMC)
+    return mkdir(name, LZO_STATIC_CAST(mode_t, mode));
+#else
+    return mkdir(name, mode);
+#endif
+}
+LZOLIB_PUBLIC(int, lzo_rmdir) (const char* name)
+{
+#if !(HAVE_RMDIR)
+    LZO_UNUSED(name);
+    return -1;
+#elif ((LZO_OS_DOS16 || LZO_OS_DOS32) && (LZO_CC_HIGHC || LZO_CC_PACIFICC))
+    return rmdir(LZO_UNCONST_CAST(char *, name));
+#else
+    return rmdir(name);
+#endif
+}
+#if defined(lzo_int32e_t)
+LZOLIB_PUBLIC(lzo_int32e_t, lzo_muldiv32s) (lzo_int32e_t a, lzo_int32e_t b, lzo_int32e_t x)
+{
+    lzo_int32e_t r = 0;
+    if __lzo_likely(x != 0)
+    {
+#if defined(lzo_int64l_t)
+        lzo_int64l_t rr = (LZO_ICONV(lzo_int64l_t, a) * b) / x;
+        r = LZO_ITRUNC(lzo_int32e_t, rr);
+#else
+        LZO_UNUSED(a); LZO_UNUSED(b);
+#endif
+    }
+    return r;
+}
+LZOLIB_PUBLIC(lzo_uint32e_t, lzo_muldiv32u) (lzo_uint32e_t a, lzo_uint32e_t b, lzo_uint32e_t x)
+{
+    lzo_uint32e_t r = 0;
+    if __lzo_likely(x != 0)
+    {
+#if defined(lzo_int64l_t)
+        lzo_uint64l_t rr = (LZO_ICONV(lzo_uint64l_t, a) * b) / x;
+        r = LZO_ITRUNC(lzo_uint32e_t, rr);
+#else
+        LZO_UNUSED(a); LZO_UNUSED(b);
+#endif
+    }
+    return r;
+}
+#endif
+#if 0
+LZOLIB_PUBLIC_NOINLINE(int, lzo_syscall_clock_gettime) (int c)
+{
+}
+#endif
+#if (LZO_OS_WIN16)
+LZO_EXTERN_C void __far __pascal DebugBreak(void);
+#endif
+LZOLIB_PUBLIC_NOINLINE(void, lzo_debug_break) (void)
+{
+#if (LZO_OS_WIN16)
+    DebugBreak();
+#elif (LZO_ARCH_I086)
+#elif (LZO_OS_WIN64) && (LZO_HAVE_WINDOWS_H)
+    DebugBreak();
+#elif (LZO_ARCH_AMD64 || LZO_ARCH_I386) && (LZO_ASM_SYNTAX_GNUC)
+    __asm__ __volatile__("int $3\n" : : __LZO_ASM_CLOBBER_LIST_CC_MEMORY);
+#elif (LZO_ARCH_I386) && (LZO_ASM_SYNTAX_MSC)
+    __asm { int 3 }
+#elif (LZO_OS_WIN32) && (LZO_HAVE_WINDOWS_H)
+    DebugBreak();
+#else
+    volatile lzo_intptr_t a = -1;
+    * LZO_STATIC_CAST(volatile unsigned long *, LZO_REINTERPRET_CAST(volatile void *, a)) = ~0ul;
+#endif
+}
+LZOLIB_PUBLIC_NOINLINE(void, lzo_debug_nop) (void)
+{
+}
+LZOLIB_PUBLIC_NOINLINE(int, lzo_debug_align_check_query) (void)
+{
+#if (LZO_ARCH_AMD64 || LZO_ARCH_I386) && (LZO_ASM_SYNTAX_GNUC)
+# if (LZO_ARCH_AMD64)
+    lzo_uint64e_t r = 0;
+# else
+    size_t r = 0;
+# endif
+    __asm__ __volatile__("pushf\n pop %0\n" : "=a" (r) : __LZO_ASM_CLOBBER_LIST_CC_MEMORY);
+    return LZO_ICONV(int, (r >> 18) & 1);
+#elif (LZO_ARCH_I386) && (LZO_ASM_SYNTAX_MSC)
+    unsigned long r;
+    __asm {
+        pushf
+        pop eax
+        mov r,eax
+    }
+    return LZO_ICONV(int, (r >> 18) & 1);
+#else
+    return -1;
+#endif
+}
+LZOLIB_PUBLIC_NOINLINE(int, lzo_debug_align_check_enable) (int v)
+{
+#if (LZO_ARCH_AMD64) && (LZO_ASM_SYNTAX_GNUC)
+    if (v) {
+        __asm__ __volatile__("pushf\n orl $262144,(%%rsp)\n popf\n" : : __LZO_ASM_CLOBBER_LIST_CC_MEMORY);
+    } else {
+        __asm__ __volatile__("pushf\n andl $-262145,(%%rsp)\n popf\n" : : __LZO_ASM_CLOBBER_LIST_CC_MEMORY);
+    }
+    return 0;
+#elif (LZO_ARCH_I386) && (LZO_ASM_SYNTAX_GNUC)
+    if (v) {
+        __asm__ __volatile__("pushf\n orl $262144,(%%esp)\n popf\n" : : __LZO_ASM_CLOBBER_LIST_CC_MEMORY);
+    } else {
+        __asm__ __volatile__("pushf\n andl $-262145,(%%esp)\n popf\n" : : __LZO_ASM_CLOBBER_LIST_CC_MEMORY);
+    }
+    return 0;
+#elif (LZO_ARCH_I386) && (LZO_ASM_SYNTAX_MSC)
+    if (v) { __asm {
+        pushf
+        or dword ptr [esp],262144
+        popf
+    }} else { __asm {
+        pushf
+        and dword ptr [esp],-262145
+        popf
+    }}
+    return 0;
+#else
+    LZO_UNUSED(v); return -1;
+#endif
+}
+LZOLIB_PUBLIC_NOINLINE(unsigned, lzo_debug_running_on_qemu) (void)
+{
+    unsigned r = 0;
+#if (LZO_OS_POSIX_LINUX || LZO_OS_WIN32 || LZO_OS_WIN64)
+    const char* p;
+    p = __LZOLIB_FUNCNAME(lzo_getenv)(LZO_PP_STRINGIZE(LZO_ENV_RUNNING_ON_QEMU));
+    if (p) {
+        if (p[0] == 0) r = 0;
+        else if ((p[0] >= '0' && p[0] <= '9') && p[1] == 0) r = LZO_ICAST(unsigned, p[0]) - '0';
+        else r = 1;
+    }
+#endif
+    return r;
+}
+LZOLIB_PUBLIC_NOINLINE(unsigned, lzo_debug_running_on_valgrind) (void)
+{
+#if (LZO_ARCH_AMD64 && LZO_ABI_ILP32)
+    return 0;
+#elif (LZO_ARCH_AMD64 || LZO_ARCH_I386) && (LZO_ASM_SYNTAX_GNUC)
+    volatile size_t a[6];
+    size_t r = 0;
+    a[0] = 0x1001; a[1] = 0; a[2] = 0; a[3] = 0; a[4] = 0; a[5] = 0;
+#  if (LZO_ARCH_AMD64)
+    __asm__ __volatile__(".byte 0x48,0xc1,0xc7,0x03,0x48,0xc1,0xc7,0x0d,0x48,0xc1,0xc7,0x3d,0x48,0xc1,0xc7,0x33,0x48,0x87,0xdb\n" : "=d" (r) : "a" (&a[0]), "d" (r) __LZO_ASM_CLOBBER_LIST_CC_MEMORY);
+#  elif (LZO_ARCH_I386)
+    __asm__ __volatile__(".byte 0xc1,0xc7,0x03,0xc1,0xc7,0x0d,0xc1,0xc7,0x1d,0xc1,0xc7,0x13,0x87,0xdb\n" : "=d" (r) : "a" (&a[0]), "d" (r) __LZO_ASM_CLOBBER_LIST_CC_MEMORY);
+#  endif
+    return LZO_ITRUNC(unsigned, r);
+#else
+    return 0;
+#endif
+}
+#if (LZO_OS_WIN32 && LZO_CC_PELLESC && (__POCC__ >= 290))
+#  pragma warn(pop)
+#endif
+#endif
+#if defined(LZO_WANT_ACCLIB_WILDARGV)
+#  undef LZO_WANT_ACCLIB_WILDARGV
+#define __LZOLIB_WILDARGV_CH_INCLUDED 1
+#if !defined(LZOLIB_PUBLIC)
+#  define LZOLIB_PUBLIC(r,f)    r __LZOLIB_FUNCNAME(f)
+#endif
+#if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
+#if 0 && (LZO_CC_MSC)
+LZO_EXTERN_C int __lzo_cdecl __setargv(void);
+LZO_EXTERN_C int __lzo_cdecl _setargv(void);
+LZO_EXTERN_C int __lzo_cdecl _setargv(void) { return __setargv(); }
+#endif
+#endif
+#if (LZO_OS_WIN32 || LZO_OS_WIN64)
+#if (LZO_CC_INTELC || LZO_CC_MSC)
+LZO_EXTERN_C int __lzo_cdecl __setargv(void);
+LZO_EXTERN_C int __lzo_cdecl _setargv(void);
+LZO_EXTERN_C int __lzo_cdecl _setargv(void) { return __setargv(); }
+#endif
+#endif
+#if (LZO_OS_EMX)
+#define __LZOLIB_HAVE_LZO_WILDARGV 1
+LZOLIB_PUBLIC(void, lzo_wildargv) (int* argc, char*** argv)
+{
+    if (argc && argv) {
+        _response(argc, argv);
+        _wildcard(argc, argv);
+    }
+}
+#endif
+#if (LZO_OS_CONSOLE_PSP) && defined(__PSPSDK_DEBUG__)
+#define __LZOLIB_HAVE_LZO_WILDARGV 1
+LZO_EXTERN_C int lzo_psp_init_module(int*, char***, int);
+LZOLIB_PUBLIC(void, lzo_wildargv) (int* argc, char*** argv)
+{
+    lzo_psp_init_module(argc, argv, -1);
+}
+#endif
+#if !(__LZOLIB_HAVE_LZO_WILDARGV)
+#define __LZOLIB_HAVE_LZO_WILDARGV 1
+LZOLIB_PUBLIC(void, lzo_wildargv) (int* argc, char*** argv)
+{
+#if 1 && (LZO_ARCH_I086PM)
+    if (LZO_MM_AHSHIFT != 3) { exit(1); }
+#elif 1 && (LZO_ARCH_M68K && LZO_OS_TOS && LZO_CC_GNUC) && defined(__MINT__)
+    __binmode(1);
+    if (isatty(1)) __set_binmode(stdout, 0);
+    if (isatty(2)) __set_binmode(stderr, 0);
+#endif
+    LZO_UNUSED(argc); LZO_UNUSED(argv);
+}
+#endif
+#endif
+
+/* vim:set ts=4 sw=4 et: */
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo_swd.ch syslinux-4.07b/lzo/src/lzo_swd.ch
--- Syslinux-4.07a/lzo/src/lzo_swd.ch	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo_swd.ch	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -41,34 +29,27 @@
 #if (LZO_UINT_MAX < LZO_0xffffffffL)
 #  error "LZO_UINT_MAX"
 #endif
+#if defined(LZO_DEBUG)
+#  include <stdio.h>
+#endif
+#if defined(__LZO_CHECKER)
+#  include <stdlib.h>
+#endif
 
 
 /***********************************************************************
 //
 ************************************************************************/
 
-#ifndef SWD_N
-#  define SWD_N             N
-#endif
-#ifndef SWD_F
-#  define SWD_F             F
-#endif
-#ifndef SWD_THRESHOLD
-#  define SWD_THRESHOLD     THRESHOLD
-#endif
-
 /* unsigned type for dictionary access - don't waste memory here */
-#if (0UL + SWD_N + SWD_F + SWD_F < 0UL + USHRT_MAX)
-   typedef unsigned short   swd_uint;
-#  define SWD_UINT_MAX      USHRT_MAX
-#elif (0UL + SWD_N + SWD_F + SWD_F < 0UL + UINT_MAX)
-   typedef unsigned         swd_uint;
-#  define SWD_UINT_MAX      UINT_MAX
+#if (0UL + SWD_N + SWD_F + SWD_F < 65535UL)
+   typedef lzo_uint16_t     swd_uint;
+#  define SWD_UINT_MAX      0xffffu
 #else
-   typedef lzo_uint         swd_uint;
-#  define SWD_UINT_MAX      LZO_UINT_MAX
+   typedef lzo_uint32_t     swd_uint;
+#  define SWD_UINT_MAX      0xffffffffu
 #endif
-#define swd_uintp           swd_uint __LZO_MMODEL *
+#define swd_uintp           swd_uint *
 #define SWD_UINT(x)         ((swd_uint)(x))
 
 
@@ -89,22 +70,25 @@
 #endif
 #endif
 
-#if (SWD_THRESHOLD == 1) && !defined(HEAD2)
-#  if 1 && defined(LZO_UNALIGNED_OK_2)
-#    define HEAD2(b,p)      (* (lzo_ushortp) &(b[p]))
+#if !(SWD_NO_HEAD2) && (SWD_THRESHOLD == 1) && !defined(HEAD2)
+#  if 1 && (LZO_OPT_UNALIGNED16)
+#    define HEAD2(b,p)      UA_GET_NE16((b)+(p))
 #  else
-#    define HEAD2(b,p)      (b[p] ^ ((unsigned)b[p+1]<<8))
+#    define HEAD2(b,p)      (b[p] ^ ((unsigned)b[(p)+1]<<8))
 #  endif
 #  define NIL2              SWD_UINT_MAX
 #endif
+#ifndef IF_HEAD2
+#define IF_HEAD2(s)         /*empty*/
+#endif
 
 
 typedef struct
 {
 /* public - "built-in" */
-    lzo_uint n;
-    lzo_uint f;
-    lzo_uint threshold;
+    lzo_uint swd_n;
+    lzo_uint swd_f;
+    lzo_uint swd_threshold;
 
 /* public - configuration */
     lzo_uint max_chain;
@@ -144,32 +128,7 @@ typedef struct
     lzo_uint node_count;
     lzo_uint first_rp;
 
-#if defined(__LZO_MMODEL_HUGE)
-#  define A(type, n)    ((((n) * sizeof(type)) + 3UL) &~ 3UL)
-
-#  define O_b(s)        (0L)
-#  define O_head3(s)    (O_b(s) + A(char, 0UL + SWD_N + SWD_F + SWD_F))
-#  define O_succ3(s)    (O_head3(s) + A(swd_uint, 0UL + SWD_HSIZE))
-#  define O_best3(s)    (O_succ3(s) + A(swd_uint, 0UL + SWD_N + SWD_F))
-#  define O_llen3(s)    (O_best3(s) + A(swd_uint, 0UL + SWD_N + SWD_F))
-# ifdef HEAD2
-#  define O_head2(s)    (O_llen3(s) + A(swd_uint, 0UL + SWD_HSIZE))
-#  define O_END(s)      (O_head2(s) + A(swd_uint, 0UL + 65536L))
-# else
-#  define O_END(s)      (O_llen3(s) + A(swd_uint, 0UL + SWD_HSIZE))
-# endif
-
-#  define S_DEF(s,type,off)  ((type) ((lzo_bytep)s + 0L + sizeof(*s) + off))
-#  define s_b(s)        S_DEF(s, lzo_bytep, O_b(s))
-#  define s_head3(s)    S_DEF(s, swd_uintp, O_head3(s))
-#  define s_succ3(s)    S_DEF(s, swd_uintp, O_succ3(s))
-#  define s_best3(s)    S_DEF(s, swd_uintp, O_best3(s))
-#  define s_llen3(s)    S_DEF(s, swd_uintp, O_llen3(s))
-# ifdef HEAD2
-#  define s_head2(s)    S_DEF(s, swd_uintp, O_head2(s))
-# endif
-
-#elif defined(__LZO_CHECKER)
+#if defined(__LZO_CHECKER)
     /* malloc arrays of the exact size to detect any overrun */
     unsigned char *b;
     swd_uint *head3;
@@ -192,12 +151,9 @@ typedef struct
 #endif
 }
 lzo_swd_t;
-#define lzo_swd_p   lzo_swd_t __LZO_MMODEL *
+#define lzo_swd_p   lzo_swd_t *
 
 
-#if defined(__LZO_MMODEL_HUGE)
-#define SIZEOF_LZO_SWD_T    O_END(0)
-#else
 #define s_b(s)      s->b
 #define s_head3(s)  s->head3
 #define s_succ3(s)  s->succ3
@@ -207,17 +163,17 @@ lzo_swd_t;
 #define s_head2(s)  s->head2
 #endif
 #define SIZEOF_LZO_SWD_T    (sizeof(lzo_swd_t))
-#endif
 
 
 /* Access macro for head3.
- * head3[key] may be uninitialized, but then its value will never be used.
+ * head3[key] may be uninitialized if the list is emtpy,
+ * but then its value will never be used.
  */
-#if defined(__LZO_CHECKER)
+#if 1 || defined(__LZO_CHECKER)
 #  define s_get_head3(s,key) \
-        ((s->llen3[key] == 0) ? SWD_UINT_MAX : s_head3(s)[key])
+        ((swd_uint)((s_llen3(s)[key] == 0) ? SWD_UINT_MAX : s_head3(s)[key]))
 #else
-#  define s_get_head3(s,key)    s_head3(s)[key]
+#  define s_get_head3(s,key)    (s_head3(s)[key])
 #endif
 
 
@@ -231,12 +187,12 @@ void swd_initdict(lzo_swd_p s, const lzo
     s->dict = s->dict_end = NULL;
     s->dict_len = 0;
 
-    if (!dict || dict_len <= 0)
+    if (!dict || dict_len == 0)
         return;
-    if (dict_len > s->n)
+    if (dict_len > s->swd_n)
     {
-        dict += dict_len - s->n;
-        dict_len = s->n;
+        dict += dict_len - s->swd_n;
+        dict_len = s->swd_n;
     }
 
     s->dict = dict;
@@ -252,25 +208,28 @@ void swd_insertdict(lzo_swd_p s, lzo_uin
 {
     lzo_uint key;
 
-    s->node_count = s->n - len;
+    s->node_count = s->swd_n - len;
     s->first_rp = node;
 
-    while (len-- > 0)
+    if (len) do
     {
         key = HEAD3(s_b(s),node);
         s_succ3(s)[node] = s_get_head3(s,key);
         s_head3(s)[key] = SWD_UINT(node);
-        s_best3(s)[node] = SWD_UINT(s->f + 1);
+        s_best3(s)[node] = SWD_UINT(s->swd_f + 1);
         s_llen3(s)[key]++;
-        assert(s_llen3(s)[key] <= SWD_N);
+        assert(s_llen3(s)[key] <= s->swd_n);
 
 #ifdef HEAD2
-        key = HEAD2(s_b(s),node);
-        s_head2(s)[key] = SWD_UINT(node);
+        IF_HEAD2(s) {
+            key = HEAD2(s_b(s),node);
+            s_head2(s)[key] = SWD_UINT(node);
+        }
 #endif
 
         node++;
     }
+    while (--len != 0);
 }
 
 
@@ -281,50 +240,62 @@ void swd_insertdict(lzo_swd_p s, lzo_uin
 static
 int swd_init(lzo_swd_p s, const lzo_bytep dict, lzo_uint dict_len)
 {
-    lzo_uint i = 0;
-    int c = 0;
-
 #if defined(__LZO_CHECKER)
-    s->b = malloc(SWD_N + SWD_F + SWD_F);
-    s->head3 = malloc(sizeof(swd_uint) * SWD_HSIZE);
-    s->succ3 = malloc(sizeof(swd_uint) * (SWD_N + SWD_F));
-    s->best3 = malloc(sizeof(swd_uint) * (SWD_N + SWD_F));
-    s->llen3 = malloc(sizeof(swd_uint) * SWD_HSIZE);
+    s->b = (lzo_bytep) malloc(SWD_N + SWD_F + SWD_F);
+    s->head3 = (swd_uintp) malloc(sizeof(swd_uint) * SWD_HSIZE);
+    s->succ3 = (swd_uintp) malloc(sizeof(swd_uint) * (SWD_N + SWD_F));
+    s->best3 = (swd_uintp) malloc(sizeof(swd_uint) * (SWD_N + SWD_F));
+    s->llen3 = (swd_uintp) malloc(sizeof(swd_uint) * SWD_HSIZE);
 #ifdef HEAD2
-    s->head2 = malloc(sizeof(swd_uint) * 65536L);
+    IF_HEAD2(s) {
+        s->head2 = (swd_uintp) malloc(sizeof(swd_uint) * 65536L);
+    }
+#endif
 #endif
+
+    s->m_len = 0;
+    s->m_off = 0;
+#if defined(SWD_BEST_OFF)
+    {
+        unsigned i;
+        for (i = 0; i < SWD_BEST_OFF; i++)
+            s->best_off[i] = s->best_pos[i] = 0;
+    }
 #endif
 
-    s->n = SWD_N;
-    s->f = SWD_F;
-    s->threshold = SWD_THRESHOLD;
+    s->swd_n = SWD_N;
+    s->swd_f = SWD_F;
+    s->swd_threshold = SWD_THRESHOLD;
 
     /* defaults */
     s->max_chain = SWD_MAX_CHAIN;
-    s->nice_length = SWD_F;
+    s->nice_length = s->swd_f;
     s->use_best_off = 0;
     s->lazy_insert = 0;
 
-    s->b_size = s->n + s->f;
+    s->b_size = s->swd_n + s->swd_f;
 #if 0
-    if (2 * s->f >= s->n || s->b_size + s->f >= SWD_UINT_MAX)
+    if (2 * s->swd_f >= s->swd_n || s->b_size + s->swd_f >= SWD_UINT_MAX)
         return LZO_E_ERROR;
 #else
     LZO_COMPILE_TIME_ASSERT(!(0ul + 2 * SWD_F >= SWD_N))
     LZO_COMPILE_TIME_ASSERT(!(0ul + SWD_N + SWD_F + SWD_F >= SWD_UINT_MAX))
 #endif
     s->b_wrap = s_b(s) + s->b_size;
-    s->node_count = s->n;
+    s->node_count = s->swd_n;
 
-    lzo_memset(s_llen3(s), 0, sizeof(s_llen3(s)[0]) * (lzo_uint)SWD_HSIZE);
+    lzo_memset(s_llen3(s), 0, (lzo_uint)sizeof(s_llen3(s)[0]) * (lzo_uint)SWD_HSIZE);
 #ifdef HEAD2
+    IF_HEAD2(s) {
 #if 1
-    lzo_memset(s_head2(s), 0xff, sizeof(s_head2(s)[0]) * 65536L);
-    assert(s_head2(s)[0] == NIL2);
+        lzo_memset(s_head2(s), 0xff, (lzo_uint)sizeof(s_head2(s)[0]) * 65536L);
+        assert(s_head2(s)[0] == NIL2);
 #else
-    for (i = 0; i < 65536L; i++)
-        s_head2(s)[i] = NIL2;
+        lzo_xint i;
+        for (i = 0; i < 65536L; i++)
+            s_head2(s)[i] = NIL2;
 #endif
+    }
 #endif
 
     s->ip = 0;
@@ -332,21 +303,22 @@ int swd_init(lzo_swd_p s, const lzo_byte
     s->bp = s->ip;
     s->first_rp = s->ip;
 
-    assert(s->ip + s->f <= s->b_size);
+    assert(s->ip + s->swd_f <= s->b_size);
 #if 1
     s->look = (lzo_uint) (s->c->in_end - s->c->ip);
     if (s->look > 0)
     {
-        if (s->look > s->f)
-            s->look = s->f;
+        if (s->look > s->swd_f)
+            s->look = s->swd_f;
         lzo_memcpy(&s_b(s)[s->ip],s->c->ip,s->look);
         s->c->ip += s->look;
         s->ip += s->look;
     }
 #else
     s->look = 0;
-    while (s->look < s->f)
+    while (s->look < s->swd_f)
     {
+        int c;
         if ((c = getbyte(*(s->c))) < 0)
             break;
         s_b(s)[s->ip] = LZO_BYTE(c);
@@ -366,15 +338,15 @@ int swd_init(lzo_swd_p s, const lzo_byte
     else
         s->rp += s->b_size - s->node_count;
 
-#if defined(__LZO_CHECKER)
+#if 1 || defined(__LZO_CHECKER)
     /* initialize memory for the first few HEAD3 (if s->ip is not far
      * enough ahead to do this job for us). The value doesn't matter. */
-    if (s->look < 3)
-        lzo_memset(&s_b(s)[s->bp+s->look],0,3);
+    if (s->look < 3) {
+        lzo_bytep p = &s_b(s)[s->bp+s->look];
+        p[0] = p[1] = p[2] = 0;
+    }
 #endif
 
-    LZO_UNUSED(i);
-    LZO_UNUSED(c);
     return LZO_E_OK;
 }
 
@@ -415,17 +387,17 @@ void swd_getbyte(lzo_swd_p s)
     {
         if (s->look > 0)
             --s->look;
-#if defined(__LZO_CHECKER)
+#if 1 || defined(__LZO_CHECKER)
         /* initialize memory - value doesn't matter */
         s_b(s)[s->ip] = 0;
-        if (s->ip < s->f)
+        if (s->ip < s->swd_f)
             s->b_wrap[s->ip] = 0;
 #endif
     }
     else
     {
         s_b(s)[s->ip] = LZO_BYTE(c);
-        if (s->ip < s->f)
+        if (s->ip < s->swd_f)
             s->b_wrap[s->ip] = LZO_BYTE(c);
     }
     if (++s->ip == s->b_size)
@@ -452,9 +424,10 @@ void swd_remove_node(lzo_swd_p s, lzo_ui
         if (s->first_rp != LZO_UINT_MAX)
         {
             if (node != s->first_rp)
-                printf("Remove %5u: %5u %5u %5u %5u  %6u %6u\n",
-                        node, s->rp, s->ip, s->bp, s->first_rp,
-                        s->ip - node, s->ip - s->bp);
+                printf("Remove %5ld: %5ld %5ld %5ld %5ld  %6ld %6ld\n",
+                        (long)node, (long)s->rp, (long)s->ip, (long)s->bp,
+                        (long)s->first_rp, (long)(s->ip - node),
+                        (long)(s->ip - s->bp));
             assert(node == s->first_rp);
             s->first_rp = LZO_UINT_MAX;
         }
@@ -465,10 +438,12 @@ void swd_remove_node(lzo_swd_p s, lzo_ui
         --s_llen3(s)[key];
 
 #ifdef HEAD2
-        key = HEAD2(s_b(s),node);
-        assert(s_head2(s)[key] != NIL2);
-        if ((lzo_uint) s_head2(s)[key] == node)
-            s_head2(s)[key] = NIL2;
+        IF_HEAD2(s) {
+            key = HEAD2(s_b(s),node);
+            assert(s_head2(s)[key] != NIL2);
+            if ((lzo_uint) s_head2(s)[key] == node)
+                s_head2(s)[key] = NIL2;
+        }
 #endif
     }
     else
@@ -485,7 +460,7 @@ void swd_accept(lzo_swd_p s, lzo_uint n)
 {
     assert(n <= s->look);
 
-    while (n--)
+    if (n) do
     {
         lzo_uint key;
 
@@ -495,18 +470,20 @@ void swd_accept(lzo_swd_p s, lzo_uint n)
         key = HEAD3(s_b(s),s->bp);
         s_succ3(s)[s->bp] = s_get_head3(s,key);
         s_head3(s)[key] = SWD_UINT(s->bp);
-        s_best3(s)[s->bp] = SWD_UINT(s->f + 1);
+        s_best3(s)[s->bp] = SWD_UINT(s->swd_f + 1);
         s_llen3(s)[key]++;
-        assert(s_llen3(s)[key] <= SWD_N);
+        assert(s_llen3(s)[key] <= s->swd_n);
 
 #ifdef HEAD2
         /* add bp into HEAD2 */
-        key = HEAD2(s_b(s),s->bp);
-        s_head2(s)[key] = SWD_UINT(s->bp);
+        IF_HEAD2(s) {
+            key = HEAD2(s_b(s),s->bp);
+            s_head2(s)[key] = SWD_UINT(s->bp);
+        }
 #endif
 
         swd_getbyte(s);
-    }
+    } while (--n != 0);
 }
 
 
@@ -548,9 +525,9 @@ void swd_search(lzo_swd_p s, lzo_uint no
             lzo_uint i;
             assert(lzo_memcmp(bp,&b[node],3) == 0);
 
-#if 0 && defined(LZO_UNALIGNED_OK_4)
+#if 0 && (LZO_OPT_UNALIGNED32)
             p1 += 3; p2 += 3;
-            while (p1 < px && * (const lzo_uint32p) p1 == * (const lzo_uint32p) p2)
+            while (p1 + 4 <= px && UA_GET_NE32(p1) == UA_GET_NE32(p2))
                 p1 += 4, p2 += 4;
             while (p1 < px && *p1 == *p2)
                 p1 += 1, p2 += 1;
@@ -562,8 +539,8 @@ void swd_search(lzo_swd_p s, lzo_uint no
 
 #ifdef LZO_DEBUG
             if (lzo_memcmp(bp,&b[node],i) != 0)
-                printf("%5ld %5ld %02x%02x %02x%02x\n",
-                        (long)s->bp, (long) node,
+                printf("%5ld %5ld %5ld %02x/%02x %02x/%02x\n",
+                        (long)s->bp, (long) node, (long) i,
                         bp[0], bp[1], b[node], b[node+1]);
 #endif
             assert(lzo_memcmp(bp,&b[node],i) == 0);
@@ -611,7 +588,7 @@ lzo_bool swd_search2(lzo_swd_p s)
         return 0;
 #ifdef LZO_DEBUG
     if (lzo_memcmp(&s_b(s)[s->bp],&s_b(s)[key],2) != 0)
-        printf("%5ld %5ld %02x%02x %02x%02x\n", (long)s->bp, (long)key,
+        printf("%5ld %5ld %02x/%02x %02x/%02x\n", (long)s->bp, (long)key,
                 s_b(s)[s->bp], s_b(s)[s->bp+1], s_b(s)[key], s_b(s)[key+1]);
 #endif
     assert(lzo_memcmp(&s_b(s)[s->bp],&s_b(s)[key],2) == 0);
@@ -648,7 +625,7 @@ void swd_findbest(lzo_swd_p s)
     key = HEAD3(s_b(s),s->bp);
     node = s_succ3(s)[s->bp] = s_get_head3(s,key);
     cnt = s_llen3(s)[key]++;
-    assert(s_llen3(s)[key] <= SWD_N + SWD_F);
+    assert(s_llen3(s)[key] <= s->swd_n + s->swd_f);
     if (cnt > s->max_chain && s->max_chain > 0)
         cnt = s->max_chain;
     s_head3(s)[key] = SWD_UINT(s->bp);
@@ -660,15 +637,17 @@ void swd_findbest(lzo_swd_p s)
         if (s->look == 0)
             s->b_char = -1;
         s->m_off = 0;
-        s_best3(s)[s->bp] = SWD_UINT(s->f + 1);
+        s_best3(s)[s->bp] = SWD_UINT(s->swd_f + 1);
     }
     else
     {
-#ifdef HEAD2
-        if (swd_search2(s))
+#if defined(HEAD2)
+        if (swd_search2(s) && s->look >= 3)
+            swd_search(s,node,cnt);
+#else
+        if (s->look >= 3)
+            swd_search(s,node,cnt);
 #endif
-            if (s->look >= 3)
-                swd_search(s,node,cnt);
         if (s->m_len > len)
             s->m_off = swd_pos2off(s,s->m_pos);
         s_best3(s)[s->bp] = SWD_UINT(s->m_len);
@@ -676,7 +655,7 @@ void swd_findbest(lzo_swd_p s)
 #if defined(SWD_BEST_OFF)
         if (s->use_best_off)
         {
-            int i;
+            unsigned i;
             for (i = 2; i < SWD_BEST_OFF; i++)
                 if (s->best_pos[i] > 0)
                     s->best_off[i] = swd_pos2off(s,s->best_pos[i]-1);
@@ -690,14 +669,17 @@ void swd_findbest(lzo_swd_p s)
 
 #ifdef HEAD2
     /* add bp into HEAD2 */
-    key = HEAD2(s_b(s),s->bp);
-    s_head2(s)[key] = SWD_UINT(s->bp);
+    IF_HEAD2(s) {
+        key = HEAD2(s_b(s),s->bp);
+        s_head2(s)[key] = SWD_UINT(s->bp);
+    }
 #endif
 }
 
 
 #undef HEAD3
 #undef HEAD2
+#undef IF_HEAD2
 #undef s_get_head3
 
 
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/lzo_util.c syslinux-4.07b/lzo/src/lzo_util.c
--- Syslinux-4.07a/lzo/src/lzo_util.c	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/lzo_util.c	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -49,18 +37,17 @@
  * keep this copyright string in the executable of your product.
 .*/
 
-const char __lzo_copyright[] =
+static const char __lzo_copyright[] =
 #if !defined(__LZO_IN_MINLZO)
     /* save space as some people want a really small decompressor */
     LZO_VERSION_STRING;
 #else
     "\r\n\n"
     "LZO data compression library.\n"
-    "$Copyright: LZO (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Markus Franz Xaver Johannes Oberhumer\n"
+    "$Copyright: LZO Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer\n"
     "<markus@oberhumer.com>\n"
     "http://www.oberhumer.com $\n\n"
     "$Id: LZO version: v" LZO_VERSION_STRING ", " LZO_VERSION_DATE " $\n"
-    "$Built: " __DATE__ " " __TIME__ " $\n"
     "$Info: " LZO_INFO_STRING " $\n";
 #endif
 
@@ -68,11 +55,7 @@ const char __lzo_copyright[] =
 LZO_PUBLIC(const lzo_bytep)
 lzo_copyright(void)
 {
-#if (LZO_OS_DOS16 && LZO_CC_TURBOC)
-    return (lzo_voidp) __lzo_copyright;
-#else
     return (const lzo_bytep) __lzo_copyright;
-#endif
 }
 
 LZO_PUBLIC(unsigned)
@@ -122,11 +105,11 @@ _lzo_version_date(void)
 #define LZO_DO8(buf,i)  LZO_DO4(buf,i); LZO_DO4(buf,i+4);
 #define LZO_DO16(buf,i) LZO_DO8(buf,i); LZO_DO8(buf,i+8);
 
-LZO_PUBLIC(lzo_uint32)
-lzo_adler32(lzo_uint32 adler, const lzo_bytep buf, lzo_uint len)
+LZO_PUBLIC(lzo_uint32_t)
+lzo_adler32(lzo_uint32_t adler, const lzo_bytep buf, lzo_uint len)
 {
-    lzo_uint32 s1 = adler & 0xffff;
-    lzo_uint32 s2 = (adler >> 16) & 0xffff;
+    lzo_uint32_t s1 = adler & 0xffff;
+    lzo_uint32_t s2 = (adler >> 16) & 0xffff;
     unsigned k;
 
     if (buf == NULL)
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/stats1a.h syslinux-4.07b/lzo/src/stats1a.h
--- Syslinux-4.07a/lzo/src/stats1a.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/stats1a.h	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -45,7 +33,7 @@
 
 
 #ifndef __LZO_STATS1A_H
-#define __LZO_STATS1A_H
+#define __LZO_STATS1A_H 1
 
 #ifdef __cplusplus
 extern "C" {
@@ -58,7 +46,7 @@ extern "C" {
 // used for finetuning, view with a debugger
 ************************************************************************/
 
-#if defined(LZO_COLLECT_STATS)
+#if (LZO_COLLECT_STATS)
 #  define LZO_STATS(expr)   expr
 #else
 #  define LZO_STATS(expr)   ((void) 0)
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/stats1b.h syslinux-4.07b/lzo/src/stats1b.h
--- Syslinux-4.07a/lzo/src/stats1b.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/stats1b.h	2023-02-08 12:45:19.367515476 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -45,7 +33,7 @@
 
 
 #ifndef __LZO_STATS1B_H
-#define __LZO_STATS1B_H
+#define __LZO_STATS1B_H 1
 
 #ifdef __cplusplus
 extern "C" {
@@ -58,14 +46,14 @@ extern "C" {
 // Examine the symbol 'lzo1b_stats' with a debugger.
 ************************************************************************/
 
-#if defined(LZO_COLLECT_STATS)
+#if (LZO_COLLECT_STATS)
 #  define LZO_STATS(expr)   expr
 #else
 #  define LZO_STATS(expr)   ((void) 0)
 #endif
 
 
-#if defined(LZO_COLLECT_STATS)
+#if (LZO_COLLECT_STATS)
 
 typedef struct
 {
diff -uprN -X dontdiff Syslinux-4.07a/lzo/src/stats1c.h syslinux-4.07b/lzo/src/stats1c.h
--- Syslinux-4.07a/lzo/src/stats1c.h	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/lzo/src/stats1c.h	2023-02-08 12:45:19.371515500 +0100
@@ -2,19 +2,7 @@
 
    This file is part of the LZO real-time data compression library.
 
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
+   Copyright (C) 1996-2014 Markus Franz Xaver Johannes Oberhumer
    All Rights Reserved.
 
    The LZO library is free software; you can redistribute it and/or
@@ -45,7 +33,7 @@
 
 
 #ifndef __LZO_STATS1C_H
-#define __LZO_STATS1C_H
+#define __LZO_STATS1C_H 1
 
 #define lzo1b_stats_t       lzo1c_stats_t
 #define lzo1b_stats         lzo1c_stats
diff -uprN -X dontdiff Syslinux-4.07a/mbr/mbr.ld syslinux-4.07b/mbr/mbr.ld
--- Syslinux-4.07a/mbr/mbr.ld	2013-07-25 11:28:59.000000000 +0200
+++ syslinux-4.07b/mbr/mbr.ld	2023-02-08 12:48:09.404469961 +0100
@@ -70,4 +70,5 @@ SECTIONS
   .debug_typenames 0 : { *(.debug_typenames) }
   .debug_varnames  0 : { *(.debug_varnames) }
   /DISCARD/ : { *(.note.GNU-stack) }
+  /DISCARD/ : { *(.note.gnu.property) }
 }
